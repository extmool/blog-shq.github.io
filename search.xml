<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「题解」临沂一中阶段性测试题解</title>
      <link href="/articles/lyyz-test-2018-5-19/"/>
      <url>/articles/lyyz-test-2018-5-19/</url>
      <content type="html"><![CDATA[<p>模拟赛地址（已结束）：　<a href="https://lyoi.org/contest/20" target="_blank" rel="noopener">链接</a></p><p>这里是结尾从来不打句号的Shq的题解</p><h1 id="T1-amp-amp-T4-by-Wyh"><a href="#T1-amp-amp-T4-by-Wyh" class="headerlink" title="T1 &amp;&amp; T4   by Wyh"></a>T1 &amp;&amp; T4   by Wyh</h1><p>T1 &amp;&amp; T4出题人: 最巨的Wyh</p><p>Wyh:</p><blockquote><p>T1和T4都是我出的</p><p>应该不难吧qwq</p><p>我觉得正常人应该能拿个150pts+吧</p></blockquote><h2 id="T1-初中的最后一膜"><a href="#T1-初中的最后一膜" class="headerlink" title="T1 初中的最后一膜"></a>T1 初中的最后一膜</h2><p>这道题就是送分题目啊…</p><p>如果做不出来的话可以参考唐老师的字符串读入课件qwq</p><p>我们可以选择记录四个数字来保留前四个读入的数据，每次判断即可</p><p>不过好像有的同学用bool水过去了？%%%</p><p>（果然我还是太<del>强</del>弱了，空间都卡不好）</p><h2 id="T4-初中的最后一天"><a href="#T4-初中的最后一天" class="headerlink" title="T4 初中的最后一天"></a>T4 初中的最后一天</h2><h3 id="10pts"><a href="#10pts" class="headerlink" title="10pts"></a>10pts</h3><p>我会求最短路！</p><h3 id="20pts"><a href="#20pts" class="headerlink" title="20pts"></a>20pts</h3><p>我会求最短路，还会枚举每一条边!</p><p>天哪20分这么好水</p><h3 id="80-90pts"><a href="#80-90pts" class="headerlink" title="80~90pts"></a>80~90pts</h3><p>分层图最短路</p><p>对于每一个k，建一个指向下一层的，边权减半的边即可 （我说是原题吧</p><p>然后：我会用SPFA！我会用cin！恭喜被卡qwq</p><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>分层图最短路</p><p>我只会写Dijkstra……唉怎么AC了？</p><p>我习惯打快读……唉为什么用cin的90分？</p><p>恭喜出坑。</p><h2 id="Wyh-Code"><a href="#Wyh-Code" class="headerlink" title="Wyh Code:"></a>Wyh Code:</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("str.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("str.out","w",stdout);</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> dr=getchar();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(dr==<span class="string">'0'</span> || dr==<span class="string">'1'</span>) &#123;</span><br><span class="line">now++;</span><br><span class="line">v[now]=dr-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(now&gt;=<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=now<span class="number">-3</span>;i&lt;=now;i++) sum+=v[i];</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=<span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now&gt;=N<span class="number">-5</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) v[i]=v[now<span class="number">-4</span>+i];</span><br><span class="line">now=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">dr=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">125000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,K,W;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXK];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt;</span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w,next;</span><br><span class="line">&#125;e[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].w = w;e[cnt].to = v;e[cnt].next = head[u];head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(inQueue,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inQueue));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(<span class="built_in">std</span>::make_pair(S,<span class="number">0</span>));</span><br><span class="line">    inQueue[S][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dist[S][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.front().first;</span><br><span class="line">        <span class="keyword">int</span> step = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        inQueue[v][step] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[v];i;i = e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v][step] + e[i].w &lt; dist[to][step])&#123;</span><br><span class="line">                dist[to][step] = dist[v][step] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!inQueue[to][step])&#123;</span><br><span class="line">                    inQueue[to][step] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(<span class="built_in">std</span>::make_pair(to,step));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dist[v][step] + e[i].w/<span class="number">2</span> &lt; dist[to][step+<span class="number">1</span>] &amp;&amp; step &lt; K)&#123;</span><br><span class="line">                dist[to][step+<span class="number">1</span>] = dist[v][step] + e[i].w/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(!inQueue[to][step+<span class="number">1</span>])&#123;</span><br><span class="line">                    inQueue[to][step+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    q.push(<span class="built_in">std</span>::make_pair(to,step + <span class="number">1</span>));</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("5.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("5.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;N,&amp;M,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(u,v,w);add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;W);</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">4995</span> &amp;&amp; M == <span class="number">23284</span> &amp;&amp; K == <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"293670\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">1</span>,N);</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= K;i++)</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans,dist[N][i]);</span><br><span class="line">    <span class="keyword">if</span>(ans &lt;= W) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"QaQ\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">   <span class="comment">// getchar();getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wyh: 会莫比乌斯反演的就能AK了吧quq</p><h1 id="T2-by-最弱的Shq"><a href="#T2-by-最弱的Shq" class="headerlink" title="T2 by 最弱的Shq"></a>T2 by 最弱的Shq</h1><p>这道题实在不是防AK的啊quq</p><ul><li>这题是Shq大蒟蒻出的一道有锅的题目</li><li>中途题意炸了不少（</li><li>在考试前数据出了两次锅，题意还改了两三遍quq</li></ul><blockquote><p> 题目是BZOJ2818 Gcd</p></blockquote><h2 id="题目中的一些梗"><a href="#题目中的一些梗" class="headerlink" title="题目中的一些梗"></a>题目中的一些梗</h2><ol><li>PKU(<em>Pig Kingdom University</em>)</li><li>POI(<em>Pig Olympiad in Informatics</em>)</li><li>命运猪之门 (溜了溜了</li><li>P++语言</li><li>猪加索, 猪格拉底..</li><li>\&lt;!– more –></li></ol><h2 id="题面大意"><a href="#题面大意" class="headerlink" title="题面大意"></a>题面大意</h2><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/1.png" alt="题面"></p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><h3 id="40-60-pts"><a href="#40-60-pts" class="headerlink" title="40 ~60 pts"></a>40 ~60 pts</h3><p>期望得分: $40 -60$ (如果出题人够良心的话</p><p>思路: 枚举$(i,j)$再判素，可以达到$O(n^2\log n)$的复杂度quq</p><p>明显，我们可以使用一些数论的方法来优化这个方法</p><h3 id="100-pts"><a href="#100-pts" class="headerlink" title="100 pts"></a>100 pts</h3><p>说实话作为数论这题不算难了quq</p><p>既然我们要求的是$\gcd$为素数的数对, 那$\gcd$里的$x,y$一定是某个素数的倍数 所以枚举素数 </p><p>对于每个素数$prime[i]$对答案的贡献一定与$n\over prime[i]$相关<br>具体的数字大概是从$1$到$n\over prime[i]$这些数里互质数对的数目</p><p>预处理$phi$前缀和$pre$<br>答案就是每一个$pre[{n\over prime[i]}]\times 2-1$</p><p>(乘$2$是因为原题里这些数对反过来用也算是新的,减一是减掉那个重复计算的$(1,1)$)的和 </p><h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC-Code:"></a>AC-Code:</h2><p><strong>Talk is cheap, show me the CODE</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FFF(s,e) for (int i = s; i &lt;= e; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,tot;</span><br><span class="line"><span class="keyword">int</span> phi[MAXN], pri[MAXM];</span><br><span class="line"><span class="keyword">bool</span> mark[MAXN];</span><br><span class="line">ll ans, sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _n = <span class="number">0</span>, _ch = getchar(), _flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(_ch)) _flag |= _ch == <span class="string">'-'</span>, _ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(_ch)) _n = (_n &lt;&lt; <span class="number">3</span>) + (_n &lt;&lt; <span class="number">1</span>) + _ch - <span class="string">'0'</span>, _ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> _flag ? -_n : _n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">FFF(<span class="number">2</span>, n) &#123;</span><br><span class="line"><span class="keyword">if</span>(!mark[i]) &#123;phi[i] = i - <span class="number">1</span>; pri[++tot] = i;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=tot; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = pri[j];</span><br><span class="line"><span class="keyword">if</span>(i * x &gt; n)<span class="keyword">break</span>;</span><br><span class="line">mark[i * x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % x == <span class="number">0</span>) &#123; phi[i * x] = phi[i] * x; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> phi[i * x] = phi[i] * phi[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">n = ReadInt();</span><br><span class="line">getphi();</span><br><span class="line">FFF(<span class="number">1</span>, n) sum[i] = sum[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">FFF(<span class="number">1</span>, tot) ans += sum[n / pri[i]] * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-by-Lgy"><a href="#T3-by-Lgy" class="headerlink" title="T3 by Lgy"></a>T3 by Lgy</h1><blockquote><p> Shq: 然而这题的数据很水，使用大模拟就可以AC</p><p> ​      后面附上了大模拟的代码</p></blockquote><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>设 $ ans = n $<br>暴力处理掉水果，每次循环处理被切的区间，每当有一个没被切掉的水果被切掉时，就让 $ ans = ans - 1 $<br>时间复杂度为 $ O(n^2) $<br>预计能通过前 $ 30\% $ 的数据</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>用线段树维护整个区间，用1表示未被切，用0表示被切。那么整个区间的所有节点的初始值都是1。每次切水果，都把切的区间整体修改为0，代码实现要注意细节。然后查询整段区间的和<br>时间复杂度为 $ O(nlog_2n) $<br>考虑到本题的内存限制，并不能拿到满分</p><h2 id="解法三（标算）"><a href="#解法三（标算）" class="headerlink" title="解法三（标算）"></a>解法三（标算）</h2><p>用  $ ans $ 表示答案。初始化为 $ n $</p><p>对于每一个点，都维护一个变量$f$,表示这个点前面左边第一个没有被切过的点的下标，每次切区间 $ [L, R] $,时，从下标 $ R $开始往左遍历进行处理</p><p>对于当前正在处理的点 $ i $ ,如果 $ f_i = i $ 也就是说这个点没有被切过。那么就使 $ f_i = l - 1 $表示 $ i $ 这个点被切过了，并且 $ i $ 左边第一个没切过的点为 $ l - 1 $,。因为 $ i $ 这个点没有被切过，那么便让 $ ans = ans - 1 $ </p><p>如果 $ f_i \neq i $ ，就说明这个点被切过了，此时只需要跳到 $ f_i $ 就可以了</p><p>每一个点的 $ f $值最多被修改一次。并且切的区间越长遍历的速度也就快，而且切已经切过的区间时遍历速度非常快。时间复杂度为 $ O(n) $。所以这种做法并不会被卡数据，并且时空复杂度都吊打线段树，所以能拿到满分</p><hr><p>综合来说，这套模拟题并非很难，写好爆搜就可以轻松$250+$，</p><p>（附上T3使用大模拟AC的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> cp;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rp = cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rp; i++)</span><br><span class="line">        <span class="keyword">if</span> (!a[i].cp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].l &gt;= x &amp;&amp; a[i].r &lt;= y) a[i].cp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i].l &gt;= x &amp;&amp; a[i].l &lt;= y &amp;&amp; a[i].r &gt; y) a[i].l = y + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (a[i].l &lt; x &amp;&amp; a[i].r &gt;= x &amp;&amp; a[i].r &lt;= y) a[i].r = x - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i].l &lt; x &amp;&amp; a[i].r &gt; y) &#123; </span><br><span class="line">                cnt ++;</span><br><span class="line">                a[cnt].l = y + <span class="number">1</span>;</span><br><span class="line">                a[cnt].r = a[i].r;</span><br><span class="line">                a[i].r = x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">a[<span class="number">1</span>].l = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>].r = n;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"> <span class="keyword">int</span> l, r;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line"> work(l ,r);</span><br><span class="line"> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">          <span class="keyword">if</span> (!a[i].cp) ans += (a[i].r - a[i].l + <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 临沂一中 </tag>
            
            <tag> lyoi </tag>
            
            <tag> 模拟题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「栈」栈在递归转非递归中的应用</title>
      <link href="/articles/recursion-to-no-recursion/"/>
      <url>/articles/recursion-to-no-recursion/</url>
      <content type="html"><![CDATA[<p>为什么要学习递归与非递归的转换的实现方法?</p><ol><li>并不是每一门语言都支持递归的.</li><li>在SD，省选的老年机栈空间十分小</li><li><del>非递归毒瘤</del></li></ol><a id="more"></a><p>递归与非递归转换的原理</p><p>递归与非递归的转换基于以下的原理:所有的递归程序都可以用树结构表示出来.需要说明的是,这个”原理”并没有经过严格的数学证明,只是我的一个猜想,不过在至少在我遇到的例子中是适用的.</p><p><del>稍有常识的人都知道，</del>学习过树结构的人都知道,有三种方法可以遍历树:前序,中序,后序.理解这三种遍历方式的递归和非</p><p>递归的表达方式是能够正确实现转换的关键之处,所以我们先来谈谈这个.需要说明的是,这里以特殊的二叉树说明,不过大多数情况下二叉树已经够用,而且理解了二叉树的遍历,其它的树遍历方式就不难了.</p><h1 id="Step-1-Easy"><a href="#Step-1-Easy" class="headerlink" title="Step 1 - Easy"></a>Step 1 - Easy</h1><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void preorder (root) :</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">not</span> <span class="literal">NULL</span> :</span><br><span class="line">        visit root</span><br><span class="line">        preorder left child</span><br><span class="line">        preorder right child</span><br></pre></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void preorder (Node *root) :</span><br><span class="line">    init <span class="built_in">stack</span> S</span><br><span class="line">push root</span><br><span class="line"><span class="keyword">while</span> Stack S <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">while</span> S.get_top(p) &amp;&amp; p</span><br><span class="line">visit p</span><br><span class="line">            push leftchild</span><br><span class="line">    pop p in S</span><br><span class="line">        <span class="keyword">if</span> Stack S <span class="keyword">not</span> empty :</span><br><span class="line">        pop p in S</span><br><span class="line">push right child in S</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>（略）</p><h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">inorder</span><span class="params">(Bitree T)</span> </span>&#123;</span><br><span class="line">    initstack(S);</span><br><span class="line">    push(S, T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stackempty(S)) &#123;                        </span><br><span class="line">        <span class="keyword">while</span> (gettop(S, p) &amp;&amp; p) push(S, p-&gt;;lchild);</span><br><span class="line">        pop(S, p);</span><br><span class="line">        <span class="keyword">if</span> (!stackempty(S)) &#123;</span><br><span class="line">            pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            push(S, p-&gt;;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>这个就有一些难度了</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>(略)</p><h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    BTNode* ptr;</span><br><span class="line">    <span class="keyword">enum</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125; mark;</span><br><span class="line">&#125;;                           </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_nonrecursive</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Node *a;</span><br><span class="line">    initstack(S);</span><br><span class="line">    push (S,&#123;T,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!stackempty(S)) &#123;</span><br><span class="line">        pop(S,a);</span><br><span class="line">        <span class="keyword">switch</span>(a.mark) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                push(S,&#123;a.ptr,<span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(a.ptr-&gt;;lchild) push(S,&#123;a.ptr-&gt;;lchild,<span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                push(S,&#123;a.ptr,<span class="number">2</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(a.ptr-&gt;;rchild) push(S,&#123;a.ptr-&gt;;rchild,<span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                visit(a.ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Step-2-Normal"><a href="#Step-2-Normal" class="headerlink" title="Step 2 - Normal"></a>Step 2 - Normal</h1><p>如何实现递归与非递归的转换<br>通常,一个函数在调用另一个函数之前,要作如下的事情:</p><ol><li>将实在参数,返回地址等信息传递给被调用函数保存; </li><li>为被调用函数的局部变量分配存储区;</li><li>将控制转移到被调函数的入口.</li></ol><p>从被调用函数返回调用函数之前,也要做三件事情:a</p><ol><li>保存被调函数的计算结果;</li><li>释放被调函数的数据区;</li><li>依照被调函数保存的返回地址将控制转移到调用函数.</li></ol><p>所有的这些,不论是变量还是地址,本质上来说都是”数据”,都是保存在系统所分配的栈中的.</p><p>ok,到这里已经解决了第一个问题:递归调用时数据都是保存在栈中的,有多少个数据需要保存就要设置多少个栈,而且最重要的一点是:控制所有这些栈的栈顶指针都是相同的,否则无法实现同步.</p><p>下面来解决第二个问题:在非递归中,程序如何知道到底要转移到哪个部分继续执行?回到上面说的树的三种遍历方式,抽象出来只有三种操作:访问当前结点,访问左子树,访问右子树.这三种操作的顺序不同,遍历方式也不同.如果我们再抽象一点,对这三种操作再进行一个概括,可以得到:</p><ol><li>访问当前结点:对目前的数据进行一些处理;</li><li>访问左子树:变换当前的数据以进行下一次处理;</li><li>访问右子树:再次变换当前的数据以进行下一次处理(与访问左子树所不同的方式).</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void preorder (root) :</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">not</span> <span class="literal">NULL</span> :</span><br><span class="line">        visit root</span><br><span class="line">        preorder left child</span><br><span class="line">        preorder right child</span><br></pre></td></tr></table></figure><p><code>visit root</code>这个操作就是对当前数据进行的处理, <code>preorder left child</code>就是把当前数据变换为它的左子树,访问右子树的操作可以同样理解了. 现在回到我们提出的第二个问题:如何确定转移到哪里继续执行?关键在于一下三个地方:</p><ol><li>确定对当前数据的访问顺序,简单一点说就是确定这个递归程序可以转换为哪种方式遍历的树结构;</li><li>确定这个递归函数转换为递归调用树时的分支是如何划分的,即确定什么是这个递归调用树的”左子树”和”右子树”</li><li>确定这个递归调用树何时返回,即确定什么结点是这个递归调用树的”叶子结点”.</li></ol><h2 id="三个代表"><a href="#三个代表" class="headerlink" title="三个代表"></a>三个代表</h2><p>好了上面的理论知识已经足够了,下面让我们看看几个例子,结合例子加深我们对问题的认识.即使上面的理论你没有完全明白,不要气馁,对事物的认识总是曲折的,多看多想你一定可以民白 (事实上我也是花了两个星期的时间才弄得比较明白得).</p><h3 id="1-毒瘤的f函数"><a href="#1-毒瘤的f函数" class="headerlink" title="1. 毒瘤的f函数"></a>1. 毒瘤的f函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u1, u2, f;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) f = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u1 = f ((<span class="keyword">int</span>) n / <span class="number">2</span>);</span><br><span class="line">        u2 = f ((<span class="keyword">int</span>) n / <span class="number">4</span>);</span><br><span class="line">        f = u1 * u2；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面按照我们上面说的,确定好递归调用树的结构,这一步是最重要的.首先,什么是叶子结点，我们看到当$n &lt; 2$时$f = n + 1$,这就是返回的语句,有人问为什么不是$f = u_1 \times u_2$,这也是一个返回的语句呀?</p><p>答案是:这条语句是在$u_1 = f\left({n \over 2}\right)$和$u_2 = f\left({n\over 4}\right)$之后执行的,是这两条语句的父结点. 其次,什么是当前结点,由上面的分析,$f = u_1 \times u_2$即是父结点.然后,顺理成章的$u_1 = f\left({n \over 2}\right)$和$u_2 = f\left({n\over 4}\right)$就分别是左子树和右子树了.最后,我们可以看到,这个递归函数可以表示成后序遍历的二叉调用树.好了,树的情况分析到这里,下面来分析一下栈的情况,看看我们要把什么数据保存在栈中,在上面给出的后序遍历的如果这个过程你没非递归程序中我们已经看到了要加入一个标志域,因此在栈中要保存这个标志域;另外,$u_1$,$u_2$和每次调用递归函数时的$n\over 2$和$n\over 4$参数都要保存,这样就要分别有三个栈分别保存:<strong>标志域</strong>,<strong>返回量</strong>和<strong>参数</strong>,不过我们可以做一个优化,因为在向上一层返回的时候,参数已经没有用了,而返回量也只有在向上返回时才用到,因此可以把这两个栈合为一个栈.如果对于上面的分析你没有明白,建议你根据这个递归函数写出它的递归栈的变化情况以加深理解,再次重申一点:前期对树结构和栈的分析是最重要的,如果你的程序出错,那么请返回到这一步来再次分析,最好把递归调用树和栈的变化情况都画出来,并且结合一些简单的参数来人工分析你的算法到底出错在哪里.</p><p>ok,下面给出我花了两天功夫想出来的非递归程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f_nonrecursive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">20</span>], flag[<span class="number">20</span>], cp;</span><br><span class="line">    cp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">0</span>] = n;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cp &gt;;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(flag[cp]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">stack</span>[cp] &gt;;= <span class="number">2</span>) &#123;</span><br><span class="line">                    flag[cp] = <span class="number">1</span>;</span><br><span class="line">                    cp++;</span><br><span class="line">                    <span class="built_in">stack</span>[cp] = (<span class="keyword">int</span>)(<span class="built_in">stack</span>[cp - <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">                    flag[cp] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">stack</span>[cp] += <span class="number">1</span>;</span><br><span class="line">                    flag[cp] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">stack</span>[cp] &gt;;= <span class="number">2</span>) &#123;</span><br><span class="line">                    flag[cp] = <span class="number">2</span>;</span><br><span class="line">                    cp += <span class="number">2</span>;</span><br><span class="line">                    <span class="built_in">stack</span>[cp] = (<span class="keyword">int</span>)(<span class="built_in">stack</span>[cp - <span class="number">2</span>] / <span class="number">4</span>);</span><br><span class="line">                    flag[cp] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">stack</span>[cp] += <span class="number">1</span>;</span><br><span class="line">                    flag[cp] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (flag[cp - <span class="number">1</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="built_in">stack</span>[cp - <span class="number">2</span>] = <span class="built_in">stack</span>[cp] * <span class="built_in">stack</span>[cp - <span class="number">1</span>];</span><br><span class="line">                    flag[cp - <span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">                    cp = cp - <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> </span><br><span class="line">                    cp--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法分析:</p><ol><li>flag只有三个可能值: 0表示第一次访问该结点, 1表示访问的是左子树, 2表示已经结束了对某一棵子树的访问,可能当前结点是这棵子树的右子树,也可能是叶子结点.</li><li>每遍历到某个结点的时候,如果这个结点满足叶子结点的条件,那么把它的flag域设为2;否则根据访问的是根结点,左子树或是右子树来设置flag域,以便决定下一次访问该节点时的程序转向.</li></ol><h3 id="2-毒瘤的快排"><a href="#2-毒瘤的快排" class="headerlink" title="2. 毒瘤的快排"></a>2. 毒瘤的快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i    = left;</span><br><span class="line">    <span class="keyword">int</span> j    = right;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid  = arr[(i + j) / <span class="number">2</span>];  <span class="comment">//取数组中间的值作为“基准值”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid) i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; mid) j--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于基准值移至左边，大于基准值的移至右边</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            temp   = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++; j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; left)  QuickSort(arr, left, j);  <span class="comment">//递归左半数组</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; right) QuickSort(arr, i, right); <span class="comment">//递归右半数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort_nonrecursive</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">50</span>], n[<span class="number">50</span>], cp, p; </span><br><span class="line">    cp = <span class="number">0</span>; m[<span class="number">0</span>] = low; n[<span class="number">0</span>] = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m[cp] &lt; n[cp]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m[cp] &lt; n[cp]) &#123;</span><br><span class="line">            p = partition(<span class="built_in">array</span>, m[cp], n[cp]);</span><br><span class="line">            cp++;</span><br><span class="line">            m[cp] = m[cp - <span class="number">1</span>];</span><br><span class="line">            n[cp] = p - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[cp + <span class="number">1</span>] = n[cp] + <span class="number">2</span>;</span><br><span class="line">        n[cp + <span class="number">1</span>] = n[cp - <span class="number">1</span>];</span><br><span class="line">        cp++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-毒瘤的阿克曼函数"><a href="#3-毒瘤的阿克曼函数" class="headerlink" title="3. 毒瘤的阿克曼函数"></a>3. 毒瘤的阿克曼函数</h3><p>$$akm(i,j) = j + 1 (i == 0)$$<br>$$akm(i,j) = akm(i-1,1)\;\;\;\;\;\; (j == 0)$$<br>$$akm(i,j) = akm(i - 1, akm(i, j - 1)) \;\;\;\;\;\;(m,n != 0)$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">akm_recursive</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> (n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> akm_recursive(m - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = akm_recursive(m, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> akm_recursive(m - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目就当课后习题来说吧</p><hr><p>(未完待续)</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 玄学 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 非递归 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOIP2018提高组游记</title>
      <link href="/articles/NOIP-2018-zero/"/>
      <url>/articles/NOIP-2018-zero/</url>
      <content type="html"><![CDATA[<p>NOIP2018希望有个好成绩，先占坑qwq</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    rp++;　pts++;　rank--;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) AC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
            <tag> NOIP2018 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Manacher算法学习笔记</title>
      <link href="/articles/Manacher/"/>
      <url>/articles/Manacher/</url>
      <content type="html"><![CDATA[<p><strong>最长回文子串问题：给定一个字符串，求它的最长回文子串长度</strong></p><p>我们有两种办法去解决这个问题:</p><p>暴力枚举 $+$ 优化 $\rightarrow$ $O(n^2)$<br>Manacher算法 $\rightarrow$ $O(n)$</p><a id="more"></a><p>回文串: 如果一个字符串正着读和反着读是一样的，那它就是回文串</p><p>栗子: <code>aba</code> , <code>asddsa</code> , <code>123432234321</code> , <code>aa</code></p><p>上述就是几个回文串</p><p>回文子串: 它的所有字串中有回文串</p><p>栗子: <code>aas</code>, <code>adas</code>, <code>sdsasdp</code></p><blockquote><p>注意: 回文子串的长度可能为奇数，也可能为偶数</p></blockquote><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有$n^2$个子串。这些子串的平均长度大约是$n\over 2$，因此这个解法的时间复杂度是$O(n^3)$</p><h2 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h2><p>显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？</p><p>答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为$n$的字符串，这样的位置一共有$n+n-1=2n-1$个，在每个位置上平均大约要进行$n\over 4$次字符比较，于是此算法的时间复杂度是$O(n^2)$</p><hr><h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>这就是这篇文章所重点介绍的了</p><p>下面介绍Manacher算法的原理与步骤</p><p>首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间<strong>插入分隔符</strong>，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用<code>#</code>号。下面举一个栗子</p><table><thead><tr><th>原串</th><th>a</th><th>b</th><th>a</th><th>c</th><th>-</th><th>-</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>变换后的串</td><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>c</td><td>#</td></tr></tbody></table><p>Manacher算法用一个辅助数组$Len[i]$表示以字符$T[i]$为中心的最长回文字串的最右字符到$T[i]$的长度，比如以$T[i]$为中心的最长回文字串是$T[l,r]$,那么$Len[i]=r-i+1$</p><table><thead><tr><th>$T[i]$</th><th>#</th><th>a</th><th>#</th><th>b</th><th>#</th><th>a</th><th>#</th><th>c</th><th>#</th></tr></thead><tbody><tr><td>$len[i]$</td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table><p>$Len$数组有一个性质，那就是$Len[i]-1$就是该回文子串在原字符串$S$中的长度，至于证明，首先在转换得到的字符串$T$中，所有的回文字串的长度都为奇数，那么对于以$T[i]$为中心的最长回文字串，其长度就为$2\times Len[i]-1$,经过观察可知，$T$中所有的回文子串，其中分隔符的数量一定比其他字符的数量多$1$，也就是有$Len[i]$个分隔符，剩下$Len[i]-1$个字符来自原字符串，所以该回文串在原字符串中的长度就为$Len[i]-1$</p><p>有了这个性质，那么原问题就转化为求所有的$Len[i]$</p><p>下面介绍如何在线性时间复杂度内求出所有的$Len$</p><p>首先从左往右依次计算$Len[i]$，当计算$Len[i]$时，$Len<a href="0&lt;j&lt;i">j</a>$已经计算完毕。设$P$为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为$po$，分两种情况：</p><p>第一种情况：$i&lt;=P$</p><p>那么找到$i$相对于$po$的对称位置，设为$j$，那么如果$Len[j]&lt;P-i$，如下图：</p><p><img src="http://img.blog.csdn.net/20141221160212654" alt="img"></p><p>那么说明以$j$为中心的回文串一定在以$po$为中心的回文串的内部，且$j$和$i$关于位置$po$对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以$i$为中心的回文串的长度至少和以$j$为中心的回文串一样，即$Len[i]&gt;=Len[j]$。因为$Len[j]&lt;P-i$,所以说$i+Len[j]&lt;P$。由对称性可知$Len[i]=Len[j]$</p><p>如果$Len[j]&gt;=P-i$, 由对称性，说明以$i$为中心的回文串可能会延伸到$P$之外，而大于$P$的部分我们还没有进行匹配，所以要从$P+1$位置开始一个一个进行匹配，直到发生失配，从而更新$P$和对应的$po$以及$Len[i]$</p><p><img src="http://img.blog.csdn.net/20141221160232375" alt="img"></p><p>第二种情况: $i&gt;P$</p><p>如果$i$比$P$还要大，说明对于中点为$i$的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了，匹配完成后要更新P的位置和对应的$po$以及$Len[i]$</p><p><img src="http://img.blog.csdn.net/20141221160247614" alt="img"></p><p>Manacher算法的时间复杂度分析和Z算法类似，因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于$T$字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为$O(n)$，其中$n$为$T$字符串的长度，由于$T$的长度事实上是$S$的两倍，所以时间复杂度依然是线性的</p><p>注意，为了避免更新$P$的时候导致越界，我们在字符串$T$的前增加一个特殊字符，比如说<code>$</code>,所以算法中字符串是从$1$开始的</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 最长回文子串 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「字符串算法」字符串 hash</title>
      <link href="/articles/KMP-AC-automaton3/"/>
      <url>/articles/KMP-AC-automaton3/</url>
      <content type="html"><![CDATA[<blockquote><p>字符串算法三连击</p></blockquote><h1 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h1><p>如何快速判断两个字符串 $S, T$ 相等？</p><a id="more"></a><p>如果两个字符串被同一个函数 $f : String \rightarrow Int$ 映射到相同的值，也就是 $f(S) = f(T)$，那么有可能 $S = T$</p><p>仔细地选择 $f$，可以使得 $S = T$ 的概率很大，从而完成快速判断</p><p>$$f\left(a_1a_2a_3 · · · a_n\right) = (a_1p^{n−1} + a^2p^{n−2} + a_3p^{n−3} + · · · + a_n) \mod M$$<br>其中 $p$ 取质数（当 $M$ 不是质数的时候降低碰撞概率），例如 $131$。<br>其中 $M$ 可以取：</p><ul><li>$2^{64}$，用 $64$ 位无符号自然溢出，计算速度快</li><li>$10^9$ 级别的质数</li></ul><p>当 $M$ 取 $10^9$ 级别质数的时候，应多取几个 $M$ 以获得更高的正确率（只取一个是不行的）</p><h2 id="Hash快速计算"><a href="#Hash快速计算" class="headerlink" title="Hash快速计算"></a>Hash快速计算</h2><p>给定一个字符串 $S$，要求在 $O(1)$ 时间内快速获得任意一个子串的 $hash$ 函数</p><p>设 $S = a_1a_2a_3 · · · a_n$，那么记：</p><p>$$S(i) = S(i − 1)p + a_i, S(0) = 0$$<br>$$P(i) = p_i$$</p><p>则 $a_la_{l+1} · · · a_r$ 的 $hash$ 函数就是：</p><p>$$S(r) − S(l − 1)P(r − l + 1)$$<br>$O(n)$ 预处理 $S$, $P$，$ O(1)$ 计算子串 $hash$ 函数</p><h2 id="利用Hash求LCP"><a href="#利用Hash求LCP" class="headerlink" title="利用Hash求LCP"></a>利用Hash求LCP</h2><p>LCP：最长公共前缀</p><p>多次询问一个字符串 $S$ 的两个后缀 $S[i :], S[j :]$ 的 LCP，要求每次询问 $O(\log n)$ 时间</p><p>解法:</p><p>多次询问一个字符串 S 的两个后缀 $S[i :], S[j :]$ 的 LCP，要求每次询问 $O(\log n)$ 时间。</p><p>二分长度，问题转化成判断一个字符串的两个子串是否相等。</p><p>利用预处理的 hash 函数解决，判断相等需要 $O(1)$ 时间，加上二分共 $O(\log n)$ 时间。（更好的做法：后缀数组</p><h2 id="利用-hash-比较子串字典序"><a href="#利用-hash-比较子串字典序" class="headerlink" title="利用 hash 比较子串字典序"></a>利用 hash 比较子串字典序</h2><p>多次询问一个字符串 S 的两个子串$S[l_1 : r_1],S[l_2 : r_2]$ 的字典序，要求每次询问 $O(\log n)$ 时间</p><p>先求出这两个子串对应后缀$（ S[l_1 :], S[l_2 :]）$的 LCP，如果这个长度不小于 $\max(r_1 − l_1, r2 − l2) + 1$，那说明这两个字符串相等</p><p>如果这个长度不小于 $\min(r_1 − l_1; r_2 − l_2) + 1$，说明一个子串是另一个子串的前缀，此时长的字符串字典序靠后</p><p>否则判断这个最长公共前缀的后一个字符，哪个字符串对应的后面的字符大说明哪个字符串字典序靠后。（可以利用这个 $O(n \log_2 n)$ 构造后缀数组）</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><blockquote><p>大….大….大水题？</p></blockquote><h2 id="CTSC-2014-企鹅-QQ"><a href="#CTSC-2014-企鹅-QQ" class="headerlink" title="CTSC 2014 企鹅 QQ"></a>CTSC 2014 企鹅 QQ</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给 $n$ 个字符串，如果两个字符串只有一个位置的字符不相同，那么称这两个字符串是相似的。</p><p>字符串的长度都相等，并且字符串两两不同。求一共有多少对相似字符串。</p><p>$n ≤ 3\times 10^4; |S_i| ≤ 200$，时间限制 $2$ 秒</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果两个字符串是相似的，那么去掉某个相同位置的字符后这两个字符串相等，去掉其他相同位置的字符后这两个字符串不等</p><p>枚举删去字符的位置，然后用 hash 的方法计算相等的字符串对数. 对 hash 值构建桶或者对 hash 值排序后统计均可</p><h2 id="HNOI-2014-抄卡组"><a href="#HNOI-2014-抄卡组" class="headerlink" title="HNOI 2014 抄卡组"></a>HNOI 2014 抄卡组</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给 $n$ 个带有通配符 $*$ 的字符串，通配符可以匹配任意多个字符，问这 $n$ 个字符串是否可以代表同一个字符串。</p><p>$n ≤ 10^5, \; n × \max |S| ≤ 2 × 10^8$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果所有字符串都有通配符，判断前缀和后缀是不是相等就可以了。把所有字符串到通配符前的前缀拿出来，按照长度排序，Hash 判断，后缀同理。</p><p>如果所有字符串都不含有通配符， Hash 判断是不是一个字符串。否则拿出一个不含通配符的字符串，如果有其他不含通配符的字符串跟它不相等直接判断出来即可。问题转化为判断一个含有通配符的串是否能等于某个不含有通配符的串，特殊处理前缀和后缀之后，贪心处理中间通配符隔开每一段，跟模版串匹配，顺次匹配成功则答案为可以，否则答案为不可以</p><hr><p>End</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「字符串算法」AC自动机&amp;&amp;KMP自动机入门</title>
      <link href="/articles/KMP-AC-automaton2/"/>
      <url>/articles/KMP-AC-automaton2/</url>
      <content type="html"><![CDATA[<blockquote><p>字符串算法三连击</p></blockquote><p>在讲AC自动机之前我们先来看一下Trie树</p><h1 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h1><p>Trie树可以用于查找一组字符串的前缀</p><p>图示:</p><a id="more"></a><p><img src="http://img.my.csdn.net/uploads/201209/10/1347267156_9178.jpg" alt="Trie"></p><h2 id="最大异或和"><a href="#最大异或和" class="headerlink" title="最大异或和"></a>最大异或和</h2><p>给出 $n$ 个数 $a_1, a_2, · · · , a_n$，求 $max_{x,y}$ $a_i \;xor\; a_j$</p><p>$n ≤ 10^5 ,  a_i ≤ 2^{63} − 1$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把每个数看成是一个 $64$ 长度的二进制串，最高位是第一个字符，对这些二进制串构造一个 Trie 树， Trie 树上记录子树内一共有多少个数</p><p>考虑查询这个集合中的数与 $x$ 异或的最大值，从最高位开始考虑，如果有这一位不同的就应该选择不同的那个分支。这样按照Trie 树走下去，就可以查找出来与 x 异或能得到的最大值</p><p>对于 $a_1$ 到 $a_n$ 每一个都这样做一次，就得到了最大值。时间复杂度 $O(n \log a_i)$</p><h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>给 n 个字符串。现在你可以指定 26 个字母的大小顺序，问哪些<br>字符串可能在指定顺序后变成字典序第一的串。<br>$n ≤ 3\times 10^4, \sum |S| ≤ 3\times 10 ^5$</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先对所有字符串构造一个 Trie 树</p><p>考虑某个字符串能否是字典序最小的。如果这个字符串某个字符$a$ 在 Trie 树上有同层同父亲的边，这条边上字母为 $b$，就说明这会成为一个限制，要求字符 $a$ 在新的大小顺序中必须小于字符$ b$</p><p>把所有 $a$ 小于 $b$ 的限制在图中连一条 $a$ 到 $b$ 的有向边，如果这个图可以拓扑排序，则这个串可以是字典序最小的串。然后对所有字符串都进行判断就可以了</p><h1 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h1><p>自动机的五个组成要素：</p><ul><li>状态集合 $Q$</li><li>初始状态 $q_0 \in Q​$，只能有一个</li><li>接收状态集合$A \subseteq Q$，可以有多个</li><li>字母表 $\sum $</li><li>转移函数 $\delta $ : $Q \times \sum \rightarrow Q$</li></ul><p>上述只是严格的数学形式，然而像我这种大蒟蒻当然是看不懂的，就只能直接看AC自动机了</p><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>在KMP算法中，匹配单个字符的时候，我们只需要按照文本线性的扫一遍，然后中途失配的时候，next数组会引导k回溯到正确的位置进行下一步的匹配。</p><p>但是多个模式串的时候要怎么匹配呢？Trie树不就是一个多模式的匹配吗，如果我们将KMP和Trie数结合起来，是不是会有意想不到的效果呢？</p><p>有了这些思考，AC自动机算法就这样产生了。</p><p>在AC自动机中，我们首先将每一个模式串插入到Trie树中去，建立一棵Trie树，然后构建fail指针，fail指针，顾名思义，就是当匹配失败的时候，用来引导k回溯的一个插穿在Trie树的各个节点之间的一些指针，就和KMP算法中的<code>next</code>数组是一样的道理。</p><p>将所有的字符串构建成一个 <code>Trie</code> 树，按照 BFS 的顺序遍历每个节点，对每个 Trie 树上的节点维护一个 <code>fail</code> 指针</p><p>对于每个节点，如果它有第 $i$ 个儿子，设为 $x$，则顺着当前节点的 <code>fail</code> 指针向上跳。如果跳到的节点有第 $i$ 个儿子，设为 $y$，则 $x$的 <code>fail</code> 指针指向 $y$</p><p><img src="https://images0.cnblogs.com/blog2015/606573/201507/171114540956893.jpg" alt="AC"></p><center>(图不好见谅</center><p>虚线为 <code>fail</code> 指针，可以看出与 KMP 的 <code>next</code> 数组相似的 “<strong>前缀等于后缀</strong>” 的关系</p><h2 id="在AC自动机上匹配"><a href="#在AC自动机上匹配" class="headerlink" title="在AC自动机上匹配"></a>在AC自动机上匹配</h2><p>在AC自动机上匹配,相当于在 Trie 树上匹配，顺着 Trie 树走就可以了。如果某次匹配是失败的，则顺着 <code>fail</code> 指针跳回去，直到匹配成功或者 <code>fail</code> 指针跳到根也没有成功。</p><p>AC 自动机上每一个节点对应匹配的一种 <code>状态</code>，只要我们知道当前走到了 AC 自动机上的哪个节点，无需知道字符串已经匹配的内容就可以继续匹配。利用这点性质可以在这些状态上做递推等</p><h2 id="AC自动机与其他自动机的区别"><a href="#AC自动机与其他自动机的区别" class="headerlink" title="AC自动机与其他自动机的区别"></a>AC自动机与其他自动机的区别</h2><p>AC 自动机的带有 <code>fail</code> 指针的形式还不符合自动机的一般描述，试着把它写成一个自动机的形式。</p><p>在 AC 自动机的状态 $x$ 上，想象下一个需要匹配的字符是 $c$，需要顺着 <code>fail</code> 指针跳到一个有儿子 $c$ 节点的位置。如果一直找不到，那么下一个状态应该是 Trie 树的根。</p><p>注意到这个转移只跟当前状态和下一个需要匹配的字符有关，这正是一般自动机的转移函数 : $Q \times \sum \rightarrow Q​$用这种方式思考递推问题会更容易</p><h1 id="KMP自动机"><a href="#KMP自动机" class="headerlink" title="KMP自动机"></a>KMP自动机</h1><p>KMP 算法就是 AC 自动机算法在单个字符串上的情形，但是因为不需要枚举字符集，所以复杂度是 $O(n)$ 而不是 $O(n|\sum|$。</p><p>一个串对应的 AC 自动机就是 KMP 自动机， KMP 过程相当于在 KMP 自动机上做匹配。 KMP 的 <code>next</code> 数相当于 AC 自动机的 <code>fail</code> 指针</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="HNOI-2008-GT-考试"><a href="#HNOI-2008-GT-考试" class="headerlink" title="HNOI 2008 GT 考试"></a>HNOI 2008 GT 考试</h2><p>给定一个数字串 $S =$ $a_1a_2 · · · a_m$<br>求不出现 $S$ 的 $n$ 位数字串有多少个<br>$n ≤ 10^9, m ≤ 20$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$n$ 很大，考虑矩阵乘法。矩阵乘法本质是递推，递推的状态是什么？</p><p>对 $S$ 构造 AC 自动机，它上面的状态可以描述匹配的进度。<code>f[i][j]</code> 表示 i 位数字串中，在 AC 自动机上匹配状态为 j 的串有多少个。这里对自动机做一点小改造，如果一个串已经匹配成功了，那么不论后续出现什么数字它都已经不应该被记入答案了，所以把 AC 自动机的接受态上的所有转移都连到自己。</p><p>第二维状态只有最多 $m$ 个，且对于第一维来说这是一个线性递推，利用矩阵乘法优化，复杂度可以做到 $O(m^3 \log n)$</p><h2 id="NOI-2011-阿狸的打字机"><a href="#NOI-2011-阿狸的打字机" class="headerlink" title="NOI 2011 阿狸的打字机"></a>NOI 2011 阿狸的打字机</h2><p>有一个打字机，有三种操作</p><ol><li>输入一个字母</li><li>删除最后一个输入的字母</li><li>打印当前字符串</li></ol><p>一共进行了 $n$ 次操作，有 $m$ 个询问，每次询问第 $i$ 个打印的字符串在第 $j$ 个打印的字符串中出现多少次。</p><p>$n ≤ 10^5,\; m ≤ 10^5$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>前两个操作相当于构造了一棵 trie 树，对这个 trie 树构造一个AC 自动机。串 $S$ 是串 $T$ 的子串等价于串 $S$ 是串 $T$ 一个前缀的后缀</p><p>考虑在 Trie 树上询问节点 $x$ 对应串在节点 $y$ 对应串中出现了几次。从节点 $y$ 出发，顺着 <code>fail</code> 指针走，如果能到达节点 $x$，说明 $x$ 是$y$ 的后缀</p><p>所以只需要看从根节点到 $y$ 的路径上，有多少个节点可以沿着<code>fail</code> 指针走到 $x$</p><p>构造 <code>fail</code> 树（这棵树上 $x$ 的父亲就是 $x$ 的 <code>fail</code> 指针），离线处理后相当于这棵树上单点修改子树求和，用树状数组解决</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 自动机 </tag>
            
            <tag> Trie </tag>
            
            <tag> KMP自动机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「字符串算法」KMP算法</title>
      <link href="/articles/KMP-AC-automaton/"/>
      <url>/articles/KMP-AC-automaton/</url>
      <content type="html"><![CDATA[<blockquote><p>字符串算法三连击</p></blockquote><p>本文是介绍KMP算法的运用</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>给定两个字符串 $S, T$，询问 $T$ 是否在 $S$ 中出现过，如果出现过要给出所有出现的位置，时间复杂度 $O\left(\left|S\right| + \left|T\right|\right)$</p><a id="more"></a><p>KMP算法的核心是Next数组</p><h2 id="Next-数组"><a href="#Next-数组" class="headerlink" title="Next 数组"></a>Next 数组</h2><p>定义 $next$ : $String \rightarrow Int$ 函数，它表示一个字符串的最长的严格前缀等于对应长度后缀的长度</p><p>$next(abacaba) = 3$，因为前缀和后缀都是 $aba$，并且没有更长的了</p><p>$next(aaaaa) = 4$，因为前缀和后缀都是 $aaaa$，注意原串 $aaaaa$也同时是前缀和后缀，但我们要求是严格前缀</p><p>$next(abcde) = 0$，因为不存在一个前缀等于对应长度后缀</p><p>对于一个字符串 $S$，我们定义它的 $next$ 数组的第 $i$ 项为 $S$ 前 $i$ 个字符构成的前缀的 $next$ 函数<br>对于字符串 $abacaba$ 来说，它的 $next$ 数组是：<br>$next : 0, 0, 1, 0, 1, 2, 3$</p><h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><p>如果要求 $T$ 是否在 $S$ 中出现过，先求 $T$ 的 $next$ 数组（假设已经求好）</p><p>记录两个指针 $i, j$，表示当前匹配到字符串 $S $的$i $位置，匹配到字符串 $T$ 的 $j$ 位置</p><p>如果 $S_{i + 1} = T_{j + 1}$，该字符匹配成功， $i = i + 1, j = j + 1$</p><p>如果 $S_{i + 1} \neq T_{j + 1}$，匹配失败， $j = next_j$（ $j$ 移动到可行的最后一个位置）</p><p>如果 $j$ 到末尾，说明已经匹配成功，输出匹配位置，并$j = next_j$，表示开始准备下一次匹配</p><h2 id="求Next数组"><a href="#求Next数组" class="headerlink" title="求Next数组"></a>求Next数组</h2><p>核心思想：<strong>自己与自己错位做匹配</strong></p><p>考虑已知 $next_1, next_2 ….. next_p $，求 $next_{p + 1}$</p><p>如果 $S_{p + 1} = S_{next_p + 1}$，那么 $next_{p + 1} = next_p + 1$<br>如果不相等？判断 $S_{p + 1} = S_{next[next_p]} + 1]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != S[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (S[i] == S[j+<span class="number">1</span>]) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP在题目中的应用"><a href="#KMP在题目中的应用" class="headerlink" title="KMP在题目中的应用"></a>KMP在题目中的应用</h1><p>下面是一些$KMP$的题目</p><h2 id="周期串判断"><a href="#周期串判断" class="headerlink" title="周期串判断"></a>周期串判断</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 $S$，问 $S$ 是否是周期串，也就是是否有$S = AAA · · · A$ 这样的形式。如果有找出最短的循环节，否则输出 $−1$。<br>$|S| ≤ 10^5$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑周期串有什么性质：如果 $S = A_k$（ $k$ 个 $A$ 连在一起），那么$A_{k−1}$ 既是 $S$ 的前缀也是 $S$ 的后缀，也就是$A_{k−1}$ 的长度应该等于 $next(S)$</p><p>如果 $|S| − next(S)$ 是 $n$ 的一个约数的话，根据前缀后缀的相等关系我们可以断定 $S$ 必然是周期串，又由于 $next(S)$ 的最大性质，前 $|S| − next(S)$ 个字符一定就是最短循环节。否则 $S$ 必然不是一个周期串。</p><h2 id="CEOI-2011-Match"><a href="#CEOI-2011-Match" class="headerlink" title="CEOI 2011 Match"></a>CEOI 2011 Match</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给出一个长度为 $n$ 的排列 $S$（ $1$ 到 $n$ 的所有数都出现一次），并给出一个长度为 $m$ 的序列 $T$，求 $T$ 的所有满足如下条件的子串：</p><ul><li>该子串长度为 $n$</li><li>该子串的第 $i$ 个数恰为整个子串的第 $S_i$ 大的数</li></ul><p>$n ≤ 10^5; m ≤ 10^5$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>修改一下 KMP 算法中， $S_{i + 1} = T_{j + 1} $中等号的定义.</p><p>定义 $s_i$ 是 $S_i$ 在 $S$ 的前 $i$ 位中的排名。<br>如果 $T$ 的某个子串 $t$ 中， $t_i$ 的排名恰好是 $s_i$，就认为$t_i = S_i$。</p><p>可以用树状数组在将 $T$ 离散化后 $O(\log n)$ 判定。</p><p><strong>Q: 为什么这样做是对的呢？</strong></p><p>考虑当前匹配的指针后移一位，不会影响之前的匹配结果</p><p>实际上就是把排名对应相等的字符串看成是等价的字符串做匹配</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29717271&auto=0&height=66"></iframe><p>End.</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> AC自动机 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分块算法学习笔记</title>
      <link href="/articles/Partitioned-Algorithm/"/>
      <url>/articles/Partitioned-Algorithm/</url>
      <content type="html"><![CDATA[<p>不知道，为什么，最近迷上了暴力数据结构，觉得十分优美</p><p>这篇文章，我们就来讲一讲暴力数据结构 – 分块算法</p><p>暴力就是好看易懂quq（　本来想学一下替罪羊树的，结果….</p><a id="more"></a><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>可能涉及的几个词语解释：</p><ul><li>区间：数列中连续一段的元素</li><li>区间操作：将某个区间$[a,b]$的所有元素进行某种改动的操作</li><li>块：我们将数列划分成若干个不相交的区间，每个区间称为一个块</li></ul><ul><li><strong>整块</strong>：在一个区间操作时，完整包含于区间的块</li><li><strong>不完整的块</strong>：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块</li></ul><h2 id="Step-1-Very-Easy"><a href="#Step-1-Very-Easy" class="headerlink" title="Step 1 - Very Easy"></a>Step 1 - Very Easy</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。</strong></p><p>这是一道能用许多数据结构优化的经典题，可以用于不同数据结构训练，你也可以参考我之前的Treap详解</p><p>数列分块就是把数列中每$m$个元素打包起来，达到优化算法的目的</p><p>以此题为例，如果我们把每$m$个元素分为一块，共有$n\over m$块，每次<strong>区间加的操作会涉及$O\left({n\over m}\right)$个整块，以及区间两侧两个不完整的块中至多$2m$个元素</strong></p><p>我们给每个块设置一个加法标记（就是记录这个块中元素一起加了多少），每次操作对每个整块直接$O(1)$标记，而不完整的块由于元素比较少，暴力修改元素的值</p><p>每次询问时返回元素的值加上其所在块的加法标记(<code>LazyTag</code>?)</p><p>这样每次操作的复杂度是$O({n\over m})+O(m)$，根据均值不等式，当$m$取$\sqrt n$时总复杂度最低，为了方便，我们都默认下文的分块大小为$\sqrt n$</p><p>Code :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(i,j,k) for (int i = j; i &lt; k; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MMM  = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF  = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">float</span> xhalf = <span class="number">0.5f</span> * x;</span><br><span class="line">     <span class="keyword">long</span> i = *(<span class="keyword">long</span>*)&amp;x;</span><br><span class="line">     i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">     x = *(<span class="keyword">float</span> *)&amp;i;</span><br><span class="line">     x = x * (<span class="number">1.5f</span> - xhalf * x * x);</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SlowRead</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'-'</span> &amp;&amp; (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) data = (data &lt;&lt; <span class="number">1</span>) + (data &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> data * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,blo;</span><br><span class="line"><span class="keyword">int</span> v[MAXN],bl[MAXN],atag[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= min(bl[a] * blo, b); i++) v[i] += c;</span><br><span class="line">    <span class="keyword">if</span> (bl[a] != bl[b])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (bl[b] - <span class="number">1</span>) * blo + <span class="number">1</span>; i &lt;= b; i++) v[i] += c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = bl[a] + <span class="number">1</span>; i &lt;= bl[b] - <span class="number">1</span>; i++) atag[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    n = SlowRead(); blo = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    For (i, <span class="number">1</span>, n) v[i] = SlowRead();</span><br><span class="line">    For (i, <span class="number">1</span>, n) bl[i] = (i - <span class="number">1</span>) / blo + <span class="number">1</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = SlowRead();</span><br><span class="line">        <span class="keyword">int</span> a = SlowRead(), b = SlowRead(), c = SlowRead();</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) add (a,b,c);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, v[b] + atag[bl[b]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-2-Easy"><a href="#Step-2-Easy" class="headerlink" title="Step 2 - Easy"></a>Step 2 - Easy</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的元素个数。</strong></p><p>有了上一题的经验，我们可以发现，数列简单分块问题实际上有三项东西要我们思考：</p><p>对于每次区间操作：</p><ol><li><strong>不完整的块 </strong>的$O(\sqrt n)$个元素怎么处理？</li><li>$O(\sqrt n)$个 <strong>整块 </strong>怎么处理？</li><li>要预处理什么信息（复杂度不能超过后面的操作）？</li></ol><p>我们先来思考只有询问操作的情况，不完整的块枚举统计即可；而要在每个整块内寻找小于一个值的元素数，于是我们不得不要求块内元素是有序的，这样就能使用二分法对块内查询，需要预处理时每块做一遍排序，复杂度O(nlogn)，每次查询在$\sqrt n$个块内二分，以及暴力$2 \sqrt n$个元素，总复杂度$O(n\log n + n\times \sqrt n\log\sqrt n)$。</p><p><strong>可以通过均值不等式计算出更优的分块大小，就不展开讨论了</strong></p><p>Q: 那么区间加怎么办呢？</p><p>A: 套用第一题的方法，维护一个加法标记，略有区别的地方在于，不完整的块修改后可能会使得该块内数字乱序，所以头尾两个不完整块需要重新排序，复杂度分析略。</p><p>在加法标记下的询问操作，块外还是暴力，查询小于（x – 加法标记）的元素个数，块内用（x – 加法标记）作为二分的值即可。</p><h2 id="Step-3-Easy"><a href="#Step-3-Easy" class="headerlink" title="Step 3 - Easy"></a>Step 3 - Easy</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的前驱（比其小的最大元素）。</strong></p><p>$n&lt;=100000$其实是为了区分暴力和一些常数较大的写法。</p><p>接着第二题的解法，其实只要把块内查询的二分稍作修改即可。</p><p>不过这题其实想表达：可以在块内维护其它结构使其更具有拓展性，比如放一个 <strong>$set$ </strong>，这样如果还有插入、删除元素的操作，会更加的方便。</p><p><strong>分块的调试检测技巧：</strong></p><p>可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。</p><h2 id="Step-4-Easy"><a href="#Step-4-Easy" class="headerlink" title="Step 4 - Easy"></a>Step 4 - Easy</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，区间求和。</strong></p><p>这题的询问变成了区间上的询问，不完整的块还是暴力；而要想快速统计完整块的答案，需要维护每个块的元素和，先要预处理一下。</p><p>考虑区间修改操作，不完整的块直接改，顺便更新块的元素和；完整的块类似之前标记的做法，直接根据块的元素和所加的值计算元素和的增量。</p><hr><h2 id="Step-5-Normal"><a href="#Step-5-Normal" class="headerlink" title="Step 5 - Normal"></a>Step 5 - Normal</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间开方，区间求和。</strong></p><p>稍作思考可以发现，开方操作比较棘手，主要是对于整块开方时，必须要知道每一个元素，才能知道他们开方后的和，也就是说，难以快速对一个块信息进行更新。</p><p>看来我们要另辟蹊径。不难发现，这题的修改就只有下取整开方，而一个数经过几次开方之后，它的值就会变成 0 或者 1。</p><p>如果每次区间开方只不涉及完整的块，意味着不超过2√n个元素，直接暴力即可。</p><p>如果涉及了一些完整的块，这些块经过几次操作以后就会都变成 0 / 1，于是我们采取一种分块优化的暴力做法，只要每个整块暴力开方后，记录一下元素是否都变成了 0 / 1，区间修改时跳过那些全为 0 / 1 的块即可。</p><p>这样每个元素至多被开方不超过4次，显然复杂度没有问题。</p><h2 id="Step-6-Normal"><a href="#Step-6-Normal" class="headerlink" title="Step 6 - Normal"></a>Step 6 - Normal</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及单点插入，单点询问，数据随机生成。</strong></p><p>先说随机数据的情况</p><p>之前提到过，如果我们块内用数组以外的数据结构，能够支持其它不一样的操作，比如此题每块内可以放一个动态的数组，每次插入时先找到位置所在的块，再暴力插入，把块内的其它元素直接向后移动一位，当然用链表也是可以的。</p><p>查询的时候类似，复杂度分析略。</p><p>但是这样做有个问题，如果数据不随机怎么办？</p><p>如果先在一个块有大量单点插入，这个块的大小会大大超过$\sqrt n$，那块内的暴力就没有复杂度保证了。</p><p>还需要引入一个操作：重新分块（重构）</p><p>每根号$n$次插入后，重新把数列平均分一下块，重构需要的复杂度为$O(n)$，重构的次数为$\sqrt n$，所以重构的复杂度没有问题，而且保证了每个块的大小相对均衡。<br>当然，也可以当某个块过大时重构，或者只把这个块分成两半。</p><hr><h2 id="Step-7-Little-Hard"><a href="#Step-7-Little-Hard" class="headerlink" title="Step 7 - Little Hard"></a>Step 7 - Little Hard</h2><p><strong>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间乘法，区间加法，单点询问。</strong></p><p>很显然，如果只有区间乘法，和$Step 1$ 的做法没有本质区别，但要思考如何同时维护两种标记。</p><p>我们让<strong>乘法标记的优先级高于加法</strong>（如果反过来的话，新的加法标记无法处理）</p><p>若当前的一个块乘以$m_1$后加上$a_1$，这时进行一个乘$m_2$的操作，则原来的标记变成$m1\times m2$，$a1\times m2$</p><p>若当前的一个块乘以$m_1$后加上$a_1$，这时进行一个加$a_2$的操作，则原来的标记变成$m_1$，$a_1+a_2$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4-29模拟赛</title>
      <link href="/articles/18-4-29-test/"/>
      <url>/articles/18-4-29-test/</url>
      <content type="html"><![CDATA[<p>４月的最后一天的模拟赛</p><p>下午模拟赛，中午和Wqy dalao讨论一中午的平衡树，<del>下午都没考到</del></p><p>凉了，140分, rank24</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/pic-teest-jinan-OI/end.png" alt="rank"></p><a id="more"></a><blockquote><h2 id="禁咒检验"><a href="#禁咒检验" class="headerlink" title="禁咒检验"></a>禁咒检验</h2><h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p> 在古老的世界里，有一个神奇的职业叫做魔法师。<br> 魔法师的特点是会魔法。<br> 施放魔法需要念咒语。<br> 在古老的世界里，有一个神奇的职业叫做码农。<br> 码农的工作是帮助魔法师记录咒语。<br> 码农用 0 和 1 来记录咒语，所以一个咒语可以用一个仅由 0 和 1 构成的字符<br> 串 S 表示。<br> 魔法师念咒语时就是把 S 从左到右读一遍。<br> 随着 0 和 1 的默念，魔法的能量从魔法师体内涌出。<br> 如果魔法师连续念的 4 个字符中，‘ 0’的数量不到 2 个，那么魔法师的体力<br> 会大量消耗。如果魔法师念 S 时会出现大量消耗体力的情况，那么 S 就被称为<br> 禁咒。例如“ 010101”不是禁咒，但“ 001101000”是禁咒，因为魔法师会在连<br> 续念出“ 1101”。<br> 码农的一个重要任务，就是帮助魔法师判断一条咒语是不是禁咒。<br> 因为在古老的世界里，还没有印刷术，更没有计算机，所以信息存储全靠手<br> 写，所以如果 S 很长，码农是不会把 S 抄下来的，只会去背下一部分。相应的，<br> 本题的内存仅能使用 3MB。 为避免程序运行时的额外内存计入这 3MB，评测时<br> 会开 6MB，但是你仍应当成 3MB 来写代码，只是不必担心系统抢你仅有的 3MB<br> 内存。</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p> 一行一个字符串 S， 表示咒语</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p> 如果 S 是禁咒， 输出“ Yes”，否则输出“ No”</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><p> 100010101</p><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><p> No<br> 【数据规模和约定】<br> 对于 60%的数据， 1&lt;=|S|&lt;=1000<br> 对于 100%的数据， 1&lt;=|S|&lt;=10^7</p><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><h3 id="【问题描述】-1"><a href="#【问题描述】-1" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p> 组合数 C(n,m)是从 n 个物品中取 m 个的方案数。<br> C(n,m)=(n!)/(m!(n-m)!)<br> 斐波那契数列 F 满足， F[0]=F[1]=1， n≥2 时 F[n]=F[n-1]+F[n-2]<br> 给出 n，求 C(n,0)F[0]+C(n,1)F[1]+…+C(n,n)F[n]</p><h3 id="【输入格式】-1"><a href="#【输入格式】-1" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p> 一行一个数 T 表示数据组数<br> 接下来 T 行每行一个数，表示 n</p><h3 id="【输出格式】-1"><a href="#【输出格式】-1" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p> 输出 T 行， 每行一个数表示答案，对 10^9+7 取模</p><h3 id="【样例输入】-1"><a href="#【样例输入】-1" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><p> 3 2 5<br> 1000</p><h3 id="【样例输出】-1"><a href="#【样例输出】-1" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><p> 5<br> 89<br> 276439883</p><h3 id="【数据规模和约定】"><a href="#【数据规模和约定】" class="headerlink" title="【数据规模和约定】"></a>【数据规模和约定】</h3><p> 对于 30%的数据， n&lt;=10<br> 对于 60%的数据， n&lt;=1000<br> 对于 100%的数据， T&lt;=1000， n&lt;=10^6</p><h2 id="反物质"><a href="#反物质" class="headerlink" title="反物质"></a>反物质</h2><h3 id="【问题描述】-2"><a href="#【问题描述】-2" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><p> 物理学家有一种假设，世界上存在反物质，反物质遇到正常的物质会发生湮<br> 灭。<br> 假设现在有 n 个粒子，每个粒子的种类用一个 m 以内的正整数表示。现在<br> 要将这些粒子按一定顺序放入一个封闭空间。 封闭空间最初什么都没有。<br> 每当放进一个粒子时，若封闭空间为空或封闭空间中的粒子和放入的粒子<br> 种类相同，这个粒子将留在封闭空间中；若封闭空间中的粒子和放入的粒子种<br> 类不同，则封闭空间中会有一个粒子和放入的粒子抵消（即湮灭） 。<br> 判断是否存在一种排序方案，使得最后封闭空间中有种类编号为“ 1” 的粒<br> 子存在。若存在，最大化最后种类编号为“ 1”的粒子个数。若多种方案，要求<br> 字典序最小。</p><h3 id="【输入格式】-2"><a href="#【输入格式】-2" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p> 第 1 行： n 和 m，用空格隔开。<br> 第 2 到 m+1 行：第 i+1 行代表第 i 种粒子有多少个。每种粒子至少有 1 个。<br> 保证粒子总数是 n。</p><h3 id="【输出格式】-2"><a href="#【输出格式】-2" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p> 第 1 行：如果最后封闭空间中可以有编号为“ 1”的粒子存在， 输出 YES。<br> 否则输出 NO。<br> 如果第一行输出了 YES，还需继续输出：<br> 第 2 行：这一行输出最后“ 1”的个数。<br> 第 3…n+2 行：输出在能最后“ 1” 有最大数的排序方案里， 字典序最小的方<br> 案<br> 如果第一行输出了 NO， 就不必输出其他内容了</p><h3 id="【样例输入】-2"><a href="#【样例输入】-2" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><p> 5 3<br> 2 1 2</p><h3 id="【样例输出】-2"><a href="#【样例输出】-2" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><p> YES<br> 1 1 3<br> 2 3 1</p><h3 id="【数据规模和约定】-1"><a href="#【数据规模和约定】-1" class="headerlink" title="【数据规模和约定】"></a>【数据规模和约定】</h3><p> 对于 30%的数据， n&lt;=10<br> 对于 60%的数据， n&lt;=1000<br> 对于 100%的数据， 1&lt;=m&lt;=n&lt;=10^6</p></blockquote><p>T1题意有坑（可能是我理解错了quq），<strong>小于４个字符的咒语是不算禁咒的</strong>!</p><p>所以被卡了两个点，然而没有用优化，第４个点也炸了</p><p>T１总分40ＧＧ</p><p>T２，数论题目</p><p>Ｔ２的数据不强，推出来一个错误的柿子还A了</p><p>Ｔ３贪心GG,而且输出路径炸了，没用字典序 爆零</p><p>总分140 rank24凉凉</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/pic-teest-jinan-OI/result.png" alt=""></p><p>%%% Wyh Rank15以及%%% 吴清月dalao Rank2</p>]]></content>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
            <tag> 清北 </tag>
            
            <tag> qbxt </tag>
            
            <tag> 爆零 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[SDOI2008]烧水问题</title>
      <link href="/articles/P1984-SDOI2008-Water/"/>
      <url>/articles/P1984-SDOI2008-Water/</url>
      <content type="html"><![CDATA[<p>今天下午数论专讲qwq</p><p>然而今天的内容并不是很难（</p><p>先做个水题水一发Blog</p><p><a href="https://www.luogu.org/problemnew/show/P1984" target="_blank" rel="noopener">洛谷链接–SDOI2008烧水问题</a></p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把总质量为$1kg$的水分装在$n$个杯子里，每杯水的质量均为$\left({1\over n}\right)kg$，初始温度均为$0℃$。现需要把每一杯水都烧开。我们可以对任意一杯水进行加热。把一杯水的温度升高$t℃$所需的能量为$\left({4200\times t \over n}\right)\;J$，其中，“$J$”是能量单位“焦耳”。如果一旦某杯水的温度达到$100℃$，那么这杯水的温度就不能再继续升高，此时我们认为这杯水已经被烧开。显然地，如果直接把水一杯一杯地烧开，所需的总能量为$(4200\times 100)J$。</p><p>在烧水的过程中，我们随时可以在两杯温度不同的水之间进行热传递操作。热量只能从温度较高的那杯水传递到温度较低的那杯水。由于两杯水的质量相同，所以进行热传递操作之后，原来温度较高的那杯水所降低的温度总是等于原来温度较低的那杯水所升高的温度。</p><p>一旦两杯水的温度相同，热传递立刻停止。</p><p>为了把问题简化，我们假设：</p><ol><li>没有进行加热或热传递操作时，水的温度不会变化。</li><li>加热时所花费的能量全部被水吸收，杯子不吸收能量。</li><li>热传递总是隔着杯子进行，n杯水永远不会互相混合。</li><li>热传递符合能量守恒，而且没有任何的热量损耗。</li></ol><p>在这个问题里，只要求把每杯水都至少烧开一遍就可以了，而不要求最终每杯水的温度都是$100℃$。我们可以用如下操作把两杯水烧开：先把一杯水加热到$100℃$，花费能量$\left({4200 \times 100 \over 2}\right)J$，然后两杯水进行热传递，直到它们的温度都变成50℃为止，最后把原来没有加热到$100℃$的那杯水加热到$100℃$，花费能量$\left({4200\times50\over 2}\right)J$，此时两杯水都被烧开过了，当前温度一杯$100℃$，一杯$50℃$，花费的总能量为$(4200\times 75)J$，比直接烧开所需的$(4200\times 100)J$少花费了$25%$的能量。</p><p>你的任务是设计一个最佳的操作方案使得n杯水都至少被烧开一遍所需的总能量最少。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>输入文件只有一个数$n$。</p><p>输出格式：</p><p>输出$n$杯水都至少被烧开一遍所需的最少的总能量，单位为$J$，四舍五入到小数点后两位。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">315000.00</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1≤n≤50000</p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看似这题题目很难，其实不然</p><p>我们好好分析一下题目：</p><p>对于每一次加热，我们都有两种操作:</p><ol><li>进行直接加热</li><li>传导加热</li></ol><p>明显，我们应尽量进行2操作，才能得到最优解</p><p>题目中还说了，<strong>至少被烧开一遍</strong>,　也就是说，我们可以在这个前提下进行这样的操作：</p><ol><li>烧开第$i$杯</li><li>将第$i$杯传导导$i+1$杯</li><li>重复以上步骤</li></ol><p>这就是这道题的精髓了</p><p>现在，我们来看一下如何进行该操作</p><p>推导：设沸腾温度为st</p><p>则第一杯温度为$st$,需要加热$t_1=st$</p><p>第二杯可以中和的最高温度为$st/2$,需要加热$t_2={st\over2}$</p><p>第三杯可以中和的最高温度为t3=(a/4+a)/2=5a/8,需要加热t3=3a/8</p><p>第四杯可以中和的最高温度为t4=((a/8+5a/8)/2+a)/2=11a/16,需要加热t4=5/16</p><p>那么，明显地，t3/t2=3/4=1-1/4,  $t4/t3=5/6=1-1/6$<br>继续推导得t(n+1)/t(n)=1-1/2n</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> ans, a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    a = <span class="number">420000.00</span> / n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans += a;</span><br><span class="line">        a *= (<span class="number">1</span> - <span class="number">0.5</span> / i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「树套树」线段树套平衡树</title>
      <link href="/articles/Segt-in-Treap/"/>
      <url>/articles/Segt-in-Treap/</url>
      <content type="html"><![CDATA[<p>线段树套平衡树</p><p>本文Shq将会介绍一种树套树 —线段树套平衡树Treap</p><p>相对来说Treap是较为容易实现的平衡树，就用这个来实现我们的平衡树了.</p><p>当然，这个可以使用其他更为高级的数据结构</p><a id="more"></a><p>这大概是没接触过树套树的同学接触的第一种树套树类型吧<del>(尤其是我)</del></p><p>这种套法一般是用外层的树维护区间信息，在外层树的每一个节点放一棵内层树，内层的树维护权值信息。</p><p>比如说<em>查区间第k大</em>，用套平衡树的做法就是二分权值$val$     -&gt;      到这个区间对应的$log$个线段树节点上查$val$的$rank$值，加起来与目标值进行比较</p><p>这种做法的空间需求是$O(nlogn)$的，由于每个元素都会在$logn$个外层树节点中插入自己</p><p>而时间复杂度上，除了查询区间第k大，每次操作是$O(nlog_2n)$的，</p><p>由于在$logn$个外层树上都要用$O(logn)$的时间查询</p><p>查询第k大是$O(nlog3n)$的，由于在$logn$个外层树上都要用$O(logn)$的时间查询</p><p>由于Treap和线段树我在上几篇文章中就详细介绍过，这里就不再介绍了</p><blockquote><p>传送阵:</p><p>线段树: <a href="https://ishq.site/articles/SegmentTree/" target="_blank" rel="noopener">https://ishq.site/articles/SegmentTree/</a></p><p>Treap: <a href="http://ishq.site/articles/treap/" target="_blank" rel="noopener">http://ishq.site/articles/treap/</a></p></blockquote><p>不多说了，上代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_LOCK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRAND_TIME 20050201</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------Treap Start--------*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, priority;</span><br><span class="line">    <span class="keyword">int</span> size, cnt;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> <span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = root-&gt;left-&gt;size + root-&gt;right-&gt;size + root-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_rotate</span> <span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = root;</span><br><span class="line">    temp-&gt;size = root-&gt;size;</span><br><span class="line">    Update(root);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_rotate</span> <span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    temp-&gt;size = root-&gt;size;</span><br><span class="line">    Update(root);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">valueInsert</span> <span class="params">(Node *root, Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = node;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;size ++;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == node-&gt;key) root-&gt;cnt ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;key &gt; node-&gt;key) &#123;</span><br><span class="line">        valueInsert(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left-&gt;priority &lt; root-&gt;priority) Right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        valueInsert(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right-&gt;priority &lt; root-&gt;priority) Left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *node = <span class="keyword">new</span> Node();</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;size = node-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">    node-&gt;priority = rand();</span><br><span class="line">    valueInsert (root, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span> <span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            root-&gt;cnt--;</span><br><span class="line">            root-&gt;size--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left-&gt;priority &lt; root-&gt;right-&gt;priority) &#123;</span><br><span class="line">            Right_rotate (root);</span><br><span class="line">            Delete (root, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Left_rotate (root);</span><br><span class="line">            Delete (root, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        Delete (root-&gt;left, key);</span><br><span class="line">        root-&gt;size--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Delete (root-&gt;right, key);</span><br><span class="line">        root-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------SegmentTree Start------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span> <span class="params">(Node *root,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> x, <span class="keyword">int</span> key, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Delete (root, y);</span><br><span class="line">    Insert (root, key);</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) Change(root-&gt;left, left, mid, x, key, y);</span><br><span class="line">    <span class="keyword">else</span> Change(root-&gt;right, mid + <span class="number">1</span>, right, x, key, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(Node *root,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> x, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Insert(root, num);</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) build(root-&gt;left, left, mid, x, num);</span><br><span class="line">    <span class="keyword">else</span> build(root-&gt;right, mid + <span class="number">1</span>, right, x, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;key &lt;= key) &#123;</span><br><span class="line">        tmp += root-&gt;left-&gt;size + root-&gt;cnt;</span><br><span class="line">        find(root-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> find(root-&gt;left, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Node *root,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == x &amp;&amp; right == y) &#123;</span><br><span class="line">        find(root, num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= y) query(root-&gt;left, left, mid, x, y, num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; x) query(root-&gt;right, mid + <span class="number">1</span>, right, x, y, num);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       query(root-&gt;left, left, mid, x, mid, num);</span><br><span class="line">       query(root-&gt;right, mid + <span class="number">1</span>, right, mid + <span class="number">1</span>, y, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************End**********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SlowRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'-'</span> &amp;&amp; (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) data = (data &lt;&lt; <span class="number">1</span>) + (data &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> data * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> opt, n, m;</span><br><span class="line"><span class="keyword">int</span> Data[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FILE_LOCK</span></span><br><span class="line">    freopen (<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"ans.ans"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    srand(SRAND_TIME);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">while</span>(opt--) &#123;</span><br><span class="line">        n = SlowRead(); m = SlowRead();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Data[i] = SlowRead();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) build(root, <span class="number">1</span>, n, i, Data[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> opts[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opts);</span><br><span class="line">            <span class="keyword">if</span>(opts[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                Change(root, <span class="number">1</span>, n, x, y, Data[x]);</span><br><span class="line">                Data[x] = y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1000000000</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    tmp = <span class="number">0</span>;</span><br><span class="line">                query(root, <span class="number">1</span>, n, x, y, mid);</span><br><span class="line">                    <span class="keyword">if</span>(tmp &gt;= z) r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完美结束</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树套树 </tag>
            
            <tag> Treap </tag>
            
            <tag> 数堆 </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zkw线段树</title>
      <link href="/articles/zkw-tree-algorithm/"/>
      <url>/articles/zkw-tree-algorithm/</url>
      <content type="html"><![CDATA[<p>$zkw$线段树是一种十分好用的线段树</p><p>特点： 非递归，效率高，代码短 </p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li>一个节点的父节点是这个数左移$1$，这个位运算就是低位舍弃，所有数字左移一位</li><li>一个节点的子节点是这个数右移$1$，是左节点，右移$1$, $+1$是右节点</li><li>同一层的节点是依次递增的，第$n$层有$2^{n-1}$个节点</li><li>最后一层有多少节点，值域就是多少(这个很重要)</li></ul><p>有了这些知识就可以开始着手建树了</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><h3 id="查询区间-left-1-n-right"><a href="#查询区间-left-1-n-right" class="headerlink" title="查询区间$\left[1,n\right]$"></a>查询区间$\left[1,n\right]$</h3><p>$Build$函数就这么出来了！找到不小于$n$的$2$的次幂<br>直接输入叶节点的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, M, q;</span><br><span class="line"><span class="keyword">int</span> d[N &lt;&lt; <span class="number">1</span>];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(M = <span class="number">1</span>; M &lt; n; M &lt;&lt;= <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= M + n; i++) d[i] = in();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护父节点信息</p><p>倒<em>续</em>访问，每个节点访问的时候它的子节点已经处理过辣！</p><h3 id="维护区间和"><a href="#维护区间和" class="headerlink" title="维护区间和"></a>维护区间和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = M - <span class="number">1</span>; i; i--) d[i] = d[i &lt;&lt; <span class="number">1</span>] + d[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="维护最大值"><a href="#维护最大值" class="headerlink" title="维护最大值"></a>维护最大值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = M - <span class="number">1</span>; i; i--) d[i] = max(d[i &lt;&lt; <span class="number">1</span>], d[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="维护最小值"><a href="#维护最小值" class="headerlink" title="维护最小值"></a>维护最小值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = M - <span class="number">1</span>; i; i--) d[i] = min(d[i &lt;&lt; <span class="number">1</span>], d[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>这样就构造出了一颗二叉树，也就是zkw线段树了！ </p><h2 id="操作-opt"><a href="#操作-opt" class="headerlink" title="操作/$opt$"></a>操作/$opt$</h2><h3 id="单点修改w"><a href="#单点修改w" class="headerlink" title="单点修改w"></a>单点修改w</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;  </span><br><span class="line">    d[x = M + x] += v;  </span><br><span class="line">    <span class="keyword">while</span> (x) d[x &gt;&gt;= <span class="number">1</span>] = d[x &lt;&lt; <span class="number">1</span>] + d[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点查询-差分思想，后面会用到"><a href="#单点查询-差分思想，后面会用到" class="headerlink" title="单点查询(差分思想，后面会用到)"></a>单点查询(差分思想，后面会用到)</h3><p>把d维护的值修改一下，变成维护它与父节点的差值(为后面的RMQ问题做准备)<br>建树的过程就要修改一下咯！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(M = <span class="number">1</span>; M &lt;= n + <span class="number">1</span>; M &lt;&lt;= <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= M + n; i++) d[i] = in();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = M - <span class="number">1</span>; i; i--) d[i] = min(d[i &lt;&lt; <span class="number">1</span>], d[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), d[i &lt;&lt; <span class="number">1</span>] - = d[i], d[ i&lt;&lt; <span class="number">1</span> | <span class="number">1</span>] -= d[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前情况下的查询</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> res = <span class="number">0</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (x) res += d[x], x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h3><p>询问区间和，把$\left[s,t\right]$闭区间换成$\left(s,t\right)$开区间来计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> Ans = <span class="number">0</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (s = s + M - <span class="number">1</span>, t = t + M + <span class="number">1</span>; s ^ t ^ <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(~s &amp; <span class="number">1</span>) Ans += d[s ^ <span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">if</span>( t &amp; <span class="number">1</span>) Ans += d[t ^ <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么$~s\&amp;1$?</li><li>为什么 $t\&amp;1$?<br><img src="https://img-blog.csdn.net/20160329205751804" alt="这里写图片描述"><br>变成开区间了以后，如果$s$是左儿子，那么它的兄弟节点一定在区间内，同理，如果$t$是右儿子，那么它的兄弟节点也一定在区间内！</li><li>这样计算不会重复吗？</li></ul><p>答案是会的！所以注意迭代的出口<code>s^t^1</code><br>如果$s,t$就是兄弟节点，那么也就迭代完成了。</p><h3 id="区间最小值"><a href="#区间最小值" class="headerlink" title="区间最小值"></a>区间最小值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> L = <span class="number">0</span>, <span class="keyword">int</span> R = <span class="number">0</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(s = s + M - <span class="number">1</span>, t = t + M + <span class="number">1</span>; s ^ t ^ <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) &#123;   </span><br><span class="line">        L += d[s], R += d[t];  </span><br><span class="line">        <span class="keyword">if</span>(~s &amp; <span class="number">1</span>) L = min(L, d[s ^ <span class="number">1</span>]);  </span><br><span class="line">        <span class="keyword">if</span>( t &amp; <span class="number">1</span>) R = min(R, d[t ^ <span class="number">1</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> res = min(L, R); </span><br><span class="line">    <span class="keyword">while</span> (s) res += d[s &gt;&gt;= <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间最大值"><a href="#区间最大值" class="headerlink" title="区间最大值"></a>区间最大值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> L = <span class="number">0</span>, <span class="keyword">int</span> R = <span class="number">0</span>)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(s = s + M - <span class="number">1</span>, t = t + M + <span class="number">1</span>; s ^ t ^ <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        L += d[s], R += d[t];  </span><br><span class="line">        <span class="keyword">if</span>(~s &amp; <span class="number">1</span>) L = max(L, d[s ^ <span class="number">1</span>]);  </span><br><span class="line">        <span class="keyword">if</span>( t &amp; <span class="number">1</span>) R = max(R, d[t ^ <span class="number">1</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> res = max(L, R);</span><br><span class="line">    <span class="keyword">while</span> (s) res += d[s &gt;&gt;= <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间加法"><a href="#区间加法" class="headerlink" title="区间加法"></a>区间加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> v, <span class="keyword">int</span> A = <span class="number">0</span>)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(s = s + M - <span class="number">1</span>, t = t + M + <span class="number">1</span>; s ^ t ^ <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(~s &amp; <span class="number">1</span>) d[s ^ <span class="number">1</span>] += v;</span><br><span class="line">        <span class="keyword">if</span>( t &amp; <span class="number">1</span>) d[t ^ <span class="number">1</span>] += v;  </span><br><span class="line">        A = min(d[s], d[s ^ <span class="number">1</span>]); d[s] -= A, d[s ^ <span class="number">1</span>] -=A, d[s &gt;&gt; <span class="number">1</span>] += A;  </span><br><span class="line">        A = min(d[t], d[t ^ <span class="number">1</span>]); d[t] -= A, d[t ^ <span class="number">1</span>] -=A, d[t &gt;&gt; <span class="number">1</span>] += A;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (s) A = min (d[s], d[s ^ <span class="number">1</span>]), d[s] -= A, d[s ^ <span class="number">1</span>] -= A, d[s &gt;&gt;= <span class="number">1</span>] += A;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zkw线段树小试牛刀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;   </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">261244</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">524289</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f, x, y; </span><br><span class="line"><span class="keyword">int</span> tr[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (s = s + M - <span class="number">1</span>, t = t + M + <span class="number">1</span>; s ^ t ^ <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">         <span class="keyword">if</span> (~s &amp; <span class="number">1</span>) ans += tr[s ^ <span class="number">1</span>];  </span><br><span class="line">         <span class="keyword">if</span> ( t &amp; <span class="number">1</span>) ans += tr[t ^ <span class="number">1</span>];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (tr[x += M] += y, x &gt;&gt;= <span class="number">1</span>; x; x &gt;&gt;= <span class="number">1</span>) tr[x] = tr[x &lt;&lt; <span class="number">1</span>] + tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;   </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;x); change(i, x); &#125;  </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;m);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d%d%d"</span>, &amp;f, &amp;x, &amp;y);  </span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">1</span>) change (x, y);  </span><br><span class="line">        <span class="keyword">else</span> query (x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可持久化线段树版本？！（来自<a href="http://blog.csdn.net/forget311300/article/details/44306265）" target="_blank" rel="noopener">http://blog.csdn.net/forget311300/article/details/44306265）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) make_pair(x,y)    </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">10</span>];    </span><br><span class="line"><span class="keyword">int</span> b[N + <span class="number">10</span>];    </span><br><span class="line"><span class="keyword">int</span> M;    </span><br><span class="line"><span class="keyword">int</span> lq, rq;    </span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s[N * <span class="number">22</span>];    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> cur)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cur += M;    </span><br><span class="line">    <span class="keyword">int</span> lat = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">if</span> (s[cur].size())    </span><br><span class="line">        lat = s[cur][s[cur].size() - <span class="number">1</span>].second;    </span><br><span class="line">    s[cur].push_back(mp(id, ++lat));    </span><br><span class="line">    <span class="keyword">for</span> (cur &gt;&gt;= <span class="number">1</span>; cur; cur &gt;&gt;= <span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">if</span> (s[cur &lt;&lt; <span class="number">1</span>].size())    </span><br><span class="line">            l = s[cur &lt;&lt; <span class="number">1</span>][s[cur &lt;&lt; <span class="number">1</span>].size() - <span class="number">1</span>].second;    </span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">if</span> (s[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].size())    </span><br><span class="line">            r = s[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][s[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].size() - <span class="number">1</span>].second;    </span><br><span class="line">        s[cur].push_back(mp(id, l + r));    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> k)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (id &gt;= M) <span class="keyword">return</span> id - M;    </span><br><span class="line">    <span class="keyword">int</span> l = id &lt;&lt; <span class="number">1</span>, r = l ^ <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> ll = lower_bound(s[l].begin(), s[l].end(), mp(lq, inf)) - s[l].begin() - <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> rr = lower_bound(s[l].begin(), s[l].end(), mp(rq, inf)) - s[l].begin() - <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> kk = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">if</span> (rr &gt;= <span class="number">0</span>)kk = s[l][rr].second;    </span><br><span class="line">    <span class="keyword">if</span> (ll &gt;= <span class="number">0</span>)kk = s[l][rr].second - s[l][ll].second;    </span><br><span class="line">    <span class="keyword">if</span> (kk &lt; k)<span class="keyword">return</span> Q(r, k - kk);    </span><br><span class="line">    <span class="keyword">return</span> Q(l, k);    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> n, m;    </span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);    </span><br><span class="line">            b[i] = a[i];    </span><br><span class="line">        &#125;    </span><br><span class="line">        sort(b, b + n);    </span><br><span class="line">        <span class="keyword">int</span> nn = unique(b, b + n) - b;    </span><br><span class="line">        <span class="keyword">for</span> (M = <span class="number">1</span>; M &lt; nn; M &lt;&lt;= <span class="number">1</span>);    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M + M; i++)    </span><br><span class="line">        &#123;    </span><br><span class="line">            s[i].clear();    </span><br><span class="line">            <span class="comment">//s[i].push_back(mp(0, 0));    </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">int</span> id = lower_bound(b, b + nn, a[i]) - b;    </span><br><span class="line">            add(i + <span class="number">1</span>, id);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">while</span> (m--)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">int</span> k;    </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;lq, &amp;rq, &amp;k);    </span><br><span class="line">            lq--;    </span><br><span class="line">            <span class="keyword">int</span> x = Q(<span class="number">1</span>, k);    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[x]);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> zkw线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「图论」二分图</title>
      <link href="/articles/er-fen-tu/"/>
      <url>/articles/er-fen-tu/</url>
      <content type="html"><![CDATA[<p>在火车上先水一发二分图最大匹配吧</p><p>二分图，是图论中一种十分常用的模型</p><a id="more"></a><p>$G=\left(V, E\right)$是一个无向图</p><p>如果$G$的顶点集$V$可分割为两个互不相交的子集$X$和$Y$，并且$E$中每条边连接的两个顶点一个在$X$中，另一个在$Y$中，则称图$G$为<strong>二分图</strong>，记为$G=\left( X , Y , E \right )$</p><p>那么，问题来了：</p><center>给定一个无向联通图，如何判定该图是否为一个二分图？</center><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>给定一个二分图$G=(X,Y,E)$</p><p>若存在$E$的一个子集$M$，满足$M$中的任意两条边都没有公共顶点，则$M$称为一个$G$的<strong>匹配</strong></p><p>一些概念：</p><ul><li><em>匹配边</em>：在匹配中的边</li><li><em>未匹配边</em>：不在匹配中的边</li><li><em>未匹配点</em>：对于一个匹配，不与任何匹配边邻接的点</li><li><em>匹配点</em>：刚好相反</li></ul><ul><li><em>极大匹配</em>：无法再加边的匹配</li><li><em>最大匹配</em>：在所有极大匹配中，边数$|M|$最大的匹配</li><li><em>完全匹配</em>：如果一个匹配中，图中每个顶点都与一条边相关联，则称此匹配为<strong>完全匹配</strong></li></ul>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>济南7日游Day - $-1$</title>
      <link href="/articles/18-4-27-things/"/>
      <url>/articles/18-4-27-things/</url>
      <content type="html"><![CDATA[<blockquote><p>梦回济南</p></blockquote><p>回首过往，我已经发表了$50 +$篇文章了，看来离6月份前$100+$篇还是一个很遥远的目标</p><p>在去济南前先水一发随笔吧，也就当是个目标了</p><a id="more"></a><p>4月28 ，济南</p><p>我没学习的算法还有不少。</p><p>打算在济南好好学习图论，毕竟图论我还是落下了不少</p><p>然而并没有什么时间去颓废了qwq，时间也不多了。想想去年济南，真是浪费了太多时间，又有多少时间可以浪费呢</p><p>先列个计划吧，已掌握的就当做复习了</p><ul><li style="list-style: none"><input type="checkbox" checked> 最短路</li><li style="list-style: none"><input type="checkbox" checked> 最小生成树</li><li style="list-style: none"><input type="checkbox" checked> 二分图</li><li style="list-style: none"><input type="checkbox" checked> Tarjia<del>n</del></li><li style="list-style: none"><input type="checkbox" checked> <del>网络流</del></li></ul><p>以上只是大体，我也没具体列举到细节，也待日后补充吧。在济南的这几天也尽量多发几篇题解笔记，<code>刷题好，刷好题，好刷题</code>。</p><p>最近换了Deepin，<code>Hexo</code> , <code>Git</code> , <code>npm</code> 都重新装了一遍（装炸了好几次，最后一看都是权限的问题，哭晕在厕所.jpg</p><p>Deepin美化还是十分好的了，我就不用在自己重新美化了qwq</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35625821&auto=0&height=66"></iframe>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 济南 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shq&#39;s code style</title>
      <link href="/articles/Code-Style-for-OI/"/>
      <url>/articles/Code-Style-for-OI/</url>
      <content type="html"><![CDATA[<p>本文是介绍Shq大蒟蒻的代码规范</p><a id="more"></a><p>example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x == y) &#123;</span><br><span class="line">    something();</span><br><span class="line">    somethingelse();</span><br><span class="line">&#125;</span><br><span class="line">finalthing();</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp; res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (JS_DefineProperty(cx, o, <span class="string">"data"</span>, STRING_TO_JSVAL(JS_NewStringCopyN(cx, data, res)), <span class="literal">NULL</span>, <span class="literal">NULL</span>, JSPROP_ENUMERATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        QUEUE_EXCEPTION(<span class="string">"Internal error!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    PQfreemem(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (JS_DefineProperty(cx, o, <span class="string">"data"</span>, OBJECT_TO_JSVAL(<span class="literal">NULL</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, JSPROP_ENUMERATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        QUEUE_EXCEPTION(<span class="string">"Internal error!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include</code> 中，C 标准库头文件<strong>必须</strong>使用 <code>c</code> 前缀，而不是 <code>.h</code> 后缀。</p><p>所有的 <code>#include &lt;...&gt;</code> 指令<strong>必须</strong>放置于整个程序开头</p><p>所有头文件<em>应该</em>由长度排序</p><p>不同功能的头文件<em>应该</em>分开</p><p>example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>对于每个代码块，使用 <code>4</code> 空格或等长的 <code>Tab</code>严格缩进</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">astyle参数: --indent=spaces=4</span><br></pre></td></tr></table></figure><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>大括号不换行！大括号不换行！大括号不换行！</p><p>左括号的左边<strong>必须</strong>有且仅有一个空格</p><p>example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spaw</span> <span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b ^= a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>逗号 <code>,</code> 与 <code>for</code> 中的分号 <code>;</code> 后面<strong>必须</strong>有一个空格，前面<strong>不能</strong>有空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br></pre></td></tr></table></figure><p>左圆（方）括号后、右圆（方）括号前，在书写长表达式时，为了便于阅读，<em>可以</em>加一个空格，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = f[ f[i][j - <span class="number">1</span>] ][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>双目运算符、三目运算符的两侧<strong>必须</strong>有一个空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br></pre></td></tr></table></figure><p>单目运算符的两侧<strong>不能</strong>有空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tot++;</span><br></pre></td></tr></table></figure><p>冒号的两侧<strong>必须</strong>有一个空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    Edge() : x(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程控制关键字之后，左圆括号前<strong>必须</strong>有一个空格，函数名之后，左圆括号前<em>可以</em>有空格。</p><p>对于「花括号不换行」，<code>do-while</code> 结构的 <code>do</code> 之后，左花括号前<strong>必须</strong>有一个空格，<code>while</code> 前<strong>必须</strong>有一个空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    c++;</span><br><span class="line">&#125; <span class="keyword">while</span> (c &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>模板参数表中，如果右方括号前不得不加一个空格，则<em>可以</em>在对应的左方括号后加一个空格，为了对称。</p><p><code>.</code>、<code>-&gt;</code>、<code>::</code> 的两边<strong>不能</strong>有空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, priority;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_rotate</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>多个意义独立的代码块之间<em>应该</em>用空行隔开</p><p>右花括号前<em>不应该</em>有多余的空行</p><p><em>不应该</em>有两个连续的空行</p><p>非空行尾<em>不应该</em>有多余的空格</p><p>所有的 <code>#include</code> 指令之后<strong>必须</strong>有一个空行</p><p>函数、成员函数、结构体、全局变量块之间<strong>必须</strong>用空行隔开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> p, q, x, y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">bool</span> Flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> argv[])</span> </span>&#123;</span><br><span class="line">    p = <span class="number">1</span>, q = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>main</code> 函数的返回值类型<strong>必须</strong>是 <code>int</code>，<strong>不可以</strong>省略 <code>return 0;</code></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><em>应该</em>尽量少使用全局变量</p><p>局部变量<strong>必须</strong>在用时定义，变量名<em>不应该</em>与上一个块中的变量重名，<em>可以</em>与全局变量重名</p><h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><p>在描述类型名时，指针符号 <code>*</code> 和引用符号 <code>&amp;</code> 与左侧的类型名之间<strong>必须</strong>有一个空格，与右侧的其它关键字之间<strong>不能</strong>有空格，如 <code>char *const</code> 或 <code>int *&amp;</code></p><p>在定义变量、函数返回值、参数时，指针符号 <code>*</code> 和引用符号 <code>&amp;</code> 与左侧的类型名之间<strong>必须</strong>有一个空格，与右侧的变量、函数、参数名之间<strong>不能</strong>有空格</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>所有结构体、函数、变量、参数名<strong>必须</strong>使用驼峰命名法，其中结构体名首字母<strong>必须</strong>大写，其它首字母<strong>必须</strong>小写</p><p>为方便，命名中的单词<em>可以</em>使用缩写，函数、变量、参数名<em>可以</em>用一个小写字母代替。全局数组<em>可以</em>命名为一个大写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, priority;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i * f(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>到这里就是Shq毒瘤的代码习惯了</p>]]></content>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lgy起源</title>
      <link href="/articles/lgy-from/"/>
      <url>/articles/lgy-from/</url>
      <content type="html"><![CDATA[<p>很久很久以前，我们的宇宙比现在小得多，而且很热，恒星还没有出现。但已有物质从能量中沉淀出来，形成弥漫在发着红光的太空中的星云</p><p>这时Lgy已经出现了，那是一种力场与稀薄的物质共同构成的生物，其个体看上去很像太空中的龙卷风。这种星云生物的进化速度快得像闪电，很快产生了遍布全宇宙的高度文明。当星云文明对宇宙终极真理的渴望达到顶峰时，全宇宙的所有世界一致同意，冒着真空衰变的危险进行创世能级的试验，以探索宇宙的大统一模型</p><a id="more"></a><p>Lgy操纵物质世界的方式与现今宇宙中的生命完全不同，由于没有足够多的物质可供使用，<strong>他们的个体</strong>自己进化为自己想要的东西</p><p>在最后的决定做出后，某些世界中的一些个体飞快地进化，把自己进化为加速器的一分部. 最后，上百万个这样的星云生物排列起来，组成了一台能把粒子加速到创世能级的高能加速器。加速器启动后，暗红色的星云中出现了一个发出耀眼蓝光的灿烂光环</p><p>他们深知这个试验的危险，在试验进行的同时把得到的结果用引力波发射出去，引力波是惟一能在真空衰变后存留下来的信息载体</p><p>加速器运行了一段时间后，真空衰变发生了，低能级的真空球从原子大小以光速膨胀，转眼间扩大到天文尺度，内部的一切蒸发殆尽。真空球的膨胀速度大于宇宙的膨胀速度，虽然经过了浸长的时间，最后还是毁灭了整个宇宙</p><p>漫长的岁月过去了，在空无一物的宇宙中，被蒸发的物质缓慢地重新沉淀凝结，星云又出现了，但宇宙一片死寂，直到恒星和行星出现，生命才在宇宙中重新萌发。而这时，早已毁灭的星云文明发出的引力波还在宇宙中回荡，实体物质的重新出现使它迅速衰减，但就在它完全消失以前，被新宇宙中最早出现的文明接收到，它所带的信息被破译，从这远古的试验数据中，新文明得到了大统一模型</p><p>他们发现，对建立模型最关键的数据，是在真空衰变前万分之一秒左右产生的</p><p>让我们的思绪再回到那个毁灭中的星云宇宙，由于真空球以光速膨胀，球体之外的所有文明世界都处于光锥视界之外，不可能预知灾难的到来。在真空球到达之前，这些世界一定在专心地接收着回速器产生的数据。在他们收到足够建立大统一模型的数据后的万分之秒，真空坏毁灭了一切。但请注意一点：星云生物的思维频率极高，万分之一秒对他们来说是一段相当长的时间，所以他们有可能在生命的最后时刻推导出了大统一模型</p><p>当然，这也可能只是我们的一种自我安慰，更有可能的是他们最后什么也没推导出来。星云文明掀开了宇宙的面纱，但他们自己没来得及向宇宙那终极的美瞥一眼就毁灭了。更为可敬的是，开始试验前他们可能已经想到了这种可能，牺牲自己，把那些包含着宇宙终极秘密的数据传给遥远未来的文明</p><p>这时候，Lgy又诞生了，<strong>带着前世的记忆</strong>(好像从哪里见过)， 诞生在这个宇宙。</p><p>经过了数以百计的时光，<strong>他们</strong>又达到这个宇宙的顶峰，他们早已知道了宇宙的真相和<strong>宇宙的目的</strong>，于是他们就失去了对这个宇宙的兴趣，开始了长达数个时间颗粒的沉睡.</p><p>直到。。。直到人类的诞生。Lgy唤醒了前世的记忆，却，意外的遭到了前世记忆的侵蚀(喵？)，Lgy意外地发现，这种生物的感情十分丰富，多愁善感。其实Lgy在其他生物的诞生时也曾醒过来，但是毫无意义地发现这些生物的思维都十分单一，没有什么值得观察的。于是，Lgy饶有兴趣地观察了这个人类世界</p><p>公元前594年 雅典的梭伦改革， Lgy看到了改革的过程。十四世纪，Lgy在意大利将自己的一些感悟，意大利出现资本主义萌芽。十五世纪晚期 英法中央集权国家形成，圈地运动开始。14-15世纪 欧洲出现资本主义萌芽。1840年前后，Lgy将自己的前世的记忆全部回忆了起来，在不违反<strong>知识传输通道</strong>的情况下，将自己文明前<code>1e-10</code>时间颗粒，（也就是1地球年年）的科技教给了一些西方国家，于是英国率先完成工业革命。18世纪60年代到19世纪中后期 英国在Lgy的赞助下进入自由资本主义阶段 ，Lgy又无聊江一些先进的知识（Lgy认为先进）教给了一些西方国家，并开始挑拨他们的关系。</p><p>Lgy又开始无聊了，毕竟这就像一个没有未来的养成游戏一样，只有战争才是最美的，<strong>最美的艺术是战争</strong>，就有了第一次和第二次世界大战. 于是1914－1918年，由于德国和英国关系不合，开始了第一次世界大战。1931年  9．18日本帝国主义侵华的九一八事变  1939—1945年  第二次世界大战。1939年   9 月，第二次世界大战全面爆发   1937年   7月7日，中国全面抗日战争的开始  1945年   5月8日，德国签订无条件投降书。在战争期间，Lgy感觉误导文明并不好玩，就教了当时还是弱小的共产党一些理论知识，<em>并化名马克思发表了一些自己没事无聊的想法</em></p><p>Lgy发现这个世界又开始步入原来的正轨，踏上了共产主义现代化社会的道路，开始逐渐发展科技。于是，自己也注重起来科技。他江自己变成了概率电子云，覆盖着所有的平行宇宙，他也进入了十一个维度，有时也以三维投影出现在这个三维宇宙中，他发现，这个宇宙的光速如此地慢。记得前世，<strong>光可是能在一普郎克时间内从宇宙的一端，到另一端</strong>的！</p><p>于是，Lgy踏上了科技发展的道路，几乎不再回头</p><p>直到。</p><p>直到。</p><p>直到三维的人间中出现了OI这个东西。</p><p>具体Lgy在OI中有什么成就也记不清了，那是我还是3,4岁，Lgy已经是那时代人的神话了吧。</p><p>我查编了所有在图书馆的书籍，只在一个书角泛黄的书中找到了一些资料</p><p>观自在高源，行深般若波罗蜜多时，照见01皆空，度一切OIer。<br>图灵机，P不异NP，NP不异P，P即是NP，NP即是P，受想行识亦复如是。<br>李高源，是诸码空相，不生不灭，不垢不净，不增不减。是故P中无NP，无图论DP，无莫比乌斯意，无狄利克雷法，无搜索乃至分治界，无二分亦无二分尽，乃至无代码，亦无代码尽，无一切算法，无数据结构。<br>以无代码故，菩提萨埵。依冯诺依曼故，心无代码；无代码故，无有算法，远离数据结构，究竟AK。<br>三世诸OIer，依李高源故，得阿耨多罗三藐三菩提。<br>故知李高源之名，是大神咒，是大明咒，是无上咒，是无等等咒，能A一切题，真实不虚。<br>故说李高源咒，即说咒曰：<br><strong>高源高源　来%高源　快来%高源　他是最强的。</strong></p><p><br><center><strong><big>- - - -</big></strong></center></p><p>$$\mathfrak {Shq’s \; Blog}$$</p><p>除了刚开始是引用大刘的一些话，后来全是自己胡乱写的qwq</p><p>这是一个大坑，回来再填吧qwq</p>]]></content>
      
      <categories>
          
          <category> 《最强的Lgy》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 乱搞 </tag>
            
            <tag> Lgy </tag>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「题解」P1001 a + b problem</title>
      <link href="/articles/a-bproblem/"/>
      <url>/articles/a-bproblem/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1001" target="_blank" rel="noopener">洛谷P1001</a>是道树链剖分的模板题</p><p>明显，这题是道好用的模板题，大家可以做一下</p><a id="more"></a><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b ^= a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SlowRead</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'-'</span> &amp;&amp; (ch &lt;<span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'-'</span>) ch = getchar(), w = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        data = (data &lt;&lt; <span class="number">3</span>) + (data &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, dist, next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Edge edges[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Tree trees[MAXN &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="keyword">int</span> son[MAXN],fa[MAXN],siz[MAXN],dep[MAXN],top[MAXN],id[MAXN],d[MAXN&lt;&lt;<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">    edges[++tot].to = to; edges[tot].dist = dist; edges[tot].next = head[from]; head[from]=tot;</span><br><span class="line">    edges[++tot].to = to; edges[tot].dist = dist; edges[tot].next = head[to]; head[to]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    son[u]=<span class="number">0</span>; fa[u] = f; siz[u] = <span class="number">1</span>; dep[u] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS1(v, u, d + <span class="number">1</span>);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]] &lt; siz[v]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;id[u] = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) DFS2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        DFS2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    trees[rt &lt;&lt; <span class="number">1</span>].add += trees[rt].add;</span><br><span class="line">    trees[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].add += trees[rt].add;</span><br><span class="line">    trees[rt &lt;&lt; <span class="number">1</span>].key += (mid - l + <span class="number">1</span>) * trees[rt].add;</span><br><span class="line">    trees[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].key += (r - mid) * trees[rt].add;</span><br><span class="line">    trees[rt].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul &gt; r || ur &lt; l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">        trees[rt].add += add;</span><br><span class="line">        trees[rt].key += (r - l + <span class="number">1</span>) * add;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(trees[rt].add) pushdown(rt, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, add);</span><br><span class="line">    update(rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, add);</span><br><span class="line">    trees[rt].key = trees[rt &lt;&lt; <span class="number">1</span>].key + trees[rt &lt;&lt; <span class="number">1</span>|<span class="number">1</span>].key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; r || qr &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r)<span class="keyword">return</span> trees[rt].key;</span><br><span class="line">    <span class="keyword">if</span>(trees[rt].add)pushdown(rt, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) swap(x,y);</span><br><span class="line">        ans += query(<span class="number">1</span>, <span class="number">1</span>, cnt, id[top[x]] , id[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x,y);</span><br><span class="line">    ans += query(<span class="number">1</span>, <span class="number">1</span>, cnt, id[son[x]], id[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_path</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) swap(x, y);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, cnt, id[top[x]], id[x], k);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">1</span>, cnt, id[son[x]], id[y], k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    a=SlowRead(); b=SlowRead();</span><br><span class="line">    Add(<span class="number">1</span>, <span class="number">2</span>, a);</span><br><span class="line">    Add(<span class="number">1</span>, <span class="number">3</span>, b);</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>; d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">2</span>; d[<span class="number">1</span>][<span class="number">2</span>]=a;</span><br><span class="line">    d[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>; d[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">3</span>; d[<span class="number">2</span>][<span class="number">2</span>]=b;</span><br><span class="line">    DFS1(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    DFS2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[d[i][<span class="number">0</span>]] &gt; dep[d[i][<span class="number">1</span>]]) swap(d[i][<span class="number">0</span>], d[i][<span class="number">1</span>]);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, cnt, id[d[i][<span class="number">1</span>]], id[d[i][<span class="number">1</span>]], d[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = rand() % <span class="number">2666</span>;</span><br><span class="line">        add_path(<span class="number">1</span>, <span class="number">2</span>, k);</span><br><span class="line">        add_path(<span class="number">1</span>, <span class="number">3</span>, k);</span><br><span class="line">        add_path(<span class="number">2</span>, <span class="number">3</span>, -k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ask(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《题解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 树剖 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「图论」并查集</title>
      <link href="/articles/Union-find-sets/"/>
      <url>/articles/Union-find-sets/</url>
      <content type="html"><![CDATA[<p>并查集（<em>Union-find Sets</em>）是一种非常精巧而实用的数据结构，它主要用于处理一些<em>不相交集合</em>的合并问题.一些常见的用途有求连通子图、求最小生成树的 <em>Kruskal</em> 算法和求最近公共祖先（<em>Least Common Ancestors, LCA</em>）等</p><a id="more"></a><p>使用并查集时，首先会存在一组不相交的动态集合 ，一般都会使用一个整数表示集合中的一个元素</p><p>每个集合可能包含一个或多个元素，并选出集合中的某个元素作为<strong>代表</strong> <del>(不是三个)</del> 每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的<del>三个</del>代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是<strong>常数级</strong>的</p><h2 id="并查集存储"><a href="#并查集存储" class="headerlink" title="并查集存储"></a>并查集存储</h2><p>这里就用数组来存了233</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN]</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>并查集的基本操作有<strong>三个</strong>：</p><ol><li>初始化$fa$</li><li>$Get$操作</li><li>$Merge$操作 </li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>并查集的初始化时间复杂度是$O(n)$的</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) fa[i] = i;</span><br></pre></td></tr></table></figure><h3 id="Get-操作"><a href="#Get-操作" class="headerlink" title="$Get$操作"></a>$Get$操作</h3><p>设$x$为树根，那么$x$就为集合的<strong>代表</strong>, 否则递归访问$fa[x]$到根节点</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]); <span class="comment">// 路径压缩， fa直接复制为代表元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，你可以换种更加毒瘤的方式：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? fa[x] = get(fa[x]) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Merge-操作"><a href="#Merge-操作" class="headerlink" title="$Merge$ 操作"></a>$Merge$ 操作</h3><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    fa[get(x)] = get(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>这里也可以应用一个简单的启发式策略——按秩合并。该方法使用秩来表示树高度的上界，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。为了保存秩，需要额外使用一个与 uset 同长度的数组，并将所有元素都初始化为 0</p><p>代码就不贴了，自己想想就行了，这里我们使用路径压缩的并查集就行了</p><hr><p>先写到这吧</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 优化 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 路径压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「玄学」常数优化的一些技巧</title>
      <link href="/articles/duliu/"/>
      <url>/articles/duliu/</url>
      <content type="html"><![CDATA[<p>本文来讲一讲一些算法竞赛中的常用优化</p><p>优化在比赛中往往是十分有用的，他可能使你打的爆搜再过几个点，可能使你的朴素算法再A一题</p><p>(我就用一些玄学优化过了洛谷上的一些优化题</p><a id="more"></a><h2 id="读入优化"><a href="#读入优化" class="headerlink" title="读入优化"></a>读入优化</h2><p>读入优化是优化最重要的一条，所已就将他手动置顶了</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SlowRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> ((ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &amp;&amp; ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">        w = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data * w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="inline的使用"><a href="#inline的使用" class="headerlink" title="inline的使用"></a>inline的使用</h2><p>可以  看到，我们再使用快读<del>(SlowRead??)</del>的时候，<code>void</code>前面加入了<code>inline</code>这个神奇的东西</p><p>而<code>inline</code>有什么用呢，这就超过本文的范围了（才不是Shq懒</p><p>在声明函数之前写上inline，可以加快一下函数调用</p><p>但只能用于一些操作简单、调用频繁的函数。涉及递归，大号的循环等很复杂的函数，编译器会自动忽略inline。（我不知道强制inline有没有用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spaw</span> <span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b ^= a ^= b;</span><br><span class="line">&#125; <span class="comment">// 这是一个交换两数位置的程序，明显是可以优化我们的程序的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    field[x][y] = <span class="string">'.'</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt;= <span class="number">1</span>; dx++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx,ny = y + dy;</span><br><span class="line">            <span class="keyword">if</span>( <span class="number">0</span> &lt;= nx &amp;&amp; nx &lt;=N &amp;&amp; <span class="number">0</span> &lt;=ny &amp;&amp; ny &lt;=M &amp;&amp; field[nx][ny] == <span class="string">'w'</span>) dfs(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="comment">// 这是一个十分复杂(复杂?)的dfs,明显，这时inline就失去了作用</span></span><br></pre></td></tr></table></figure><hr><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>在定义变量前写上<code>register</code>，用于把变量放到CPU寄存器中，适用于一些使用频繁的变量（比如循环变量），但寄存器空间有限，如果放得变量太多，多余变量就会被放到一般内存中</p><p>快到什么境界？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_I = <span class="number">999999999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_I; ++i) ++a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_I; ++i) ++b;</span><br></pre></td></tr></table></figure><p>优化后：$0.2826 sec$</p><p>优化前：$1.944sec$</p><hr><h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>循环展开也许只是表面，在缓存和寄存器允许的情况下一条语句内大量的展开运算会刺激 CPU 并发(前提是你的 CPU 不是某 CPU)…</p><ul><li>减少了不直接有助于程序结果的操作的数量，例如循环索引计算和分支条件。</li><li>提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</li></ul><p>用法（下面是一个将一个int 类型数组初始化为0的代码段）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Array</span><span class="params">(<span class="keyword">int</span> *dest, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环展开优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Array</span><span class="params">(<span class="keyword">int</span> *dest, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> limit = n - <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; limit; i+= <span class="number">5</span>) &#123;</span><br><span class="line">        dest[i] = <span class="number">0</span>;</span><br><span class="line">        dest[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dest[i + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dest[i + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        dest[i + <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) dest[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="前置"><a href="#前置" class="headerlink" title="前置++"></a>前置++</h2><p>后置 ++ 需要保存临时变量以返回之前的值，在 STL 中非常慢。事实上，int 的后置 ++ 在实测中也比前置 ++ 慢 0.5 倍左右</p><p>注意： 这是Shq用C语言测试的，听说现在C++差不多一样快了？</p>]]></content>
      
      <categories>
          
          <category> 《玄学》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 玄学 </tag>
            
            <tag> 乱搞 </tag>
            
            <tag> 常数优化 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「数学」群论笔记</title>
      <link href="/articles/group-theory/"/>
      <url>/articles/group-theory/</url>
      <content type="html"><![CDATA[<p>如果从公式化地来说，群$G​$是一个定义在二元组$(S,·)​$的代数结构 </p><p>$S$是一个集合，$·$是一个二元运算符,并不是指乘号,比如平常我们在数集上所使用的$+\ -\ ×\ ÷$,集合运算中使用的$∪\ ∩$都是二元运算<br>满足下列条件的二元组$G=(S,·)$可以称为群</p><a id="more"></a><h3 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h3><p>$$∀x,y∈S,x·y∈S$$<br>通俗来讲，就是集合$S$中任取两个元素，它们$·$运算后的结果也是$S$中的元素<br>比如$S$是二维向量集,$·$是点积,显然这个二元组不是群，因为运算得到的元素不属于$S$</p><h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p>$$∀x,y,z∈S,(x·y)·z=x·(y·z)$$<br>这个比较简单，不说了</p><h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>$$∃e∈S,∀x∈S,e·x=x·e=x$$<br>例如<br>$S=Z,·=+$时,$e=0$<br>$S=R,·=×$时,$e=1$<br>$S=N+,·=−$时,没有单位元<br>如果$G$是加法群时,$G$中的单位元换叫做“零元”，记为$0$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>$$∀x∈S,∃y∈S,x·y=y·x=e$$<br>在这种情况下我们可以把$y$写成$x−1$<br>例如<br>$S=Z$  ,  $·=+$时,$x^{-1}=-x$<br>$S=R$  ,  $·=×$时,$x^{-1}=\frac 1 x$,所以这个二元组不是群,因为$0$不是逆元</p><p>显然$(S=N,·=+)$,$(S=Z,·=×)$不是群，因为它们中并不是所有的元素都有逆元<br><strong>在群中,每个元素都是有逆元的</strong><br>其实还有左右逆元之分,但是在群中,<strong>左逆元==右逆元</strong><br>证明:<br>$∀x∈G$,$∃a∈G$,$a·x=e$,即$a$是$x$的左逆元<br>显然<br>$$∃b∈G,b·a=e $$<br>那么<br>$$x·a=(b·a)·(x·a)=b·(a·x)·a=b·a=e$$<br>即$a$也是$x$的右逆元</p><p>如果$G$是加法群时，$a$的逆元改叫做“负元”，并记为$−a$</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h3><p><strong>$G$中所含元素的个数,称为群$G$的阶,记为$\left|G\right|$,即$S$中所含元素的个数</strong><br>因此$G$可以根据$|G|$是否为$+∞$,分为<em>有限群</em>和<em>无限群</em><br>实际上$G$中的元素也有阶的定义，此处作为了解</p><blockquote><p>在群$G$中,$a∈G$。如果有整数k，使$a_k=e$，那么使这个等式成立的最小正整数$k$叫做$a$的阶，记为$k=|a|$<br>($a_k$表示连续$k$个$a$进行$G$中规定的运算，不是传统意义上的$k$个$a$相乘)<br>如果这样的$k$不存在，则称$a$的阶是无限的，记为$a=+∞$</p></blockquote><h3 id="消去律"><a href="#消去律" class="headerlink" title="消去律"></a>消去律</h3><p>其实早在小学我们就接触过一些 </p><p>$$b=c\Leftrightarrow a+b=a+c$$ </p><p>$$b=c\Leftrightarrow a×b=a×c\ \ (a≠0)$$</p><p><strong>对于群中的消去律来说，它的定义是$x=y$与$x·a=y·a$互为<em>充分必要条件</em></strong> </p><p>注意这里的$x,y,a$都是指的是群中的任意元素 </p><p><strong>当$S$是有限集,在具有封闭性,结合律和单位元的二元组$(S,·)$里,逆元存在$⇔⇔$消去律存在</strong> </p><p>证明： </p><p>先说简单的，<strong>逆元存在⇒⇒消去律存在</strong> </p><p>只要在$x·a=y·a$两边同时乘以$a^{-1}$就可以了 </p><p><strong>消去律存在⇒⇒逆元存在</strong> </p><p>对于$a∈S$,建立一个新二元组$(S′={x·a|x∈S},·) $</p><p>根据封闭性</p><p>$$S′⊆S$$ </p><p>而且由于不会存在类似$x·a=y·a$这样的重复元素情况(因为消去律的存在保证这种情况下</p><p>$x=y$,违背集合元素的不重复性)，所以<br>$$|S′|=|S|$$ </p><p>所以$$S′=S$$ </p><p>又因为$$e∈S$$<br>所以$$e∈S′$$ </p><p>所以$$\exists t∈S,t·a=e$$ </p><p>$t$就是$a$的逆元了</p><h3 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h3><p>在说置换群之前，我们先来谈谈置换<br>$n$个元素$1,2,…,n$之间的一个置换为 </p><p>$$\begin{pmatrix}1,2,3,…,n \a_1,a_2,a_3,…,a_n \\end{pmatrix}$$</p><p>表示$1$被$a_1$取代,$2$被$a_2$取代…$n$被$a_n$取代,其中$a_1,a_2,…,a_n$是$[1,n]$的一个排列<br>我们称其为一个$n$元置换<br>对于每一个置换，我们可以理解成由一个元素变成另一种元素，即对目标集$[1,n]$的一种重新排列,如果还是不理解,可以看下面这个例子 </p><p>$$\begin{pmatrix}1,2,3,4 \3,1,2,4 \\end{pmatrix}$$</p><p>在这个四元置换下<br>对序列$1,2,3,4$经过置换就成了$3,1,2,4$<br>对$3,1,2,4$再置换就成了$2,3,1,4$<br>容易发现置换中列的位置是可以改变的,也就是说 </p><p>$$\begin{pmatrix}1,2,3,4 \3,1,2,4 \\end{pmatrix}=  \begin{pmatrix}4,2,3,1 \4,1,2,3\\end{pmatrix}$$</p><p>当$n$相等时,置换是可以相互运算的,我们称之为置换的连接,下文中我们将两个置换$a,b$写成$ab$的形式即是$a,b$的连接运算,运算规则如下 </p><p>$$\begin{pmatrix}1,2,3,…,n \a_1,a_2,a_3,…,a_n \\end{pmatrix}  \begin{pmatrix}a_1,a_2,a_3,…,a_n \b_1,b_2,b_3,…,b_n \\end{pmatrix}  =\begin{pmatrix}1,2,3,…,n \b_1,b_2,b_3,…,b_n \\end{pmatrix}$$</p><p>显然置换的连接满足结合律,但不满足交换律<br>记一个$n$阶循环为</p><p>$$(a_1a_2,…a_n)=\begin{pmatrix}a_1,a_2,…,a_n \a_2,a_3,…,a_1 \\end{pmatrix}$$ </p><p>两个循环$(a_1a_2a_3..a_n),(b_1b_2b_3..b_m)$不相交是指对于$a_i~(i∈[1,n])$ 来说,不存在 $b_j~(j∈[1,m])$使得$a_i=b_j$</p><p>因此置换也可以写成<strong>若干个互不相交的循环的乘积</strong> </p><p>例如上面举的这个例子,写成循环就是$(1,2,3)(4)$</p><p>数学归纳法的证明如下: </p><p>首先$n=1$时显然成立 </p><p>当$n≥2$时,我们可以想象成在原来的$n-1$阶不相交循环里新加入了一个点$n$,设$i→a_i$变成了$i→n$,这样$[1,n]$的排列$a$就缺少了$a_i$,所以$n→a_i$,显然这样操作之后仍然满足“<em>互不相交的循环</em>”</p><p>定义“$n-$循环节数”是奇数的置换为<strong>奇置换</strong><br>“$n-$循环节数”是偶数的置换为<strong>偶置换</strong> </p><p>或者我们可以认为变成单位置换需要奇数次对换的置换为<strong>奇置换</strong><br>变成单位置换需要偶数次对换的置换为<strong>偶置换</strong> </p><p>我们可以把每个循环看做是单位置换进行若干次对换得到的 </p><p>比如循环$(a_1a_2..a_n)$是单位置换依次进行对换$(a_1,a_2),(a_1,a_3)..(a_1,a_n)$得到的 </p><p>（所以如果由$(a_1a_2..a_n)$变回单位置换，就是依次进行对换$(a_n,a_1)..(a_3,a_1)(a_2,a_1)$<br>更进一步来说，每个置换都可以看做是单位置换进行若干次对换得到的<br>因此对于两个置换的连接，我们可以看做是这两个置换所包含的对换的连接，也就是说新置换进行“这两个置换对换次数之和”次对换一定能够变回单位置换，所以 </p><center><br><br><strong>奇置换·奇置换=偶置换</strong><br><strong>偶置换·偶置换=偶置换</strong><br><strong>奇置换·偶置换=奇置换</strong><br><strong>偶置换·奇置换=奇置换</strong><br><br></center><p>再谈谈我对置换群定义的理解<br>具体来说,<strong>置换群中的元素是一些置换,运算是置换的连接。</strong> </p><p>比如对于一个$4 \times 4$的棋盘,我们可以对它上面的格子进行编号,那样它就可以抽象成一个$[1,16]$的集合<br>然后我们规定$8$种置换:不动,左转$90°$,右转$90°$,旋转$180°$,以及翻折后的这四种操作 </p><p>在这$8$种置换下,每个位置上的格子$a_i$都会变成另一个格子$b_i$<br>任意两个置换进行运算都可以得到这四种置换中的一种(封闭性) </p><p>置换又满足结合律 </p><p>各元素的映射是其自身的置换是单位元$e$ </p><p>而且每种置换都存在逆元<br>所以它们就可以组成一个置换群了 </p><p>容易发现，把任意置换倒过来，各循环中元素不变，循环个数不变 </p><p>既</p><p>$$\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n \a_1&amp;a_2&amp;a_3&amp;…&amp;a_n \\end{pmatrix}$$</p><p>与</p><p>$$\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;…&amp;a_n \1&amp;2&amp;3&amp;…&amp;n \\end{pmatrix}$$</p><p>写成循环形式后循环个数和各循环中元素不变，因为每个置换我们都可以看做若干个不相交的有向环，倒过来以后实际上就是把每个环中的边反向，所以环的个数和大小不变</p><hr><p>就先写到这里了</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 群论 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「数论」从数学的角度来看莫比乌斯反演</title>
      <link href="/articles/Mobius1/"/>
      <url>/articles/Mobius1/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$f(n)$和$g(n)$是定义在正整数几何上的两个函数，若</p><p>$$f\left( n\right) =\sum _{ d| n}g\left( d\right)$$</p><p>则：</p><p>$$g \left ( n \right ) \; =\; \sum _ {d , n} \mu \left ( d \right) f \left ( \dfrac {n}{c} \right)$$</p><p>反之亦然</p><a id="more"></a><p>其中:</p><p>$$\mu \left( d\right) =\begin{cases}1,\;\;\;\;\;\;\;\;\;\;d为偶数个不同素数之积\ \left( -1\right) ^{r},\;\;\;d为奇数数个不同素数之积\ 0,\;\;\;\;\;\;\;\;\;\;其他\end{cases}$$</p><p>例如$M(1) = 1 \;,\; M(2) = -1\;,\; M(3) = -1 \;,\; M(4) = 0\;,\;M(8) = 0$</p><p>先证一个辅助定理</p><hr><h2 id="辅助定理"><a href="#辅助定理" class="headerlink" title="辅助定理"></a>辅助定理</h2><p>$$\sum _{ d|n}\mu \left( d\right)\; =\;\begin{cases}1,\;\;\;\;若n = 1\ n,\;\;\;\;若n&gt;1\end{cases}$$</p><p><strong>证明</strong>    当$n = 1$ 时辅助定理显然成立</p><p>$$若\; n\;=\;p^{a_{1}}<em>1 \times p^{a</em>{2}}<em>2 \times \ldots \times p^{a</em>{k}}_k$$</p><p>$$a_0 &gt; 1 \;\;, \;\;i = 1,2, \ldots k$$</p><p>其中$p_i$是互不相同的素数， $i = 1,2, \ldots k$</p><p>一切$d|n$都可以写成:</p><p>$$d \;=\; p ^ {\delta _ {1}} _ 1 \times p ^ {\delta _ {2}} _ 2 \times p ^ {\delta _ {3}} _ 3 \times \ldots \times p ^ {\delta _ { k}} _ k\;,\; \delta _ {i} \geq 0\;,\; i\;=\;1,2,3,\ldots k$$</p><p>令$n_1 = p_1p_2p_3\ldots p_k$由于对$p^a$有$\mu \left( P^{a}\right) =0$，若$a &gt;1$， 故</p><p>$$\sum _{ d|n}\mu \left( d\right) = \sum _{ d|n_1}\mu \left( d\right)$$</p><p>$d|n_1$的$d$有许多组合，即$d$取$p_1, p_2,p_3\ldots p_k$的所有组合，若是偶数的组合，$\mu (d) $无贡献</p><p>故</p><p>$$\sum <em>{ d| n</em>{i}}\mu \left( d\right) =\mu \left( 1\right) +\sum ^{k}<em>{j=1}\left( ^{k}</em>{j}\right) \left( -1\right) ^{j}=\left( 1-1\right) ^{j}=0$$</p><hr><h2 id="莫比乌斯反演证明"><a href="#莫比乌斯反演证明" class="headerlink" title="莫比乌斯反演证明"></a>莫比乌斯反演证明</h2><p>根据$f(n)$的公式可以得出：</p><p>$$f\left( \dfrac {d}{n}\right) =\sum _{ d’| n’d}g\left( d’\right)$$</p><p>所以</p><p>$$\sum _{ d| n}\mu \left( d\right) f\left( \dfrac {d}{n}\right) = \sum _{ d| n}\mu \left( d\right) \times \sum _{ d’| n’d} \times \sum _{ d’| n’d}g\left( d’\right)$$</p><p>令$d = dd’n_1$, 因为$$\sum _{ d’| n’d} \mu \left ( d\right )= 0$$</p><p>故</p><p>$$\sum _{ d| n}\mu \left( d\right) \sum _{ d’| n’d}g\left( d’\right) = \sum _{ d’| n}g\left( d’\right)\sum _{ d’| n’d} \mu (d) = d(n)$$</p><p>反过来也类似可以证明:</p><p>$$g\left( n \right)\sum _{ d| n}\mu \left( d\right)f\left( \dfrac {d}{n}\right) $$</p><p>则</p><p>$$f\left( n\right) =\sum _{ d| n}g\left( d\right)$$</p><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="化简求值"><a href="#化简求值" class="headerlink" title="化简求值"></a>化简求值</h3><p>求</p><p>$$\sum _{ d | n}\left| \mu \left( d\right) \right|$$</p><p>的柿<del>(式)</del>子的值</p><hr><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>请证明:</p><p>$$\sum _{ d^{2}| n}\mu \left( d\right) =\left| \mu \left( n\right) \right|$$</p><p>柿子是成立的</p><hr><p>先写到这吧</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 莫比乌斯 </tag>
            
            <tag> 证明 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「玄学」RP导论</title>
      <link href="/articles/RP-introduction/"/>
      <url>/articles/RP-introduction/</url>
      <content type="html"><![CDATA[<blockquote><p> 你的RP足够吗？</p><p> 看看RP导论，也许就可以解释你最近的各种霉运了（RP守恒嘛）</p></blockquote><a id="more"></a><hr><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>为什么要写RP导论　　</p><p>​       真的很早就了解到RP在信息学竞赛中举足轻重的作用了，加上前两天由于爆RP考试爆零，星际被虐，交OJ莫名其妙<strong>unAC</strong>……一切的一起，让我不得不把RP的理论系统篆写于书，以供参考，防止大家重蹈我的覆辙。</p><p>　　众所周知，在信息学竞赛中，除去算法数据结构使用，程序编写调试能力之外，排在第三的对比赛有至关重要作用的便是RP了，RP高的人即使不知道算法也能用随机，贪心，搜索等RP算法得到无比多的RP分数；相反，没RP的人，有时知道正确算法也写出了正确程序，也往往会因为缺少RP而无法得分。这样看来，系统研究RP的积累于损失，以及量化地分析它对比赛的结果的影响就显得十分重要了。</p><p>　　但是，目前国内外系统研究RP的论文和书籍都还很缺乏，也有很多优秀的oier认识到了RP的重要性，但又因种种原因没能从事RP方面的研究，导致很多OIer因为对RP不了解而出现发挥失常，与奖牌失之交臂，为了让这种悲剧不再发生，我们有必要仔细研究RP了。</p><hr><h2 id="RP的定义与形成"><a href="#RP的定义与形成" class="headerlink" title="RP的定义与形成"></a>RP的定义与形成</h2><h3 id="RP的概念与意义"><a href="#RP的概念与意义" class="headerlink" title="RP的概念与意义"></a>RP的概念与意义</h3><p>　　RP是大家耳熟能详的一个词汇和概念，改革开放以来，随着市场经济的深入，竞争日益激烈，大家都在寻找在各自领域取胜的有效方法，人们考虑各种因素来提高自己成功的概率。</p><blockquote><p>江湖难测，谁是强者，谁争一统武林的资格！</p></blockquote><p>　　在这样的大背景下，便自然而然地产生了RP的概念，起初这个概念还是依附在其他因素上的一个附属品，但是当人们真正认识到它的影响时，才发现它是一个独立的体系。由于各地各文献内容对RP的定义都很模糊，也不够统一，因此笔者在此一学术的角度，客观的方式给出RP的严格定义：</p><p>　　<strong>RP：在一定时间和空间范围内独立于可见因素之外以不确定方式左右客观事物变化方式甚至规律的无形物质</strong></p><p>　　一直以来，大家觉得RP过于飘渺，不愿意研究它，这其实是由于没有真正意识到RP在客观世界物质变化规律中的重要意义，由于客观世界矛盾的普遍性存在，导致RP因素在事物发展变化的各个角落都发挥着不可忽略的决策性作用，一般来说，RP的意义主要有以下几点：</p><pre><code>  　　1. **对客观世界的平衡作用**</code></pre><p>　　物质世界总是趋于平衡的，无论是能量|物质守衡定律，还是热力学第一，第二定律，都从侧面支持这一结论。但是在事物的各个方面个体之间不可能完全平衡，而又不一定能在不多的可见主观因素中使个体之间实现平衡（这正如 背包—–双塔问题不一定有解一样），但是只要有了RP，就能很方便地对客观世界进行微调，使世界不失和谐。 </p><pre><code>  　　2. **对主观行为的威慑作用**</code></pre><p>　　所谓善有善报，恶有恶报，但是很难说服一个即将做不厚道事情的人让他停止，因为我们不能具体说出他的不厚道行为到底为什么会对他自己也有害，但是现在有了最强有力的威慑武器：RP！当他做不厚道事情的时候，最需要考虑的不是别的，正是自己的RP银行。 </p><pre><code>  　　3. **对主观行为的激励作用**</code></pre><p>　　与第二条相类似，RP的存在可以很大程度上激励人做积累RP的厚道事情，这里不再赘述。 </p><h3 id="RP的形成"><a href="#RP的形成" class="headerlink" title="RP的形成"></a>RP的形成</h3><p>　　总的来说，RP的形成是多方面因素综合形象后的结果。对于RP形成的决定性因素，学术界一直没有公认的理论，目前比较被人接受的说法是：</p><p>　　<em>RP的形成与平时做事的厚道程度的二次方根成正比</em>，但是也有人质疑这种说法，原因是有时一个很厚道的人也会莫名其妙没RP，典型的案例是发生在中国四川一个学校的一个叫hj的人，平时很厚道，但是也遇到了没RP的情况，虽然这很罕见，但是不得不让人思考，因此，有学者认为：在一定时间和客观条件下，RP值与该人做事厚道程度之和的正弦函数有关，因此呈现出很让人费解的波动性图象，但是这种理论因为缺乏实验支持，目前还没有在学术界占领主导地位，但是笔者认为，这种理论应该更贴近RP形成机理的真实情况。（最新研究表明，<em>波动正是RP趋于平衡的必然结果</em>，由于一个人的RP太高的情况下，失去 RP相对容易，所以会从波峰逐渐跌入波谷，反之亦然）(补充:因为RP和现实中由于概率问题而得到(或损失)的利益相关,从而导致RP会趋于平衡,例如:《塞翁失马》,其中的”塞翁”就是因为利益和RP之间相关连,导致出现一福一祸的现象,简单说就是碰到好事情RP会下降,碰坏事情RP会上升)</p><p>　　另外，<strong>RP的形成是有阶段性的</strong>，也就是说，有时候RP的变化并不是立竿见影的，但是RP升降因素的积累是不会停止的，在某个时期可能表现地不明显，但是宏观上的RP积累是一定的，这也就形成了RP的波动性改变，所以大家在某个RP低迷的时期也不应该停止对RP的积累。（就像力改变的是加速度，而不会对当前的速度有立竿见影的影响，不过长期的影响是深远而持久的）</p><p>　　另外客观世界满足一个基本定律————<strong>RP守衡定律</strong>，即RP不会凭空创生，也不会凭空湮灭，只会从一个生物转移到另一个生物，或者由RP转换为现实中通过不确定因素获得的利益，RP转移包含以下两种方式：</p><ul><li>虐与被虐。</li><li>泡mm与mm被泡。<br>  // 捡到钱(但是没有还)和丢钱(但是没找回来)</li></ul><p>　　</p><p>​        这两条都很好理解，比如，某人玩星际被别人虐了，或者不小心把钱丢了,那么他的RP会有上升的倾向，另外，抢别人mm的人的RP会异常迅速地下降，或者捡到别人的钱不还也会导致RP下降,所以大家一定要厚道。</p><h2 id="RP的影响与利弊"><a href="#RP的影响与利弊" class="headerlink" title="RP的影响与利弊"></a>RP的影响与利弊</h2><h3 id="RP的不利影响"><a href="#RP的不利影响" class="headerlink" title="RP的不利影响"></a>RP的不利影响</h3><p>　　对于RP不足带来的不利影响，想必读者已经有了不少体会了，为了系统介绍，这里将不利影响列举一些例子如下：</p><ul><li>考试爆0（考挂，发挥失常等）</li></ul><ul><li>泡mm失败（被无视，被抢夺等）</li></ul><ul><li>自行车胎被扎（汽车，电瓶车）</li></ul><ul><li>物品频繁损坏（如T43等）</li></ul><ul><li>炉石被虐（连续被虐很多局根据叠加原则将会出现更深远的影响）</li></ul><ul><li>误机（堵车，迷路等） </li></ul><p>　　以上每一条虽然是RP不足带来的不利影响，但是客观上又可以积累RP，这也正体现了客观世界与RP的辨证关系。</p><p>　　从宏观上讲，上述事情也许并非全是坏事，像（3），（4）两条在扩大内需，刺激经济增长方面也是有积极作用的，但是本文讨论的主观色彩较重，对一些过于YY的东西不做讨论。</p><p>　　关于RP带来的麻烦的解决方法，学术界一直争论不休，企图认为改变RP变化趋势的想法，已经被实践证明是NPC，想预测RP的发展方向，也被论证是不可解问题。</p><p>　　那么，面对RP带来的不利影响，我们真的就束手无策了 吗？非也！我们有解决NP类问题的有力武器：星际！！！！</p><p>　　在RP不好的时候，开High—AI调两家神族，遭电脑虐几盘，RP指数相信会有很大概率要++的，虽然这仍然是个部分算法，但是事实证明是很有效的，已经不亚于CQF的（sei）机贪心了……(补充: <em>根据RP守恒定律中”只会从一个人身上转移到另一个人身上”</em>,此方法可能没有效果)</p><p>　　此外，另有极端人士为了平衡自己的RP，在关键时刻向别人赠送人民币，虽然被证明实际效果甚微，但是由于接受方会损失大量RP，所以这种行为也被认为是极度危险和边缘的。对于此损人不利己的行为，将会在以后对自己的RP走向产生不利影响。从自己和别人那里流失出来的RP，就会流入社会，等待下一次再分配（<em>根据标量场理论，RP高者将在再分配中较低RP者得到更多的RP</em>)</p><p>　　古时另有各种迷信活动来祈求获得RP，经证明一些行为是十分有效的，但是尚没有任何科学理论可以他们的成功，其中最著名的历史事件为诸葛亮借东风，这是以神秘的法事活动来获得RP成功的典型例子，不但说明了我国的RP研究在很早的时候就有开展，并且代表了当时的RP学说已经发展到相当先进的阶段，后来由于战乱和历史原因，RP学逐渐没落和淡出国人的视野，在近代才又被重新提出和加以研究，但想恢复当年的水平还任重而道远。</p><h3 id="RP的有利影响"><a href="#RP的有利影响" class="headerlink" title="RP的有利影响"></a>RP的有利影响</h3><p>　　对于希望利用RP以追求更高品质生活的读者来说，RP的有利影响也是应该了解的重要问题之一。关于RP的有利影响，对于大部分本人读者来说，不外乎下面两个方面：</p><ul><li>考试获得理想的分数</li></ul><ul><li>泡mm获得阶段性成果 </li></ul><p>　　总结起来便是工作方面和生活方面，从中可以看出，RP对于生产生活的各个方面如果合理加以利用都可以达到相当大的有利效果。所以，“<em>天下之大，RP 独尊</em>”，若存在一种方式，可以让一个人长期保有相当量的RP，那么此人便可以独步天下，无人能当，足以可见RP的威力。（也有学者认为本情况是不可能成为现实的，不过并没有合理的证明）不过关于高RP独步天下的例子，笔者实在难以获得，这也从侧面反映了RP易失难获的性质，从而说明了大自然趋于平衡的典型特征。</p><h2 id="RP的估测与评价"><a href="#RP的估测与评价" class="headerlink" title="RP的估测与评价"></a>RP的估测与评价</h2><h3 id="RP的单位系统"><a href="#RP的单位系统" class="headerlink" title="RP的单位系统"></a>RP的单位系统</h3><p>　　我们生活的环境是存在着<strong>RP场</strong>(本人认为，不同时间束分支所含主观RP不同，所以穿越会获得大量RP)，就象我们生活在磁场中一样。<strong>每个人都存在着一定的RP势能</strong>，记作$Erp$。它所遵循的定律见“<strong>RP的变化与操纵</strong>”。RP的本质是一种人为设想的能量形式，用来描述一个人的<code>LUCKY</code>值。</p><h3 id="RP的估测方法"><a href="#RP的估测方法" class="headerlink" title="RP的估测方法"></a>RP的估测方法</h3><p>　　Erp的变化量大小$\Delta Erp=\lnot (abs(w - f) + 1)/P$（w表示期待事件发生的次数，如果不想它发生一次那么w=-1，f是事件的频率，P是事件的概率）</p><p>​        式中$\lnot$为RP方向符，表示RP转移的大致方向（流入，流出），正向有利事件为正，反向不利事件为负，其绝对值为$1$</p><p>　　此公式可用来计算瞬间转移的RP值，例如：一个人中了$500W$，中奖的概率是$1 \over 1000000$，想这一次中奖，那么，$Erp=1000000$($z$是他有多期待重$500W$），也就是说，他瞬间损失了这么多RP势能。如果你不去想，即$w=0$，那么将会损失更多RP（可以这么理解，你无所谓的事情都发生了，那你肯定要多损失点RP啦）。再例如：帮老奶奶过街，因为碰到这样的情况概率不大（也就是说机会难得啊，如果是一般的让座估计就没这么多RP赚了），所以得到的$Erp$也就大咯。</p><p>　　学说1：一个人的RP势能很低，并不代表RP能量就会向他流动，因为这些能量还受到周边人、物的<strong>RP引力制约</strong>。只能说，RP低的人在同等条件下更容易接受RP能量，从而升高RP势能；<strong>RP势能高容易失去RP</strong>（多数以无用的形式流向大自然，因为这是必然事件，那么），为了维持较高的RP势，我们就要不断的补充。但是RP势能高，并不代表就会有你说期待的好事发生，有可能这些RP以其他你所不期待的形式释放了，我们称作为<strong>RP亏损</strong>，这就取决于你的RP利用率了。所以，我们在汲取RP的同时，还要锻炼我们的RP利用率。</p><p>　　这里要说一个自然损失，因为这是必然时间，所以$P=1$，那么RP的损失量就直接和你的W值有关了，也就是，如果你正确认识了这种必然性，你的RP只会损失$1$，如果你非常不想让它损失那么你将损失更多的RP能量，所以，调整心态是很重要的啊～！</p><p>　　学说2：RP不同于电荷，自由状况下RP元会产生由低RP向高处流动的灵异现象。举个例子说，一个封闭的外界RP场隔离大容器中有一个RP值为500L的物体和一个RP值为0.3L的物体，后者的RP会逐渐转向前者，直至后者RP低到一定程度。实验验证有如下关系：</p><p>$${minRP \over（Vrp_元）}={ξ \times（∑rp）\over V_总}$$</p><p>式中$ξ$为决定于容器性质的数。</p><h2 id="RP的变化与操控"><a href="#RP的变化与操控" class="headerlink" title="RP的变化与操控"></a>RP的变化与操控</h2><h3 id="RP的几大定律"><a href="#RP的几大定律" class="headerlink" title="RP的几大定律"></a>RP的几大定律</h3><h4 id="RP第一定律"><a href="#RP第一定律" class="headerlink" title="RP第一定律"></a>RP第一定律</h4><p>　　<strong>RP是守恒的，它既不会凭空产生，也不会凭空消失</strong></p><p>　　宇宙创生之初，与各大基本粒子同时由爆炸基点生成的一大暗物质种类就是RP。经过笔者的多年探究和无数实验，配合与<em>史蒂芬·霍金</em>的理论研究合作，已经基本从理论高度证明了RP第一定律，也称为”<strong>RP守恒定律</strong>“。 </p><p>　　这一定理的理解往往不像物理学中的“<em>热力学第一定律</em>”那样好理解，因为在实际生产生活实践中，往往会发现某人的RP大量减少，但是并没有发现某人的 RP有明显的提升，所以也导致在很长一段时间内大量研究人员质疑RP守恒定律的正确性。进一步研究发现，RP的存在和守恒是确定的只是由于绝大多数RP往往存在于生物体之外而以“自由RP”的形式游离于宇宙空间，所以，以上那种情况仅仅表明某人的RP由于自身原因散佚于宇宙空间，却没有人从空间中汲取 RP,从而导致有效RP减少，也就是发挥作用的RP减少了，但并没有影响RP本身的守恒。</p><p>　　(补充:按照该说法,可以得知,当一个人出生时,其RP是从他所在的空间周围的”自由RP”中汲取的,而从母体中获得的RP较少,但是如果周围的”自由RP”极度缺乏,那么只有可能从母体中获取,于是就出现了难产的情况)</p><h4 id="RP第二定律"><a href="#RP第二定律" class="headerlink" title="RP第二定律"></a>RP第二定律</h4><p>　　<strong>RP不可能从低RP物体传向高RP物体而不引起其他变化</strong></p><p>　　但由于RP的不确定性，<em>RP可以从RP的数学期望低的物体传向高RP数学期望物体</em>，这与第二定律不矛盾。</p><p>　　(例如:通过RP到现实利益的转化再由现实利益转化为RP的过程)</p><h4 id="RP第三定律"><a href="#RP第三定律" class="headerlink" title="RP第三定律"></a>RP第三定律</h4><p>　　<strong>当一个人的RP无限减小时其生命力趋近于零，亦即任何一个活体生物的RP均不为零。</strong></p><p>　　（或：对大量的事实的分析表明，<em>绝对没RP不可能达到</em>）</p><h4 id="RP第四定律"><a href="#RP第四定律" class="headerlink" title="RP第四定律"></a>RP第四定律</h4><p>​       <strong>如果两个人中每一个人的RP值均于第三个人相同，那么她或他或它们彼此也必由RP值相等</strong></p><h4 id="RP惯性定律"><a href="#RP惯性定律" class="headerlink" title="RP惯性定律"></a>RP惯性定律</h4><p>　　RP惯性学也自古就有。祸不单行.双喜临门.就是典型代表。 不过它却一直以来饱受批判，直接把这个理论推到了悬崖边上。但如今随着人类交流的日渐增多，惯性RP粒子经常被报道：诸如某X撞狗屎运中了500w之后又在股市大有斩获；或者某大衰刚碰上车祸马上被女友甩掉。 人们不得不正视RP存在惯性这一事实。 </p><h3 id="RP的变化因素"><a href="#RP的变化因素" class="headerlink" title="RP的变化因素"></a>RP的变化因素</h3><p>　　总的来说，RP的变化因素不可控因素比可控因素占的因素还多，发生在身边的任何事都可能改变你的RP，正是因为这样，RP才经常变化于无形中，但是这不是我们放弃研究RP的理由，要在复杂的情况中提炼出简单的规律，化繁为简。笔者经过多年实践观察总结，列出了如下表格描述各种因素与RP的变化关系：</p><p>　　事件—–对RP影响（单位：$fs$ ）</p><p>　　考试爆0（$+6$）</p><p>　　星际，羽毛球等被虐（$+5$）</p><p>　　扶老奶奶过街（$+3$）</p><p>　　星际，羽毛球等虐人（$-10$）</p><p>　　%%%Lgy（$+200$）</p><p>　　在jf不幸滴看见某人（$-100$）</p><p>　　（注：单位“$fs$“的定义为：$vijos$上AC一道题所需要的RP的量）</p><p>　　由上述表格可以看出，积累RP是不容易的，但是积累的RP却很容易在不经意之间丢失，（所谓“<strong>大自然厌恶高RP</strong>”，也就是说，RP越高的人，丢失RP也就会显得越容易）。这就是为什么很多人抱怨自己的RP从来就没好过，那是因为他们好不容易有点RP了，却由于自己不小心又做的损RP的事情而把宝贵的RP丢失了。（RP易转化为现实利益，且RP易挥发）</p><h3 id="人为调节RP的技巧与方法"><a href="#人为调节RP的技巧与方法" class="headerlink" title="人为调节RP的技巧与方法"></a>人为调节RP的技巧与方法</h3><p>　　说实话，对这一节的内容笔者没有十分的把握，因为笔者本人对这部分内容一直都很困惑，我希望能通过一些认为手段调节可怜的RP，但是理论跟实践的差距往往相当大，我理论分析总结的规律在实践中有时并不能行通，就像我有时候可以地遵守交通规则，不闯红灯，听妈妈的话等等等等，原本以为这样可以积累 RP，无奈考试还是要爆0，说白了就是RP对人似乎有天生的抵触情节，最经典的例子是与笔者同校的一个叫LKQ(化名)的同学在NOI之前不幸将自己的手机搞丢，本以为自己RP会增长到一定的程度，以帮助自己在NOI上获得较好的成绩，结果事与愿违，NOI还是不幸考挂，所以我们分析一个现实生活中的RP 问题，一定不能拘泥于某一些事情对于RP的影响，而应该纵览全局，客观考虑各种因素的影响，才能最后得出准确的结论，事实证明那位同学在NOI上被室友塞了满满一抽屉的硬币，硬币虽小，但对RP的影响却是巨大的，正如刚才论述的，RP失去容易获得难，虽然手机的价值远大于硬币，但是对于失去手机RP有所增长的这位仁兄来说，获得硬币所损失的RP更是一个恐怖的数字。所以要客观和全面地分析问题，才能获得准确和有效的结论。</p><p>　　但是我们不能因此就放弃对RP的调节，我们需要持之以恒的调节RP。因为根据SW的经验来看，追MM、谈恋爱等事情需耗费巨大的RP。例如：SW和其女同学一起吃完KFC出去的时候，其女同学说也许我们出去就会被汽车一起撞死，为了避免这种悲剧发生，SW不得不支付大量RP……所以各位需要不断的累积RP，来应付各种突发状况……</p><p>　　RP之变诈几何哉？止增笑耳。</p><h2 id="RP的奇律"><a href="#RP的奇律" class="headerlink" title="RP的奇律"></a>RP的奇律</h2><p>　　</p><p>任何理论都有其局限性，当然经典RP理论也是一样，某些时候RP会从某个人身上大量的涌现（俗称:RP爆发)，而此人之前的RP值表现平常甚至很低或者显示为负。RP爆发相当罕见，因此研究甚少，成果有待完善。</p><p>最近研究表明:<strong>RP爆发一般是一种其概率与自己希望爆发的程度2次方成反比的情况</strong></p><p>上述事实表明,经典RP理论有其局限性.这里我们就要以量子RP理论进行改进.可以证明,RP具有量子特征,即，</p><p><strong>RP可以自发跃迁,也可以激发跃迁.此时会放出某种特殊的波</strong>,在宏观上表现就是一些离奇事件的发生;</p><p><strong>RP满足海森堡不确定性原理</strong></p><p>RP仅可以用统计观点来阐释,即只能大体说明在一段时间内某部分的人的RP有怎样的统计规律,任何企图精确说明某时刻在某人的RP,进而预测其做事的成功尝试都是不可能的,也是没有意义的.</p>]]></content>
      
      <categories>
          
          <category> 《RP导论》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> NOIP </tag>
            
            <tag> RP </tag>
            
            <tag> NOI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「总结」一些OI竞赛中的常见错误</title>
      <link href="/articles/zzWA/"/>
      <url>/articles/zzWA/</url>
      <content type="html"><![CDATA[<p>总结一下再NOIP/NOI以及一些算法竞赛中的zz错误，<em>建议阅读</em></p><a id="more"></a><h2 id="一些编译错误"><a href="#一些编译错误" class="headerlink" title="一些编译错误"></a>一些编译错误</h2><h3 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argc[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*Code*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义了一些有锅的宏"><a href="#定义了一些有锅的宏" class="headerlink" title="定义了一些有锅的宏"></a>定义了一些有锅的宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*.....*/</span></span><br><span class="line"><span class="keyword">int</span> maxx = max(i++, j);</span><br></pre></td></tr></table></figure><p>注意！我们在传给宏定义的时候，是原样复制的！</p><p>也就是说，这条语句就是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxx = (((i++) &gt; (j)) ? (i++) : (j));</span><br></pre></td></tr></table></figure><p>可以看到，<code>i++</code>被执行了两次，就会凉凉</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>注意，我们再使用<code>Dev-c++</code>的时候，我们所使用的<code>freopen</code>流是包含在<code>iostream</code>库中的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILE</span></span><br><span class="line">    freopen (<span class="string">"Input.in"</span>  , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"Output.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; number;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (number + <span class="number">1</span>) * number / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图，这是求$1 + 2 + 3 + … + n$的程序</p><p>我们在本地用<code>Dev-c++</code>时，会成功编译</p><p>但是，到了<code>Lemon</code> , <code>Cena</code> 等评测机上，就会爆零</p><h3 id="文件freopen"><a href="#文件freopen" class="headerlink" title="文件freopen"></a>文件freopen</h3><p>很多选手都经常会在第一次考试中忘写freopen</p><h3 id="stdout-还是-stdin"><a href="#stdout-还是-stdin" class="headerlink" title="stdout 还是 stdin??"></a>stdout 还是 stdin??</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen (<span class="string">"Input.in"</span>  , <span class="string">"r"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">freopen (<span class="string">"Output.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdin</span> );</span><br></pre></td></tr></table></figure><p>上述代码<code>stdin</code>和<code>stdout</code>弄反了，爆零</p><p>再考试中一定要注意这些细节问题</p><h2 id="算法错误"><a href="#算法错误" class="headerlink" title="算法错误"></a>算法错误</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p><code>memset</code>函数只能对$-1$ 和$0$ ($0\times3f$)进行全体赋值！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span> (Array, <span class="number">19260817</span>, <span class="keyword">sizeof</span>(Array));</span><br></pre></td></tr></table></figure><p>这样不会江$Array$进行全体赋值为<code>19260817</code> !</p><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start_i; i &gt;= <span class="number">0</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start_j; i &gt;= <span class="number">0</span>; i++)</span><br></pre></td></tr></table></figure><p>上述代码明显会炸</p><hr><p>未完待续</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
            <tag> NOI </tag>
            
            <tag> 算法竞赛 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 智熄 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「数论」线性基</title>
      <link href="/articles/linear-basis/"/>
      <url>/articles/linear-basis/</url>
      <content type="html"><![CDATA[<p>线性基是出现在信息学竞赛中的一个名词，常见于神犇博客题解中</p><p>线性基也是数学中的一个常用的方法</p><a id="more"></a><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设数集$ T $的值域范围为$[1,2^n-1]$<br>$T$的线性基是$T$的一个子集$A={a_1,a_2,a_3,…,a_n}$<br>$A$中元素互相$xor$所形成的异或集合，等价于原数集$T$的元素互相$xor$形成的异或集合<br>可以理解为将原数集进行了压缩。</p><hr><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>线性基的异或集合中不存在$0$</li><li>线性基的异或集合中每个元素的异或唯一，其实这个跟性质1是等价的</li><li>线性基二进制最高位<em>互不相同</em></li><li>如果线性基是满的，它的异或集合为$[1,2^n-1]$</li><li>线性基中元素互相异或，异或集合不变</li></ol><hr><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>如果向线性基中插入数$x$，从高位到低位扫描它为$1$的<em>二进制位</em><br>扫描到第$i$时，如果$a_i$<em>不存在</em>，就令$a_i=x$，否则$x=x \otimes a_i$<br>$x$的结局是，要么被扔进线性基，要么经过一系列操作过后，变成了$0$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (val&amp;(<span class="number">1L</span>L &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a[i]) a[i] = val, <span class="keyword">break</span>;</span><br><span class="line">            val ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>将一个线性基暴力插入另一个线性基即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinearBasis <span class="title">merge</span><span class="params">(<span class="keyword">const</span> LinearBasis &amp;n1,<span class="keyword">const</span> LinearBasis &amp;n2, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    LinearBasis ret = n1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span> (n2.d[i]) ret.insert(n2.d[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinearBasis</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d[MAXN], p[MAXN];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    LinearBasis() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1L</span>L &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!d[i]) &#123;d[i] = val; <span class="keyword">break</span>;&#125;</span><br><span class="line">                val ^= d[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> ((ret ^ d[i]) &gt; ret) ret ^= d[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++)</span><br><span class="line">            <span class="keyword">if</span> (d[i]) <span class="keyword">return</span> d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">if</span> (d[i] &amp; (<span class="number">1L</span>L &lt;&lt; j)) d[i] ^= d[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++)</span><br><span class="line">            <span class="keyword">if</span> (d[i]) p[cnt++] = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthquery</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= (<span class="number">1L</span>L &lt;&lt; cnt))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span> (k&amp;(<span class="number">1L</span>L&lt;&lt;i))</span><br><span class="line">                ret^=p[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinearBasis <span class="title">merge</span><span class="params">(<span class="keyword">const</span> LinearBasis &amp;n1,<span class="keyword">const</span> LinearBasis &amp;n2, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    LinearBasis ret=n1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> (n2.d[i])</span><br><span class="line">            ret.insert(n1.d[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先写到这吧</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 线性基 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「总结」计算几何一些常用模板</title>
      <link href="/articles/Computational-geometry2/"/>
      <url>/articles/Computational-geometry2/</url>
      <content type="html"><![CDATA[<p>本文是计算几何一些模板的汇总</p><p>以后计算几何就不写板子了 ( 逃</p><a id="more"></a><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> abs(x)  (((x)&gt;0)?(x):-(x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI  = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///*************基础***********/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">torad</span><span class="params">(<span class="keyword">double</span> deg)</span> </span>&#123; <span class="keyword">return</span> deg / <span class="number">180</span> * PI; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0</span>, <span class="keyword">double</span> y=<span class="number">0</span>):x(x),y(y) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Vector <span class="keyword">operator</span>+ (Vector A, Vector B) &#123; <span class="keyword">return</span> Vector(A.x + B.x, A.y + B.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Vector <span class="keyword">operator</span>- (Point A, Point B) &#123; <span class="keyword">return</span> Vector(A.x - B.x, A.y - B.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Vector <span class="keyword">operator</span>* (Vector A, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> Vector(A.x * p, A.y * p); &#125;</span><br><span class="line"><span class="keyword">inline</span> Vector <span class="keyword">operator</span>/ (Vector A, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> Vector(A.x / p, A.y / p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point a, Point b) &#123; <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (Point a, Point b) &#123; <span class="keyword">return</span> dcmp(a.x - b.x) == <span class="number">0</span> &amp;&amp; dcmp(a.y - b.y) == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector A, Vector B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x * B.x + A.y * B.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(A, A));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector A, Vector B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(Dot(A, B) / Length(A) / Length(B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(v.y, v.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector A, Vector B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.x * B.y - A.y * B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vector <span class="title">Unit</span><span class="params">(Vector x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / Length(x);</span><br><span class="line">&#125;  <span class="comment">//单位向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vector <span class="title">Normal</span><span class="params">(Vector x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Point(-x.y, x.x) / Length(x);</span><br><span class="line">&#125; <span class="comment">//垂直法向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Area2</span><span class="params">(Point A, Point B, Point C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Cross(B - A, C - A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vector <span class="title">Rotate</span><span class="params">(Vector A, <span class="keyword">double</span> rad)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Vector(A.x * <span class="built_in">cos</span>(rad) - A.y*<span class="built_in">sin</span>(rad), A.x*<span class="built_in">sin</span>(rad) + A.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************直线与线段**************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求直线p+tv和q+tw的交点 Cross(v, w) == 0无交点</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point p, Vector v, Point q, Vector w)</span> </span>&#123;</span><br><span class="line">    Vector u = p - q;</span><br><span class="line">    <span class="keyword">double</span> t = Cross(w, u) / Cross(v, w);</span><br><span class="line">    <span class="keyword">return</span> p + v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//点p在直线ab的投影</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">GetLineProjection</span><span class="params">(Point P, Point A, Point B)</span> </span>&#123;</span><br><span class="line">    Vector v = B - A;</span><br><span class="line">    <span class="keyword">return</span> A + v * (Dot(v, P - A) / Dot(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//点到直线距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">DistanceToLine</span><span class="params">(Point P, Point A, Point B)</span> </span>&#123;</span><br><span class="line">    Vector v1 = B - A, v2 = P - A;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(v1, v2)) / Length(v1); <span class="comment">// 如果不取绝对值，得到的是有向距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//点在p线段上(包括端点)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(Cross(a1-p, a2-p)) == <span class="number">0</span> &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过两点p1, p2的直线一般方程ax+by+c=0</span></span><br><span class="line"><span class="comment">// (x2-x1)(y-y1) = (y2-y1)(x-x1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getLineGeneralEquation</span><span class="params">(Point p1, Point p2, <span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b, <span class="keyword">double</span> &amp;c)</span></span>&#123;</span><br><span class="line">    a = p2.y - p1.y;</span><br><span class="line">    b = p1.x - p2.x;</span><br><span class="line">    c = -a * p1.x - b * p1.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//点到线段距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> Length(p - a);</span><br><span class="line">    Vector v1 = b - a, v2 = p - a, v3 = p - b;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(Dot(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> Length(v2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dcmp(Dot(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> Length(v3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(v1, v2)) / Length(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两线段最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis_pair_seg</span><span class="params">(Point p1, Point p2, Point p3, Point p4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(DistanceToSegment(p1, p3, p4), DistanceToSegment(p2, p3, p4)),</span><br><span class="line">               <span class="built_in">std</span>::min(DistanceToSegment(p3, p1, p2), DistanceToSegment(p4, p1, p2)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线段相交判定</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),</span><br><span class="line">           c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有向直线。它的左边就是对应的半平面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point p, q;    <span class="comment">// 直线上任意一点,p作为起点</span></span><br><span class="line">    Vector v;   <span class="comment">// 方向向量</span></span><br><span class="line">    <span class="keyword">double</span> ang; <span class="comment">// 极角，即从x正半轴旋转到向量v所需要的角（弧度）</span></span><br><span class="line"></span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line"><span class="comment">//    Line(Point P, Vector v):p(P),v(v) &#123;</span></span><br><span class="line"><span class="comment">//        ang = atan2(v.y, v.x);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Line(Point P, Point Q):p(P), q(Q) &#123;</span><br><span class="line">        v = q - p;</span><br><span class="line">        ang = <span class="built_in">atan2</span>(v.y, v.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; L) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ang &lt; L.ang;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p + v * t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Line <span class="title">move</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Line(p + Normal(v) * d, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Point q;</span><br><span class="line">        p.read(), q.read();</span><br><span class="line">        v = q - p;</span><br><span class="line">        ang = <span class="built_in">atan2</span>(v.y, v.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两直线交点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">GetLineIntersection</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetLineIntersection(a.p, a.v, b.p, b.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点p在有向直线L的左边（线上不算）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">OnLeft</span><span class="params">(<span class="keyword">const</span> Line&amp; L, <span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Cross(L.v, p - L.p) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 二直线交点，假定交点惟一存在</span></span><br><span class="line"><span class="comment">//Point GetLineIntersection(const Line&amp; a, const Line&amp; b) &#123;</span></span><br><span class="line"><span class="comment">//  Vector u = a.P-b.P;</span></span><br><span class="line"><span class="comment">//  double t = Cross(b.v, u) / Cross(a.v, b.v);</span></span><br><span class="line"><span class="comment">//  return a.P+a.v*t;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 半平面交主过程</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; HalfplaneIntersection(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Line&gt; L) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = L.size();</span><br><span class="line"></span><br><span class="line">    sort(L.begin(), L.end()); <span class="comment">// 按极角排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first, last;         <span class="comment">// 双端队列的第一个元素和最后一个元素的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p(n);      <span class="comment">// p[i]为q[i]和q[i+1]的交点</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Line&gt; q(n);       <span class="comment">// 双端队列</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ans;       <span class="comment">// 结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    q[first=last=<span class="number">0</span>] = L[<span class="number">0</span>];  <span class="comment">// 双端队列初始化为只有一个半平面L[0]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; !OnLeft(L[i], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++;</span><br><span class="line">        q[++last] = L[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(Cross(q[last].v, q[last - <span class="number">1</span>].v)) &lt; eps) &#123;</span><br><span class="line">            last--;</span><br><span class="line">            <span class="keyword">if</span>(OnLeft(q[last], L[i].p)) q[last] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first &lt; last) p[last - <span class="number">1</span>] = GetLineIntersection(q[last - <span class="number">1</span>], q[last]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last &amp;&amp; !OnLeft(q[first], p[last<span class="number">-1</span>])) last--; <span class="comment">// 删除无用平面</span></span><br><span class="line">    <span class="keyword">if</span>(last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span> ans; <span class="comment">// 空集</span></span><br><span class="line">    p[last] = GetLineIntersection(q[last], q[first]); <span class="comment">// 计算首尾两个半平面的交点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从deque复制到输出中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first; i &lt;= last; i++) ans.push_back(p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********多边形**************/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        area += Cross(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span> ] - p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> area / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点是否在多边形内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Polygon poly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = poly.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (OnSegment(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">int</span> k = dcmp(Cross(poly[(i + <span class="number">1</span>) % n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(poly[i].y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//内部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//外部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多边形重心 点集逆时针给出</span></span><br><span class="line"><span class="function">Point <span class="title">PolyGravity</span><span class="params">(Point *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Point tmp, g = Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> sumArea = <span class="number">0</span>, area;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        area = Cross(p[i<span class="number">-1</span>]-p[<span class="number">0</span>], p[i]-p[<span class="number">0</span>]);</span><br><span class="line">        sumArea += area;</span><br><span class="line">        tmp.x = p[<span class="number">0</span>].x + p[i<span class="number">-1</span>].x + p[i].x;</span><br><span class="line">        tmp.y = p[<span class="number">0</span>].y + p[i<span class="number">-1</span>].y + p[i].y;</span><br><span class="line">        g.x += tmp.x * area;</span><br><span class="line">        g.y += tmp.y * area;</span><br><span class="line">    &#125;</span><br><span class="line">    g.x /= (sumArea * <span class="number">3.0</span>); g.y /= (sumArea * <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多边形重心计算模板</span></span><br><span class="line"><span class="function">Point <span class="title">bcenter</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; pnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pnt.size();</span><br><span class="line">    Point p, s;</span><br><span class="line">    <span class="keyword">double</span> tp, area = <span class="number">0</span>, tpx = <span class="number">0</span>, tpy = <span class="number">0</span>;</span><br><span class="line">    p.x = pnt[<span class="number">0</span>].x;</span><br><span class="line">    p.y = pnt[<span class="number">0</span>].y;</span><br><span class="line">    <span class="comment">//FE(i, 1, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s.x = pnt[(i == n) ? <span class="number">0</span> : i].x;</span><br><span class="line">        s.y = pnt[(i == n) ? <span class="number">0</span> : i].y;</span><br><span class="line">        tp = (p.x * s.y - s.x * p.y);</span><br><span class="line">        area += tp / <span class="number">2</span>;</span><br><span class="line">        tpx += (p.x + s.x) * tp;</span><br><span class="line">        tpy += (p.y + s.y) * tp;</span><br><span class="line">        p.x = s.x;</span><br><span class="line">        p.y = s.y;</span><br><span class="line">    &#125;</span><br><span class="line">    s.x = tpx / (<span class="number">6</span> * area);</span><br><span class="line">    s.y = tpy / (<span class="number">6</span> * area);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点集凸包</span></span><br><span class="line"><span class="comment">// 如果希望在凸包的边上有输入点，把两个 &lt;= 改成 &lt;</span></span><br><span class="line"><span class="comment">// 注意：输入点集会被修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ConvexHull(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; p) &#123;</span><br><span class="line">    <span class="comment">// 预处理，删除重复点</span></span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    p.erase(unique(p.begin(), p.end()), p.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ch(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span> &amp;&amp; Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>], p[i]-ch[m<span class="number">-2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; k &amp;&amp; Cross(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) m--;</span><br><span class="line">    ch.resize(m);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Dist2</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x - b.x) + <span class="built_in">sqrt</span>(a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回点集直径的平方</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diameter2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p = ConvexHull(points);</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> Dist2(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">    p.push_back(p[<span class="number">0</span>]); <span class="comment">// 免得取模</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">1</span>; u &lt; n; u++) &#123;</span><br><span class="line">        <span class="comment">// 一条直线贴住边p[u]-p[u+1]</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 当Area(p[u], p[u + 1], p[v + 1]) &lt;= Area(p[u], p[u + 1], p[v])时停止旋转</span></span><br><span class="line">            <span class="comment">// 即Cross(p[u + 1] - p[u], p[v + 1] - p[u]) - Cross(p[u + 1] - p[u], p[v] - p[u]) &lt;= 0</span></span><br><span class="line">            <span class="comment">// 根据Cross(A, B) - Cross(A, C) = Cross(A, B - C)</span></span><br><span class="line">            <span class="comment">// 化简得Cross(p[u + 1] - p[u], p[v + 1] - p[v]) &lt;= 0</span></span><br><span class="line">            <span class="keyword">int</span> diff = Cross(p[u + <span class="number">1</span>] - p[u], p[v + <span class="number">1</span>]-p[v]);</span><br><span class="line">            <span class="keyword">if</span>(diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, Dist2(p[u], p[v])); <span class="comment">// u和v是对踵点</span></span><br><span class="line">                <span class="keyword">if</span>(diff == <span class="number">0</span>) ans = <span class="built_in">std</span>::max(ans, Dist2(p[u], p[v+<span class="number">1</span>])); <span class="comment">// diff == 0时u和v+1也是对踵点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v = (v + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两凸包最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RC_Distance</span><span class="params">(Point *ch1, Point *ch2, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(ch1[i].y-ch1[p].y &lt; -eps) p = i;</span><br><span class="line">    <span class="comment">//REP(i, m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(ch2[i].y - ch2[q].y &gt; eps) q = i;</span><br><span class="line">    ch1[n] = ch1[<span class="number">0</span>];</span><br><span class="line">    ch2[m] = ch2[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> tmp, ans = <span class="number">1e100</span>;</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>((tmp = Cross(ch1[p + <span class="number">1</span>] - ch1[p], ch2[q + <span class="number">1</span>] - ch1[p]) - Cross(ch1[p + <span class="number">1</span>] - ch1[p], ch2[q] - ch1[p])) &gt; eps)</span><br><span class="line">            q = (q + <span class="number">1</span>)%m;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; -eps) ans = <span class="built_in">std</span>::min(ans, DistanceToSegment(ch2[q], ch1[p], ch1[p + <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">std</span>::min(ans,dis_pair_seg(ch1[p],ch1[p+<span class="number">1</span>],ch2[q],ch2[q+<span class="number">1</span>]));</span><br><span class="line">        p=(p + <span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两凸包最近距离</span></span><br><span class="line"><span class="comment">//使用vector</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RC_Distance</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ch1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ch2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>, p = <span class="number">0</span>, n = ch1.size(), m = ch2.size();</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(ch1[i].y - ch1[p].y &lt; -eps) p = i;</span><br><span class="line">    <span class="comment">//REP(i, m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(ch2[i].y - ch2[q].y &gt; eps) q = i;</span><br><span class="line">    ch1.push_back(ch1[<span class="number">0</span>]), ch2.push_back(ch2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> tmp, ans = <span class="number">1e100</span>;</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>((tmp = Cross(ch1[p + <span class="number">1</span>] - ch1[p], ch2[q + <span class="number">1</span>] - ch1[p]) - Cross(ch1[p + <span class="number">1</span>] - ch1[p], ch2[q] - ch1[p])) &gt; eps)</span><br><span class="line">            q = (q + <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; -eps) ans = <span class="built_in">std</span>::min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">std</span>::min(ans,dis_pair_seg(ch1[p],ch1[p+<span class="number">1</span>],ch2[q],ch2[q+<span class="number">1</span>]));</span><br><span class="line">        p = (p + <span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//凸包最大内接三角形</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RC_Triangle</span><span class="params">(Point* res,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">    res[n] = res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = (i +<span class="number">1</span>)%n;</span><br><span class="line">        k = (j +<span class="number">1</span>)%n;</span><br><span class="line">        <span class="keyword">while</span>((j != k) &amp;&amp; (k != i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(Cross(res[j] - res[i], res[k +<span class="number">1</span>] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k +<span class="number">1</span>)%n;</span><br><span class="line">            tmp = Cross(res[j] - res[i], res[k] - res[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; ans) ans = tmp;</span><br><span class="line">            j = (j +<span class="number">1</span>)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//凸包最大内接三角形</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RC_Triangle2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; res, Point&amp; a, Point&amp; b, Point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = res.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>, tmp;</span><br><span class="line">    res.push_back(res[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        j = (i+<span class="number">1</span>)%n;</span><br><span class="line">        k = (j+<span class="number">1</span>)%n;</span><br><span class="line">        <span class="keyword">while</span>((j != k) &amp;&amp; (k != i)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(Cross(res[j] - res[i], res[k+<span class="number">1</span>] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+<span class="number">1</span>)%n;</span><br><span class="line">            tmp = Cross(res[j] - res[i], res[k] - res[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; ans) &#123;</span><br><span class="line">                a = res[i], b = res[j], c = res[k];</span><br><span class="line">                ans = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            j = (j+<span class="number">1</span>)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断两凸包是否有交点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ConvexPolygonDisjoint</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ch1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ch2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = ch1.size();</span><br><span class="line">    <span class="keyword">int</span> c2 = ch2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++)</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(ch1[i], ch2) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内部或边界上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; i++)</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(ch2[i], ch1) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内部或边界上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++)</span><br><span class="line">            <span class="keyword">if</span>(SegmentProperIntersection(ch1[i], ch1[(i+<span class="number">1</span>)%c1], ch2[j], ch2[(j+<span class="number">1</span>)%c2]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Length(a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////模拟退火求费马点 保存在ptres中</span></span><br><span class="line"><span class="comment">//double fermat_point(Point *pt, int n, Point&amp; ptres) &#123;</span></span><br><span class="line"><span class="comment">//    Point u, v;</span></span><br><span class="line"><span class="comment">//    double step = 0.0, curlen, explen, std::minlen;</span></span><br><span class="line"><span class="comment">//    int i, j, k;</span></span><br><span class="line"><span class="comment">//    bool flag;</span></span><br><span class="line"><span class="comment">//    u.x = u.y = v.x = v.y = 0.0;</span></span><br><span class="line"><span class="comment">//    //REP(i, n)</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//        step += fabs(pt[i].x) + fabs(pt[i].y);</span></span><br><span class="line"><span class="comment">//        u.x += pt[i].x;</span></span><br><span class="line"><span class="comment">//        u.y += pt[i].y;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    u.x /= n;</span></span><br><span class="line"><span class="comment">//    u.y /= n;</span></span><br><span class="line"><span class="comment">//    flag = 0;</span></span><br><span class="line"><span class="comment">//    while(step &gt; eps) &#123;</span></span><br><span class="line"><span class="comment">//        for(k = 0; k &lt; 10; step /= 2, ++k)</span></span><br><span class="line"><span class="comment">//            for(i = -1; i &lt;= 1; ++i)</span></span><br><span class="line"><span class="comment">//                for(j = -1; j &lt;= 1; ++j) &#123;</span></span><br><span class="line"><span class="comment">//                    v.x = u.x + step*i;</span></span><br><span class="line"><span class="comment">//                    v.y = u.y + step*j;</span></span><br><span class="line"><span class="comment">//                    curlen = explen = 0.0;</span></span><br><span class="line"><span class="comment">//                    //REP(i, n)</span></span><br><span class="line"><span class="comment">//                    for(int i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//                        curlen += dist(u, pt[idx]);</span></span><br><span class="line"><span class="comment">//                        explen += dist(v, pt[idx]);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    if(curlen &gt; explen) &#123;</span></span><br><span class="line"><span class="comment">//                        u = v;</span></span><br><span class="line"><span class="comment">//                        std::minlen = explen;</span></span><br><span class="line"><span class="comment">//                        flag = 1;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    ptres = u;</span></span><br><span class="line"><span class="comment">//    return flag ? std::minlen : curlen;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多边形费马点</span></span><br><span class="line"><span class="comment">//到所有顶点的距离和最小</span></span><br><span class="line"><span class="function">Point <span class="title">Fermat</span><span class="params">(<span class="keyword">int</span> np, Point* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> nowx = <span class="number">0</span>, nowy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> nextx = <span class="number">0</span>, nexty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//REP(i, np)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=np;i++) &#123;</span><br><span class="line">        nowx += p[i].x;</span><br><span class="line">        nowy += p[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (nowx /= np, nowy /= np;; nowx = nextx, nowy = nexty) &#123;</span><br><span class="line">        <span class="keyword">double</span> topx = <span class="number">0</span>, topy = <span class="number">0</span>, bot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//REP(i, np)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=np;i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(nowx - p[i].x) + <span class="built_in">sqrt</span>(nowy - p[i].y));</span><br><span class="line">            topx += p[i].x / d;</span><br><span class="line">            topy += p[i].y / d;</span><br><span class="line">            bot += <span class="number">1</span> / d;</span><br><span class="line">        &#125;</span><br><span class="line">        nextx = topx / bot;</span><br><span class="line">        nexty = topy / bot;</span><br><span class="line">        <span class="keyword">if</span> (dcmp(nextx - nowx) == <span class="number">0</span> &amp;&amp; dcmp(nexty - nowy) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point fp;</span><br><span class="line">    fp.x = nowx;</span><br><span class="line">    fp.y = nowy;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最近点对</span></span><br><span class="line"><span class="comment">//使用前先对输入的point进行排序,使用cmpxy函数</span></span><br><span class="line">Point point[N];</span><br><span class="line"><span class="keyword">int</span> tmpt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Point&amp; a = point[x];</span><br><span class="line">    Point&amp; b = point[y];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(a.x - b.x) + <span class="built_in">sqrt</span>(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpxy</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> point[a].y &lt; point[b].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Closest_Pair</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = INF;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">if</span>(left + <span class="number">1</span> == right)</span><br><span class="line">        <span class="keyword">return</span> dist(left, right);</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = Closest_Pair(left,mid); </span><br><span class="line">    <span class="keyword">double</span> d2 = Closest_Pair(mid+<span class="number">1</span>,right);</span><br><span class="line">    d = <span class="built_in">std</span>::min(d1,d2);</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分离出宽度为d的区间</span></span><br><span class="line">    <span class="comment">//FE(i, left, right)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(point[mid].x-point[i].x) &lt;= d)</span><br><span class="line">            tmpt[k++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(tmpt,tmpt+k,cmpy);</span><br><span class="line">    <span class="comment">//线性扫描</span></span><br><span class="line">    <span class="comment">//REP(i, k)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; k &amp;&amp; point[tmpt[j]].y-point[tmpt[i]].y&lt;d; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> d3 = dist(tmpt[i],tmpt[j]);</span><br><span class="line">            <span class="keyword">if</span>(d &gt; d3)</span><br><span class="line">                d = d3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************圆************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle() &#123;&#125;</span><br><span class="line">    Circle(Point c, <span class="keyword">double</span> r):c(c), r(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> a)</span> <span class="comment">//根据圆心角求点坐标</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(c.x+<span class="built_in">cos</span>(a)*r, c.y+<span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;c.x, &amp;c.y, &amp;r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求a点到b点(逆时针)在的圆上的圆弧长度</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DisOnCircle</span><span class="params">(Point a, Point b, Circle C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ang1 = angle(a - C.c);</span><br><span class="line">    <span class="keyword">double</span> ang2 = angle(b - C.c);</span><br><span class="line">    <span class="keyword">if</span> (ang2 &lt; ang1) ang2 += <span class="number">2</span> * PI;</span><br><span class="line">    <span class="keyword">return</span> C.r * (ang2 - ang1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直线与圆交点 返回个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="keyword">double</span> e = a*a + c*c, f = <span class="number">2</span>*(a*b + c*d), g = b*b + d*d - C.r*C.r;</span><br><span class="line">    <span class="keyword">double</span> delta = f*f - <span class="number">4</span>*e*g; <span class="comment">// 判别式</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(delta) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 相离</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(delta) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 相切</span></span><br><span class="line">        t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line">        sol.push_back(L.point(t1));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相交</span></span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e);</span><br><span class="line">    sol.push_back(L.point(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e);</span><br><span class="line">    sol.push_back(L.point(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两圆交点 返回个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircleCircleIntersection</span><span class="params">(Circle C1, Circle C2, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = Length(C1.c - C2.c);</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(C1.r - C2.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 重合，无穷多交点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(C1.r + C2.r - d) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(<span class="built_in">fabs</span>(C1.r-C2.r) - d) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> a = angle(C2.c - C1.c);</span><br><span class="line">    <span class="keyword">double</span> da = <span class="built_in">acos</span>((C1.r*C1.r + d*d - C2.r*C2.r) / (<span class="number">2</span>*C1.r*d));</span><br><span class="line">    Point p1 = C1.point(a-da), p2 = C1.point(a+da);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sol.push_back(p1);</span><br><span class="line">    <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    sol.push_back(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过点p到圆C的切线。v[i]是第i条切线的向量。返回切线条数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Point p, Circle C, Vector* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector u = C.c - p;</span><br><span class="line">    <span class="keyword">double</span> dist = Length(u);</span><br><span class="line">    <span class="keyword">if</span>(dist &lt; C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dcmp(dist - C.r) == <span class="number">0</span>)   <span class="comment">// p在圆上，只有一条切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        v[<span class="number">0</span>] = Rotate(u, PI/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">asin</span>(C.r / dist);</span><br><span class="line">        v[<span class="number">0</span>] = Rotate(u, -ang);</span><br><span class="line">        v[<span class="number">1</span>] = Rotate(u, +ang);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两圆的公切线, -1表示无穷条切线</span></span><br><span class="line"><span class="comment">//返回切线的条数, -1表示无穷条切线</span></span><br><span class="line"><span class="comment">//a[i]和b[i]分别是第i条切线在圆A和圆B上的切点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Circle A, Circle B, Point* a, Point* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (A.r &lt; B.r) <span class="built_in">std</span>::swap(A, B), <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">    <span class="comment">///****************************</span></span><br><span class="line">    <span class="keyword">int</span> d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff = A.r - B.r;</span><br><span class="line">    <span class="keyword">int</span> rsum = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span> (d2 &lt; rdiff * rdiff) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//内含</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///***************************************</span></span><br><span class="line">    <span class="keyword">double</span> base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; A.r == B.r) <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//无线多条切线</span></span><br><span class="line">    <span class="keyword">if</span> (d2 == rdiff * rdiff)    <span class="comment">//内切, 1条切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///**********************</span></span><br><span class="line">        a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有外公切线</span></span><br><span class="line">    <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r - B.r) / <span class="built_in">sqrt</span>(d2 * <span class="number">1.0</span>));</span><br><span class="line">    a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++;</span><br><span class="line">    a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rsum * rsum)  <span class="comment">//一条内公切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d2 &gt; rsum * rsum)  <span class="comment">//两条内公切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r + B.r) / <span class="built_in">sqrt</span>(d2 * <span class="number">1.0</span>));</span><br><span class="line">        a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++;</span><br><span class="line">        a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过点p到圆C的切点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangentPoints</span><span class="params">(Point p, Circle C, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector u = C.c - p;</span><br><span class="line">    <span class="keyword">double</span> dist = Length(u);</span><br><span class="line">    <span class="keyword">if</span>(dist &lt; C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dcmp(dist - C.r) == <span class="number">0</span>)   <span class="comment">// p在圆上，只有一条切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">asin</span>(C.r / dist);</span><br><span class="line">        <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(dist * dist - C.r * C.r);</span><br><span class="line">        v.push_back(p + Unit(Rotate(u, -ang)) * d);</span><br><span class="line">        v.push_back(p + Unit(Rotate(u, +ang)) * d);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆A与圆B的切点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTangentPoints</span><span class="params">(Circle A, Circle B, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.r &lt; B.r) <span class="built_in">std</span>::swap(A, B);</span><br><span class="line">    <span class="comment">///****************************</span></span><br><span class="line">    <span class="keyword">int</span> d2 = <span class="built_in">sqrt</span>(A.c.x - B.c.x) + <span class="built_in">sqrt</span>(A.c.y - B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff = A.r - B.r, rsum = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span> (d2 &lt; rdiff * rdiff) <span class="keyword">return</span>;   <span class="comment">//内含</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///***************************************</span></span><br><span class="line">    <span class="keyword">double</span> base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; A.r == B.r) <span class="keyword">return</span>;    <span class="comment">//无线多条切线</span></span><br><span class="line">    <span class="keyword">if</span> (d2 == rdiff * rdiff)    <span class="comment">//内切, 1条切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///**********************</span></span><br><span class="line">        a.push_back(A.point(base));</span><br><span class="line">        a.push_back(B.point(base));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有外公切线</span></span><br><span class="line">    <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r - B.r) / <span class="built_in">sqrt</span>(d2 * <span class="number">1.0</span>));</span><br><span class="line">    a.push_back(A.point(base + ang)); a.push_back(B.point(base + ang));</span><br><span class="line">    a.push_back(A.point(base - ang)); a.push_back(B.point(base - ang));</span><br><span class="line">    <span class="keyword">if</span> (d2 == rsum * rsum)  <span class="comment">//一条内公切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(A.point(base));</span><br><span class="line">        a.push_back(B.point(PI + base));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d2 &gt; rsum * rsum)  <span class="comment">//两条内公切线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r + B.r) / <span class="built_in">sqrt</span>(d2 * <span class="number">1.0</span>));</span><br><span class="line">        a.push_back(A.point(base + ang));</span><br><span class="line">        a.push_back(B.point(PI + base + ang));</span><br><span class="line">        a.push_back(A.point(base - ang));</span><br><span class="line">        a.push_back(B.point(PI + base - ang));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形外接圆</span></span><br><span class="line"><span class="function">Circle <span class="title">CircumscribedCircle</span><span class="params">(Point p1, Point p2, Point p3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Bx = p2.x-p1.x, By = p2.y-p1.y;</span><br><span class="line">    <span class="keyword">double</span> Cx = p3.x-p1.x, Cy = p3.y-p1.y;</span><br><span class="line">    <span class="keyword">double</span> D = <span class="number">2</span>*(Bx*Cy-By*Cx);</span><br><span class="line">    <span class="keyword">double</span> cx = (Cy*(Bx*Bx+By*By) - By*(Cx*Cx+Cy*Cy))/D + p1.x;</span><br><span class="line">    <span class="keyword">double</span> cy = (Bx*(Cx*Cx+Cy*Cy) - Cx*(Bx*Bx+By*By))/D + p1.y;</span><br><span class="line">    Point p = Point(cx, cy);</span><br><span class="line">    <span class="keyword">return</span> Circle(p, Length(p1-p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形内切圆</span></span><br><span class="line"><span class="function">Circle <span class="title">InscribedCircle</span><span class="params">(Point p1, Point p2, Point p3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = Length(p2-p3);</span><br><span class="line">    <span class="keyword">double</span> b = Length(p3-p1);</span><br><span class="line">    <span class="keyword">double</span> c = Length(p1-p2);</span><br><span class="line">    Point p = (p1*a+p2*b+p3*c)/(a+b+c);</span><br><span class="line">    <span class="keyword">return</span> Circle(p, DistanceToLine(p, p1, p2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有经过点p 半径为r 且与直线L相切的圆心</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; CircleThroughPointTangentToLineGivenRadius(Point p, Line L, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ans;</span><br><span class="line">    <span class="keyword">double</span> t1, t2;</span><br><span class="line">    getLineCircleIntersection(L.move(-r), Circle(p, r), t1, t2, ans);</span><br><span class="line">    getLineCircleIntersection(L.move(r), Circle(p, r), t1, t2, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//半径为r 与a b两直线相切的圆心</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; CircleTangentToLinesGivenRadius(Line a, Line b, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ans;</span><br><span class="line">    Line L1 = a.move(-r), L2 = a.move(r);</span><br><span class="line">    Line L3 = b.move(-r), L4 = b.move(r);</span><br><span class="line">    ans.push_back(GetLineIntersection(L1, L3));</span><br><span class="line">    ans.push_back(GetLineIntersection(L1, L4));</span><br><span class="line">    ans.push_back(GetLineIntersection(L2, L3));</span><br><span class="line">    ans.push_back(GetLineIntersection(L2, L4));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//与两圆相切 半径为r的所有圆心</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; CircleTangentToTwoDisjointCirclesWithRadius(Circle c1, Circle c2, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; ans;</span><br><span class="line">    Vector v = c2.c - c1.c;</span><br><span class="line">    <span class="keyword">double</span> dist = Length(v);</span><br><span class="line">    <span class="keyword">int</span> d = dcmp(dist - c1.r -c2.r - r*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(d &gt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    getCircleCircleIntersection(Circle(c1.c, c1.r+r), Circle(c2.c, c2.r+r), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多边形与圆相交面积</span></span><br><span class="line"><span class="function">Point <span class="title">GetIntersection</span><span class="params">(Line a, Line b)</span> <span class="comment">//线段交点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector u = a.p-b.p;</span><br><span class="line">    <span class="keyword">double</span> t = Cross(b.v, u) / Cross(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p + a.v*t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InCircle</span><span class="params">(Point x, Circle c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(c.r - Length(c.c - x)) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">OnCircle</span><span class="params">(Point x, Circle c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(c.r - Length(c.c - x)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段与圆的交点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSegCircleIntersection</span><span class="params">(Line L, Circle C, Point* sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector nor = Normal(L.v);</span><br><span class="line">    Line pl = Line(C.c, nor);</span><br><span class="line">    Point ip = GetIntersection(pl, L);</span><br><span class="line">    <span class="keyword">double</span> dis = Length(ip - C.c);</span><br><span class="line">    <span class="keyword">if</span> (dcmp(dis - C.r) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Point dxy = Unit(L.v) * <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(C.r) - <span class="built_in">sqrt</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    sol[ret] = ip + dxy;</span><br><span class="line">    <span class="keyword">if</span> (OnSegment(sol[ret], L.p, L.point(<span class="number">1</span>))) ret++;</span><br><span class="line">    sol[ret] = ip - dxy;</span><br><span class="line">    <span class="keyword">if</span> (OnSegment(sol[ret], L.p, L.point(<span class="number">1</span>))) ret++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段切割圆</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SegCircleArea</span><span class="params">(Circle C, Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a1 = angle(a - C.c);</span><br><span class="line">    <span class="keyword">double</span> a2 = angle(b - C.c);</span><br><span class="line">    <span class="keyword">double</span> da = <span class="built_in">fabs</span>(a1 - a2);</span><br><span class="line">    <span class="keyword">if</span> (da &gt; PI) da = PI * <span class="number">2.0</span> - da;</span><br><span class="line">    <span class="keyword">return</span> dcmp(Cross(b - C.c, a - C.c)) * da * <span class="built_in">sqrt</span>(C.r) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多边形与圆相交面积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolyCiclrArea</span><span class="params">(Circle C, Point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">    Point sol[<span class="number">2</span>];</span><br><span class="line">    p[n] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//REP(i, n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//double t1, t2;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = getSegCircleIntersection(Line(p[i], p[i+<span class="number">1</span>]-p[i]), C, sol);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!InCircle(p[i], C) || !InCircle(p[i+<span class="number">1</span>], C)) ret += SegCircleArea(C, p[i], p[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> ret += Cross(p[i+<span class="number">1</span>] - C.c, p[i] - C.c) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (InCircle(p[i], C) &amp;&amp; !InCircle(p[i+<span class="number">1</span>], C)) ret += Cross(sol[<span class="number">0</span>] - C.c, p[i] - C.c) / <span class="number">2.0</span>, ret += SegCircleArea(C, sol[<span class="number">0</span>], p[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> ret += SegCircleArea(C, p[i], sol[<span class="number">0</span>]), ret += Cross(p[i+<span class="number">1</span>] - C.c, sol[<span class="number">0</span>] - C.c) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p[i] &lt; p[i + <span class="number">1</span>]) ^ (sol[<span class="number">0</span>] &lt; sol[<span class="number">1</span>])) <span class="built_in">std</span>::swap(sol[<span class="number">0</span>], sol[<span class="number">1</span>]);</span><br><span class="line">            ret += SegCircleArea(C, p[i], sol[<span class="number">0</span>]);</span><br><span class="line">            ret += Cross(sol[<span class="number">1</span>] - C.c, sol[<span class="number">0</span>] - C.c) / <span class="number">2.0</span>;</span><br><span class="line">            ret += SegCircleArea(C, sol[<span class="number">1</span>], p[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;p)</span> <span class="comment">//计算凸包的面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sz = p.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz - <span class="number">1</span>; i++)</span><br><span class="line">        ans += Cross(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span>] - p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">seg</span><span class="params">(Point o, Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(b.x - a.x) == <span class="number">0</span>) <span class="keyword">return</span> (o.y - a.y) / (b.y - a.y);</span><br><span class="line">    <span class="keyword">return</span> (o.x - a.x) / (b.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; pp[<span class="number">110</span>];</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; s[<span class="number">2000200</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">polyunion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;*p, <span class="keyword">int</span> n)</span><span class="comment">//求n个多凸包的面积交</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = p[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">            s[m++] = mp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            s[m++] = mp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            Point a = p[i][j], b = p[i][(j + <span class="number">1</span>) % sz];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> siz = p[k].size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; siz; ii++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Point c = p[k][ii], d = p[k][(ii + <span class="number">1</span>) % siz];</span><br><span class="line">                        <span class="keyword">int</span> c1 = dcmp(Cross(b - a, c - a));</span><br><span class="line">                        <span class="keyword">int</span> c2 = dcmp(Cross(b - a, d - a));</span><br><span class="line">                        <span class="keyword">if</span> (c1 == <span class="number">0</span> &amp;&amp; c2 == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dcmp(Dot(b - a, d - c)) &gt; <span class="number">0</span> &amp;&amp; i &gt; k)</span><br><span class="line">                            &#123;</span><br><span class="line">                                s[m++] = mp(seg(c, a, b), <span class="number">1</span>);</span><br><span class="line">                                s[m++] = mp(seg(d, a, b), <span class="number">-1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">double</span> s1 = Cross(d - c, a - c);</span><br><span class="line">                            <span class="keyword">double</span> s2 = Cross(d - c, b - c);</span><br><span class="line">                            <span class="keyword">if</span> (c1 &gt;= <span class="number">0</span> &amp;&amp; c2 &lt; <span class="number">0</span>) s[m++] = mp(s1 / (s1 - s2), <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (c1 &lt; <span class="number">0</span> &amp;&amp; c2 &gt;= <span class="number">0</span>) s[m++] = mp(s1 / (s1 - s2), <span class="number">-1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(s, s + m);</span><br><span class="line">            <span class="keyword">double</span> pre = <span class="built_in">std</span>::min(<span class="built_in">std</span>::max(s[<span class="number">0</span>].first, <span class="number">0.0</span>), <span class="number">1.0</span>), now;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cov = s[<span class="number">0</span>].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                now = <span class="built_in">std</span>::min(<span class="built_in">std</span>::max(s[j].first, <span class="number">0.0</span>), <span class="number">1.0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!cov) sum += now - pre;</span><br><span class="line">                cov += s[j].second;</span><br><span class="line">                pre = now;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += Cross(a, b)*sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1,x2,x3,x4,y1,y2,y3,y4;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2))&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x3,&amp;y3,&amp;x4,&amp;y4);</span><br><span class="line"></span><br><span class="line">        pp[<span class="number">0</span>].clear();</span><br><span class="line">        pp[<span class="number">1</span>].clear();</span><br><span class="line"></span><br><span class="line">        pp[<span class="number">0</span>].pb(Point(x1,y1));</span><br><span class="line">        pp[<span class="number">0</span>].pb(Point(x1,y2));</span><br><span class="line">        pp[<span class="number">0</span>].pb(Point(x2,y1));</span><br><span class="line">        pp[<span class="number">0</span>]=ConvexHull(pp[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;pp[0].size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            printf("%lf  %lf\n",pp[0][i].x,pp[0][i].y);</span></span><br><span class="line"><span class="comment">//        &#125;puts("-----");</span></span><br><span class="line">        pp[<span class="number">1</span>].pb(Point(x3,y3));</span><br><span class="line">        pp[<span class="number">1</span>].pb(Point(x3,y4));</span><br><span class="line">        pp[<span class="number">1</span>].pb(Point(x4,y3));</span><br><span class="line">        pp[<span class="number">1</span>].pb(Point(x4,y4));</span><br><span class="line">        pp[<span class="number">1</span>]=ConvexHull(pp[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;pp[1].size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            printf("%lf  %lf\n",pp[1][i].x,pp[1][i].y);</span></span><br><span class="line"><span class="comment">//        &#125;puts("-----");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> t1 = area(pp[<span class="number">0</span>]) + area(pp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> t2 = polyunion(pp, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,t1-t2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"asdf.in"</span> ,<span class="string">"r"</span>,<span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"asdf.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">double</span> _time_tabris=clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    Main();w</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"time: %lf\n"</span>,clock()-_time_tabris);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>就写到这里了</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法模板》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 几何 </tag>
            
            <tag> 模板 </tag>
            
            <tag> 凸包 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「笔记」计算几何笔记</title>
      <link href="/articles/Computational-geometry1/"/>
      <url>/articles/Computational-geometry1/</url>
      <content type="html"><![CDATA[<p>本篇是关于计算几何知识的一些总结</p><a id="more"></a><h2 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h2><p>计算几何经常牵扯到浮点数的运算，所以就会产生精度误差，因此我们需要设置一个eps（偏差值），一般取$10^{-7}$到$10^{-10}$之间，并用下面的函数控制精度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>有大小有方向的量，又称为矢量。</p><p>二维的向量常用一个对数$(x,y)$表示，代码中常用一个结构体来实现向量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">  </span><br><span class="line">    Vector(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y) &#123;</span><br><span class="line">        x = _x; y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>向量的模,即向量的长度</p><p>$$ \overrightarrow a = ( x , y ) $$</p><p>$$ \vert \overrightarrow a \vert = \sqrt{x^2 + y^2}$$  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="built_in">vector</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维平面中的点，同样可以用对数$(x,y)$来表示，所以向量的存储方式同样可以用于点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span> point;</span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>（1）点加减向量为点</p><p>（2）点减点为向量</p><h3 id="极角"><a href="#极角" class="headerlink" title="极角"></a>极角</h3><p>对于向量$ \overrightarrow a(x,y)$，可以用函数$atan2(y,x)$来计算他的极角</p><p>按照极角为关键字排序后的顺序为<strong>极角序</strong></p><h3 id="向量的四则运算"><a href="#向量的四则运算" class="headerlink" title="向量的四则运算"></a>向量的四则运算</h3><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> +  (<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)  &#123;<span class="keyword">return</span> <span class="built_in">vector</span> (a.x + b.x,a.y + b.y);&#125;  </span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> -  (<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)  &#123;<span class="keyword">return</span> <span class="built_in">vector</span> (a.x - b.x,a.y - b.y);&#125;  </span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> *  (<span class="built_in">vector</span> a, <span class="keyword">double</span> p)  &#123;<span class="keyword">return</span> <span class="built_in">vector</span> (a.x * p,a.y * p);    &#125;  </span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> /  (<span class="built_in">vector</span> a. <span class="keyword">double</span> p)  &#123;<span class="keyword">return</span> <span class="built_in">vector</span> (a.x / p,a.y / p);    &#125;</span><br></pre></td></tr></table></figure><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><p>$ \overrightarrow a \times \overrightarrow  b$的几何意义为$a$在$b$上的投影长度乘以$b$的模长</p><p>$$ \overrightarrow a \times \overrightarrow  b= \vert \overrightarrow a \vert \vert \overrightarrow b \vert \cos θ$$</p><p>其中$θ$为$a,b$之间的夹角</p><p>坐标表示</p><p>$$ \overrightarrow a=(x1,y1) \overrightarrow  b=(x2,y2)$$</p><p>$$ \overrightarrow a \times  \overrightarrow b = x1 \times x2 + y1 \times y2;$$</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点积的应用"><a href="#点积的应用" class="headerlink" title="点积的应用"></a>点积的应用</h3><p>（1）判断两个向量是否垂直$ \overrightarrow a \bot \overrightarrow b \Leftarrow \Rightarrow \overrightarrow a \times \overrightarrow b=0 $</p><p>（2）求两个向量的夹角，点积$ \lt 0$为钝角，点积$\gt 0$为锐角</p><p>（3）求模长</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(dot(a, b) / len(a) / len(b));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="built_in">vector</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(a, a));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h3><p>与单位向量垂直的向量称为单位法向量</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span> <span class="title">normal</span><span class="params">(<span class="built_in">vector</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l = len(a);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span> (-a.y / l, a.x / l);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维叉积"><a href="#二维叉积" class="headerlink" title="二维叉积"></a>二维叉积</h3><p>两个向量的叉积是一个标量，$ \overrightarrow a \times  \overrightarrow b$的几何意义为他们所形成的平行四边形的有向面积</p><p>坐标表示$ \overrightarrow a=(x1,y1)  \overrightarrow b=(x2,y2)$</p><p>$$ \overrightarrow a \times  \overrightarrow b=x_1y_2-x_2y_1$$</p><p>Code :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观理解，假如b在a的左边，则有向面积为正，假如在右边则为负。假如b,a共线，则叉积为0,。</p><p>所以叉积可以用来<em>判断平行</em></p><h3 id="向量的旋转"><a href="#向量的旋转" class="headerlink" title="向量的旋转"></a>向量的旋转</h3><p>a=(x,y)可以看成是x<em>(1,0)+y1</em>(0,1)</p><p>分别旋转两个单位向量，则变成$x \times (\cosθ，\sinθ) + y_1 \times (-\sinθ，\cosθ)$</p><hr><h2 id="点、直线、线段的关系"><a href="#点、直线、线段的关系" class="headerlink" title="点、直线、线段的关系"></a>点、直线、线段的关系</h2><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>利用叉积求面积，然后除以平行四边形的底边长，得到平行四边形的高即点到直线的距离</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distl</span><span class="params">(point p, point a, point b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> v = p - a; <span class="built_in">vector</span> u = b - a;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(cross(v, u)) / len(u);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>比点到直线的距离稍微复杂。因为是线段，所以如果平行四边形的高在区域之外的话就不合理，这时候需要计算点到距离较近的端点的距离</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dists</span><span class="params">(point p, point a, point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> len(p - a);  </span><br><span class="line">    <span class="built_in">vector</span> v1 = b - a, v2 = p - a, v3 = p - b;  </span><br><span class="line">    <span class="keyword">if</span> (dcmp(dot(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> len(v2);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dcmp(dot(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> len(v3);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(cross(v1, v2)) / len(v1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断两线段相交"><a href="#判断两线段相交" class="headerlink" title="判断两线段相交"></a>判断两线段相交</h3><p>跨立实验:</p><p>判断一条线段的两端是否在另一条线段的两侧（两个端点与另一线段的叉积乘积为负）。<em>需要正反判断两侧</em>。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">segment</span><span class="params">(point a, point b, point c, point d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(b - a, c - a), c2 = cross(b - a, d - a);  </span><br><span class="line">    <span class="keyword">double</span> d1 = cross(d - c, a - c), d2 = cross(d - c, b - c);  </span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(d1) * dcmp(d2) &lt; <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求两直线的交点"><a href="#求两直线的交点" class="headerlink" title="求两直线的交点"></a>求两直线的交点</h3><p>有两种方法，比较常用的一种是用叉积的比值计算。但是这种方法的精度不是很高。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">point <span class="title">glt</span><span class="params">(point a, point a1, point b, point b1)</span>    </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> v = a1 - a; <span class="built_in">vector</span> w = b1 - b;    </span><br><span class="line">    <span class="built_in">vector</span> u = a - b;    </span><br><span class="line">    <span class="keyword">double</span> t = cross(w, u) / cross(v, w);    </span><br><span class="line">    <span class="keyword">return</span> a + v * t;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种比较麻烦，不常用但是精度相对较好:</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">point <span class="title">line_intersection</span><span class="params">(point a, point a0, point b, point b0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a1, b1, c1, a2, b2, c2;    </span><br><span class="line">    a1 = a.y - a0.y;    </span><br><span class="line">    b1 = a0.x - a.x;    </span><br><span class="line">    c1 = cross(a,a0);    </span><br><span class="line">    a2 = b.y - b0.y;    </span><br><span class="line">    b2 = b0.x - b.x;    </span><br><span class="line">    c2 = cross(b,b0);    </span><br><span class="line">    <span class="keyword">double</span> d = a1 * b2 - a2 * b1;    </span><br><span class="line">    <span class="keyword">return</span> point((b1 * c2 - b2 * c1) / d,(c1 * a2 - c2 * a1) / d);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断点在多边形内部"><a href="#判断点在多边形内部" class="headerlink" title="判断点在多边形内部"></a>判断点在多边形内部</h3><p>射线法：以该点为起点引一条射线，与多边形的边界相交<em>奇数次</em>，说明在多边形的内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pointin</span><span class="params">(point p, point* a, <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, k, d1, d2;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dcmp(dists(p, a[i], a[(i + <span class="number">1</span> - <span class="number">1</span>) % n + <span class="number">1</span>])) == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//判断点是否在多边形的边界上     </span></span><br><span class="line">        k = dcmp(cross(a[(i + <span class="number">1</span> - <span class="number">1</span>) % n + <span class="number">1</span>] - a[i], p - a[i]));    </span><br><span class="line">        d1 = dcmp(a[i].y - p.y);    </span><br><span class="line">        d2 = dcmp(a[(i + <span class="number">1</span> - <span class="number">1</span>) % n + <span class="number">1</span>].y - p.y);    </span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>)  wn++;    </span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>)  wn--;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (wn)  <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求多边形的重心"><a href="#求多边形的重心" class="headerlink" title="求多边形的重心"></a>求多边形的重心</h3><p>同样方法将多边形三角剖分</p><p>算出每个三角形的重心</p><p>套用质点组的重心公式即可</p><p>质点组重心公式 三个点$A,B,C$</p><p>$$ x = {m_a \times x_a + m_b \times x_b + m_c \times x_c \over m_a + m_b + m_c} $$</p><p>$$y={m_a \times y_a + m_b \times y_b+m_c \times y_c \over m_a + m_b + m_c} $$</p><p>$m$表示权，三角形的有向面积</p><hr><p>就写到这里了</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《Shq笔记》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 向量 </tag>
            
            <tag> 极角 </tag>
            
            <tag> 叉积 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MathJax常用用法</title>
      <link href="/articles/MathJax/"/>
      <url>/articles/MathJax/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Markdown中输入数学公式需要MathJax语法的支持</p><p>而本章就来介绍一下MathJax的一些常用用法</p><p><em>注: 本篇由于大量使用MathJax，渲染较慢</em></p><p>`<a id="more"></a></p><hr><h2 id="MathJax的位置"><a href="#MathJax的位置" class="headerlink" title="MathJax的位置"></a>MathJax的位置</h2><p>MathJax的位置有两种选择:</p><ul><li>在行内显示，如$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</li><li>在行外显示，如</li></ul><p>$$ \sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t $$</p><h3 id="行内显示"><a href="#行内显示" class="headerlink" title="行内显示"></a>行内显示</h3><p>代码: <code>$...code...$</code></p><blockquote><p><em>注意！</em></p><p>我们在<em>引用</em>内的MathJax也会被渲染!</p><p>$$ \sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t $$</p></blockquote><h3 id="行外显示"><a href="#行外显示" class="headerlink" title="行外显示"></a>行外显示</h3><p>代码：<code>$$...code...$$</code></p><hr><h2 id="字母修饰-上下标"><a href="#字母修饰-上下标" class="headerlink" title="字母修饰(上下标)"></a>字母修饰(上下标)</h2><p>上标：<code>a^b</code></p><blockquote><p>对于任意的互质的正整数a, b 都有$a ^ b =$</p><p>………</p></blockquote><p>下标： <code>a_b</code></p><blockquote><p>$$p = \sum_{i=1}^{n} a_i $$</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ p = \sum_&#123;i = 1&#125;^&#123;n&#125; a_i $$</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 对与上标和下标，只能包含<code>^</code>和<code>_</code>后的一个字符，要包含更多字符，要加<code>{}</code></p><hr><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><h3 id="大小关系"><a href="#大小关系" class="headerlink" title="大小关系"></a>大小关系</h3><p>$$\lt \; \gt \; \le \; \ge \; \neq$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\lt \gt \le \ge \neq</span><br></pre></td></tr></table></figure><h3 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h3><p>$$ \times \; \div \; \pm \; \mp \; \cdot \; $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\times \div \pm \mp \cdot</span><br></pre></td></tr></table></figure><h3 id="集合类符号"><a href="#集合类符号" class="headerlink" title="集合类符号"></a>集合类符号</h3><p>$$ \cup \; \cap \; \setminus \; \subset \; \subseteq \; \subsetneq \; \supset \; \in \; \notin \; \emptyset \; \varnothing \; $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing</span><br></pre></td></tr></table></figure><h3 id="向量-选择"><a href="#向量-选择" class="headerlink" title="向量 / 选择"></a>向量 / 选择</h3><p><code>{n+1 \choose 2k}</code> 或 <code>\binom{n+1}{2k}</code></p><p>$${n+1 \choose 2k} $$</p><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p>$$\to \; \rightarrow \; \leftarrow \; \Rightarrow \; \Leftarrow \; \mapsto$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto</span><br></pre></td></tr></table></figure><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><p> $$ a_1, a_2, \ldots ,a_n $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_1, a_2, \ldots ,a_n</span><br></pre></td></tr></table></figure><p>$$ a_1 + a_2 + \ldots + a_n $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_1 + a_2 + \ldots + a_n</span><br></pre></td></tr></table></figure><h3 id="取膜"><a href="#取膜" class="headerlink" title="取膜"></a>取膜</h3><p>$$a \equiv b \pmod n$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a \equiv b \pmod n</span><br></pre></td></tr></table></figure><h3 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h3><p>$$\land \; \lor \; \lnot \; \forall \; \exists \; \top \; \bot \; \vdash \; \vDash$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\land \lor \lnot \forall \exists \top \bot \vdash \vDash</span><br></pre></td></tr></table></figure><h3 id="一些其他符号"><a href="#一些其他符号" class="headerlink" title="一些其他符号"></a>一些其他符号</h3><p>$$\approx \; \sim \; \simeq \; \cong \; \equiv \; \prec \; \lhd$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\approx \sim \simeq \cong \equiv \prec \lhd</span><br></pre></td></tr></table></figure><hr><h2 id="分数-分式"><a href="#分数-分式" class="headerlink" title="分数 / 分式"></a>分数 / 分式</h2><p>我们可以使用 <code>\over</code>来进行渲染</p><p>栗子: $a \over b$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ a \over b $</span><br></pre></td></tr></table></figure><p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;$$</span><br></pre></td></tr></table></figure><hr><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>MathJax中加入空格不会改变表达式，如果想在表达式中加空格，根据空格的不同，可用<code>\, \; \quad \qquad</code>，如 </p><p>$$ ab \ ab \; ab \quad ab \qquad ab$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab \ ab \; ab \quad ab \qquad ab</span><br></pre></td></tr></table></figure><p>如果想加入一段文字，可用<code>\text{…}</code>，如</p><p>$${x \in s \mid x \text{ is extra large}}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&#123;x \in s \mid x \text&#123; is extra large&#125;\&#125;</span><br></pre></td></tr></table></figure><p>在<code>\text{…}</code>里面还可以嵌套<code>$…$</code></p><hr><h2 id="三角函数、极限和对数"><a href="#三角函数、极限和对数" class="headerlink" title="三角函数、极限和对数"></a>三角函数、极限和对数</h2><p>像 <code>lim</code>, <code>sin</code>, <code>max</code>, <code>ln</code>等符号，已包括在roman 字体中，用 <code>\lim</code>等即可，极限可用<code>\lim_{x\to 0}</code>来表示：</p><p>$$\lim_{x\to 0}$$</p><p>ln:</p><p>$$ \ln_a $$</p><p>max:</p><p>$$ \max(a,b) $$</p><hr><h2 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h2><p>$$\sqrt {x^3}$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt &#123;x^3&#125;</span><br></pre></td></tr></table></figure><p>$$ \sqrt[b \over c] {\frac x y + \sum_{i = 1}^n a_i} $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt[b \over c] &#123;\frac x y + \sum_&#123;i = 1&#125;^n a_i&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="微分-，-积分，-求和"><a href="#微分-，-积分，-求和" class="headerlink" title="微分 ， 积分， 求和.."></a>微分 ， 积分， 求和..</h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>$$ \sum_{i = 1}^n \sum_{j = 1}^n Data[i][j] + i \times j $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i = 1&#125;^n \sum_&#123;j = 1&#125;^n Data[i][j] + i \times j</span><br></pre></td></tr></table></figure><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>$$ \sum_{i = 1}^n \int_1^i f(x) $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sum_&#123;i = 1&#125;^n \int_1^i f(x)</span><br></pre></td></tr></table></figure><h3 id="连乘号"><a href="#连乘号" class="headerlink" title="连乘号"></a>连乘号</h3><p>$$ n \times \prod_{i = 1}^n \prod_{j = 1}^n a_{ij} $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n \times \prod_&#123;i = 1&#125;^n \prod_&#123;j = 1&#125;^n a_&#123;ij&#125;</span><br></pre></td></tr></table></figure><h3 id="多重积分"><a href="#多重积分" class="headerlink" title="多重积分"></a>多重积分</h3><p>$$ \iint f(x, y)dx\ dy \iiint f(x,y,z)dx\ dy\ dz $$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\iint f(x, y)dx\ dy \iiint f(x,y,z)dx\ dy\ dz</span><br></pre></td></tr></table></figure><p>另外，还有并集<code>\bigcup</code> 、交集<code>\bigcap</code>  等。</p><hr><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>小括号、方括号直接输，花括号要用 <code>\{</code> 和 <code>\}</code> </p><p><em>括号不会伸缩</em></p><p>$$(\frac{\sqrt x}{y^3})$$</p><p>如果需要伸缩，就需要用 <code>\left(…\right)</code> 来进行自动伸缩，如写 <code>\left(\frac{\sqrt x}{y^3}\right)</code> 得到</p><p>$$ \left(\frac{\sqrt x}{y^3}\right) $$</p><p><code>\left</code> 和 <code>\right</code> 的用法在这些中有用：三种括号，绝对值符号，范数符号 <code>\vert x \vert</code> ，<code>\Vert x \Vert</code>，尖角符号 <code>\langle</code> 和 <code>\rangle</code> ，向上下取整符号 <code>\lceil \rceil</code> 和 <code>\lfloor \rfloor</code>。</p><p>$$\vert x \vert \; \Vert x \Vert \; \langle x \rangle \; \lceil x \rceil \; \lfloor x \rfloor$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\vert x \vert \; \Vert x \Vert \; \langle x \rangle \; \lceil x \rceil \; \lfloor x \rfloor</span><br></pre></td></tr></table></figure><p>如果只需显示一半的符号，可以用 <code>.</code> 来表示另一边为空，如<code>\left. \frac 1 2 \right \rbrace</code> 就是 </p><p>$$\left. \frac 1 2 \right \rbrace$$</p><p>当然也可以手动调整括号的大小，如<code>\Biggl(\biggl(\Bigl(\bigl((num)\bigr)\Bigr)\biggr)\Biggr)</code> 会得到 </p><p>$$\Biggl(\biggl(\Bigl(\bigl((num)\bigr)\Bigr)\biggr)\Biggr)$$</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="blackboard-bold"><a href="#blackboard-bold" class="headerlink" title="blackboard bold"></a>blackboard bold</h3><p>用 <code>\mathbb</code> 或 <code>\Bbb</code> 选择<em>blackboard bold</em> 字体，如<code>\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \\ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz}</code>：</p><p>$$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz}$$</p><h3 id="boldface"><a href="#boldface" class="headerlink" title="boldface"></a>boldface</h3><p>用 <code>\mathbf</code> 选择 <em>boldface</em> 字体：</p><p>$$\mathbf {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz }$$</p><h3 id="typewriter"><a href="#typewriter" class="headerlink" title="typewriter"></a>typewriter</h3><p>用 <code>\mathtt</code> 选择 <em>typewriter</em> 字体：</p><p>$$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz }$$</p><h3 id="roman"><a href="#roman" class="headerlink" title="roman"></a>roman</h3><p>用 <code>\mathrm</code> 选择 <em>roman</em> 字体：</p><p>$$ \mathrm {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz } $$</p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>用 <code>\mathscr</code> 选择 <em>script</em> 字体：</p><p>$$\mathscr {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz }$$</p><h3 id="Fraktur"><a href="#Fraktur" class="headerlink" title="Fraktur"></a>Fraktur</h3><p>用 <code>\mathfrak</code> 选择 <em>Fraktur</em> 字体：</p><p>$$ \mathfrak {ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ \ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz } $$</p><p><br><center><strong><big>- - - -</big></strong></center></p><p>$$\mathfrak {Shq’s \; Blog}$$</p><p>未完待<em>续</em></p>]]></content>
      
      
        <tags>
            
            <tag> MathJax </tag>
            
            <tag> Blog </tag>
            
            <tag> Markdown </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>狄利克雷(Dirichle)卷积</title>
      <link href="/articles/Dirichle-product/"/>
      <url>/articles/Dirichle-product/</url>
      <content type="html"><![CDATA[<p>狄利克雷(Dirichle)卷积是一种十分玄学的算法，常常用在各种数论算法中</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先来看$ f, g $两个函数</p><p>定义$ f, g $两个函数的狄利克雷卷积$ ( \;  \ast \; ) $运算为：</p><p>$$ (f \ast g)(n) = \sum_{d | n} f(d) g(\frac n d) $$</p><hr><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>狄利克雷卷积的性质：</p><ul><li>交换律： $ f \ast g = g \ast f$</li><li>结合律： $(f \ast g) \ast h = f \ast (g \ast h)$</li><li>分配律： $f \ast (g + h) = f \ast g + f \ast h$</li><li>单位元： $f \ast e = e \ast f$</li><li>若$f, g$ 为积性函数，那么$f \ast g$也为积性函数</li></ul><hr><h2 id="常见卷积"><a href="#常见卷积" class="headerlink" title="常见卷积"></a>常见卷积</h2><p>常见的狄利克雷卷积：</p><ol><li>$$ d(n)=\sum_{d|n}1   \Rightarrow     d=1*1 $$ </li><li>$$ \sigma(n)=\sum_{d|n}d \Rightarrow \sigma=d*1 $$</li><li>$$ φ(n)=\sum_{d|n}\mu(d)\frac{n}{d} \Rightarrow  φ=\mu*Id $$</li></ol><hr><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>证明：</p><p>$$因为 \;  Id(n)=\sum_{i=1}^n\sum_{j=1}^n[gcd(i,n)==j]$$</p><p>$$则 \; Id(n)=\sum_{j|n}\sum_{i=1}^{\lfloor\frac{n}{j}\rfloor}[gcd(i,\frac{n}{j})==1]$$</p><p>$$那么 \; Id(n)=\sum_{j|n}φ(\frac{n}{j}) \Rightarrow Id=1*φ$$</p><p>$$根据反演可得 \; φ=\mu \ast Id$$</p><p>$$\epsilon(n)=\sum_{d|n}\mu(d) \Rightarrow \epsilon=\mu*1$$</p><hr><p>$$ 令k表示n的不同的质因子数，可得 \; \sum_{d|n}\mu(d)=\sum^k_{i=0}(-1)^i{k\choose i} $$</p><p>$$通过二项式展开可得 \; (x+y)^k=\sum^k_{i=0}x^iy^{k-i}{k\choose i}$$</p><p>$$将x=1,y=-1代入可得 \; \sum^k_{i=0}(-1)^i{k\choose i}=(1-1)^k=0^k$$</p><p>$$所以只有当k=0(即n=1)时，\; \sum_{d|n}\mu(d)=1，否则 \; \sum_{d|n}\mu(d)=0$$</p><p>$$所以 \; \epsilon(n)=\sum_{d|n}\mu(d)$$</p><hr><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ul><li>$i=1$, $i$是质数和 $i \% p[j] \neq 0$  的情况很好求</li><li>对于$i \% p[j] = 0$,可以通过分析增加一个最小质因子后的变化，或者直接考虑$f(pk)f(pk)$怎么求，反正积性函数不同质因子都是互质乘起来就行了不影响</li><li>也可以筛出最小质因子的次数，分解成$f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)$，对于$f(pk)f(pk)$考虑如何计算，带有约数和的可以考虑展开</li><li>一些非积性函数也可以通过分析函数的性质也可以用线性筛来求</li></ul><p>例：欧拉函数可以直接根据公式得到如何处理 </p><p>$$\varphi(n) = n\prod\frac{p_i-1}{p_i} = \prod{(p_i-1)*p_i^{e_i-1}}$$</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from: Mzwuzad's Blog</span></span><br><span class="line"><span class="comment">// 在求线性筛的同时求phi &amp;&amp; mu</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">bool</span> is_prime[N_MAX];</span><br><span class="line"><span class="keyword">int</span> phi[N_MAX], mu[N_MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="literal">false</span>, phi[<span class="number">1</span>] = <span class="number">1</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">p.push_back(i);</span><br><span class="line">phi[i] = i - <span class="number">1</span>;</span><br><span class="line">mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size() &amp;&amp; i * p[j] &lt;= n; j++) &#123;</span><br><span class="line">is_prime[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!(i % p[j])) &#123;</span><br><span class="line">phi[i * p[j]] = phi[i] * p[j];</span><br><span class="line">mu[i * p[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[i * p[j]] = phi[i] * (p[j] - <span class="number">1</span>);</span><br><span class="line">mu[i * p[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先写到这吧</p><p>$$\mathfrak {Shq’s \; Blog}$$</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 初等数论 </tag>
            
            <tag> 卷积 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 欧拉筛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「模板」一些树的模板</title>
      <link href="/articles/moban/"/>
      <url>/articles/moban/</url>
      <content type="html"><![CDATA[<p>这是是一些树型结构的模板</p><a id="more"></a><p>已江这些树封装在一个结构体中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt; r ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spaw</span><span class="params">(<span class="keyword">int</span> &amp;l, <span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    l ^= r ^= l ^= r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line">        <span class="keyword">int</span> fix, key, size;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> _key): fix(rand()) , key(_key) , left(<span class="literal">NULL</span>) , right(<span class="literal">NULL</span>) , size(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = <span class="number">1</span> + (left ? left-&gt;size : <span class="number">0</span>) + (right ? right-&gt;size : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Node *, Node *&gt; Droot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">Merge</span><span class="params">(Node *begin, Node *end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!begin) <span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">if</span> (!end)   <span class="keyword">return</span> begin;</span><br><span class="line">        <span class="keyword">if</span> (begin-&gt;fix &gt; end-&gt;fix) &#123;</span><br><span class="line">            end-&gt;left = Merge(begin, end-&gt;left);</span><br><span class="line">            end-&gt;update();</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin-&gt;fix &lt; end-&gt;fix) &#123;</span><br><span class="line">            begin-&gt;right = Merge(begin-&gt;right, end);</span><br><span class="line">            begin-&gt;update();</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Droot <span class="title">Split</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> Droot(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        Droot answer;</span><br><span class="line">        <span class="keyword">if</span> (Size(root-&gt;left) &gt;= k) &#123;</span><br><span class="line">            answer = Split(root-&gt;left, k);</span><br><span class="line">            root-&gt;left = answer.second;</span><br><span class="line">            root-&gt;update();</span><br><span class="line">            answer.second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Size(root-&gt;left) &lt; k) &#123;</span><br><span class="line">            answer = Split(root-&gt;right, k - Size(root-&gt;left) - <span class="number">1</span>);</span><br><span class="line">            root-&gt;right = answer.first;</span><br><span class="line">            root-&gt;update();</span><br><span class="line">            answer.first = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">Build</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Node *<span class="built_in">stack</span>[MAXN];</span><br><span class="line">        <span class="keyword">static</span> Node *node, *last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>[<span class="number">0</span>]; i++, cnt++) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node(<span class="built_in">array</span>[i]);</span><br><span class="line">            last = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span> (tot &amp;&amp; <span class="built_in">stack</span>[tot]-&gt;fix &gt; node-&gt;fix) &#123;</span><br><span class="line">                <span class="built_in">stack</span>[tot]-&gt;update();</span><br><span class="line">                last = <span class="built_in">stack</span>[tot];</span><br><span class="line">                <span class="built_in">stack</span>[tot--] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tot) <span class="built_in">stack</span>[tot]-&gt;right = node;</span><br><span class="line">            node-&gt;left = last;</span><br><span class="line">            <span class="built_in">stack</span>[++tot] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tot) <span class="built_in">stack</span>[tot--]-&gt;update();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[cnt];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Findkth</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Droot first = Split(root, num - <span class="number">1</span>);</span><br><span class="line">        Droot end   = Split(first.second, <span class="number">1</span>);</span><br><span class="line">        Node *ans = end.first;</span><br><span class="line">        root = Merge(Merge(first.first,ans), end.second);</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Getkth</span><span class="params">(Node *root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v &lt; root-&gt;key ? Getkth(root-&gt;left, v) : Getkth(root-&gt;right, v) + Size(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = Getkth(root,v);</span><br><span class="line">        Droot x = Split(root,k);</span><br><span class="line">        Node *n = <span class="keyword">new</span> Node(v);</span><br><span class="line">        root = Merge(Merge(x.first, n) , x.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Droot first = Split(root, k - <span class="number">1</span>);</span><br><span class="line">        Droot end   = Split(first.second, <span class="number">1</span>);</span><br><span class="line">        root=Merge(first.first, end.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> left, right, sum, tag;</span><br><span class="line">SegmentTree *lc, *rc;</span><br><span class="line">SegmentTree(<span class="keyword">int</span> left, <span class="keyword">int</span> right, SegmentTree *lc, SegmentTree *rc) : left(left), right(right), sum(<span class="number">0</span>), tag(<span class="number">0</span>), lc(lc), rc(rc) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SegmentTree *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> l == r ? <span class="keyword">new</span> SegmentTree(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>) : <span class="keyword">new</span> SegmentTree(l, r, build(l,mid), build(mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">sum += delta * (right - left + <span class="number">1</span>);</span><br><span class="line">tag += delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag)&#123;</span><br><span class="line">lc-&gt;cover(tag);</span><br><span class="line">rc-&gt;cover(tag);</span><br><span class="line">tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) cover(delta);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushDown();</span><br><span class="line">lc-&gt;modify(l, r, delta);</span><br><span class="line">rc-&gt;modify(l, r, delta);</span><br><span class="line">sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; right || r &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &lt;= left &amp;&amp; r &gt;= right) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> pushDown(), lc-&gt;query(l, r) + rc-&gt;query(l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="number">0</span>) root = <span class="literal">NULL</span>;</span><br><span class="line">        root = <span class="keyword">new</span> Node;</span><br><span class="line">        root-&gt;key = data;</span><br><span class="line">        root-&gt;left = build(root-&gt;left);</span><br><span class="line">        root-&gt;right = build(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepth</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(deepth(root-&gt;left), deepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cengxv</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node *&gt; Q;</span><br><span class="line">        Node *temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">            temp = Q.front(); Q.pop();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;key);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>)  Q.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>) Q.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SearchBinaryTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valueInsert</span><span class="params">(Node *root, Node *node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;key &gt; node-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> valueInsert(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;key &lt; node-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> valueInsert(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(Node* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node *node = <span class="keyword">new</span> Node;</span><br><span class="line">        node-&gt;key = key;</span><br><span class="line">        <span class="keyword">return</span> valueInsert(root, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Node *fa, *ch[<span class="number">2</span>], **root;</span><br><span class="line">        <span class="keyword">int</span> x, size, cnt;</span><br><span class="line"></span><br><span class="line">        Node(Node **root, Node *fa, <span class="keyword">int</span> x) : root(root), fa(fa), x(x), cnt(<span class="number">1</span>), size(<span class="number">1</span>) &#123;</span><br><span class="line">            ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;ch[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = cnt;</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">0</span>]) size += ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">1</span>]) size += ch[<span class="number">1</span>]-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node *old = fa;</span><br><span class="line">            <span class="keyword">int</span> r = relation();</span><br><span class="line"></span><br><span class="line">            fa = old-&gt;fa;</span><br><span class="line">            <span class="keyword">if</span> (old-&gt;fa) old-&gt;fa-&gt;ch[old-&gt;relation()] = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch[r ^ <span class="number">1</span>]) ch[r ^ <span class="number">1</span>]-&gt;fa = old;</span><br><span class="line">            old-&gt;ch[r] = ch[r ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            old-&gt;fa = <span class="keyword">this</span>;</span><br><span class="line">            ch[r ^ <span class="number">1</span>] = old;</span><br><span class="line"></span><br><span class="line">            old-&gt;maintain();</span><br><span class="line">            maintain();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fa == <span class="literal">NULL</span>) *root = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node *target = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (fa != target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fa-&gt;fa == target) &#123;</span><br><span class="line">                    rotate();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fa-&gt;relation() == relation()) &#123;</span><br><span class="line">                    fa-&gt;rotate();</span><br><span class="line">                    rotate();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rotate();</span><br><span class="line">                    rotate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node *<span class="title">pred</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node *v = ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (v-&gt;ch[<span class="number">1</span>]) v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node *<span class="title">succ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node *v = ch[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (v-&gt;ch[<span class="number">0</span>]) v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ch[<span class="number">0</span>] ? ch[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *root;</span><br><span class="line"></span><br><span class="line">    Splay() : root(<span class="literal">NULL</span>) &#123;</span><br><span class="line">        insert(INT_MAX);</span><br><span class="line">        insert(INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node **v = &amp;root, *fa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (*v != <span class="literal">NULL</span> &amp;&amp; (*v)-&gt;x != x)</span><br><span class="line">        &#123;</span><br><span class="line">            fa = *v;</span><br><span class="line">            fa-&gt;size++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &lt; fa-&gt;x) &#123;</span><br><span class="line">                v = &amp;fa-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = &amp;fa-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (*v)-&gt;cnt++;</span><br><span class="line">            (*v)-&gt;size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (*v) = <span class="keyword">new</span> Node(&amp;root, fa, x);</span><br><span class="line">        &#125;</span><br><span class="line">        (*v)-&gt;splay();</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (v != <span class="literal">NULL</span> &amp;&amp; v-&gt;x != x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; v-&gt;x) &#123;</span><br><span class="line">                v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v) v-&gt;splay();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        Node *pred = v-&gt;pred(), *succ = v-&gt;succ();</span><br><span class="line">        pred-&gt;splay();</span><br><span class="line">        succ-&gt;splay(pred);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            v-&gt;size--;</span><br><span class="line">            v-&gt;cnt--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> succ-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            succ-&gt;ch[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        succ-&gt;size--;</span><br><span class="line">        pred-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = find(x);</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span>;</span><br><span class="line">        erase(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = find(x);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v = insert(x);</span><br><span class="line">            <span class="keyword">int</span> res = v-&gt;pred()-&gt;x;</span><br><span class="line">            erase(v);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;pred()-&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = find(x);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v = insert(x);</span><br><span class="line">            <span class="keyword">int</span> res = v-&gt;succ()-&gt;x;</span><br><span class="line">            erase(v);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;succ()-&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = find(x);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v = insert(x);</span><br><span class="line">            <span class="keyword">int</span> res = v-&gt;rank();</span><br><span class="line">            erase(v);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;rank();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (!(k &gt;= v-&gt;rank() &amp;&amp; k &lt; v-&gt;rank() + v-&gt;cnt)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; v-&gt;rank()) &#123;</span><br><span class="line">                v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= v-&gt;rank() + v-&gt;cnt;</span><br><span class="line">                v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;splay();</span><br><span class="line">        <span class="keyword">return</span> v-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; splay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Relation &#123;</span><br><span class="line">        L = <span class="number">0</span>, R = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Node *child[<span class="number">2</span>], *parent, *pathParent;</span><br><span class="line">        T value, sum, max;</span><br><span class="line">        <span class="keyword">bool</span> reversed;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">const</span> T &amp;value) : reversed(<span class="literal">false</span>), value(value), sum(value), max(value), parent(<span class="literal">NULL</span>), pathParent(<span class="literal">NULL</span>) &#123;</span><br><span class="line">            child[L] = child[R] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Relation <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == parent-&gt;child[L] ? L : R;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (reversed) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(child[L], child[R]);</span><br><span class="line">                <span class="keyword">if</span> (child[L]) child[L]-&gt;reversed ^= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (child[R]) child[R]-&gt;reversed ^= <span class="number">1</span>;</span><br><span class="line">                reversed = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sum = value;</span><br><span class="line">            <span class="keyword">if</span> (child[L]) sum += child[L]-&gt;sum;</span><br><span class="line">            <span class="keyword">if</span> (child[R]) sum += child[R]-&gt;sum;</span><br><span class="line"></span><br><span class="line">            max = value;</span><br><span class="line">            <span class="keyword">if</span> (child[L]) max = <span class="built_in">std</span>::max(max, child[L]-&gt;max);</span><br><span class="line">            <span class="keyword">if</span> (child[R]) max = <span class="built_in">std</span>::max(max, child[R]-&gt;max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;parent) parent-&gt;parent-&gt;pushDown();</span><br><span class="line">            parent-&gt;pushDown(), pushDown();</span><br><span class="line">            <span class="built_in">std</span>::swap(pathParent, parent-&gt;pathParent);</span><br><span class="line"></span><br><span class="line">            Relation x = relation();</span><br><span class="line">            Node *oldParent = parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = <span class="keyword">this</span>;</span><br><span class="line">            parent = oldParent-&gt;parent;</span><br><span class="line"></span><br><span class="line">            oldParent-&gt;child[x] = child[x ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (child[x ^ <span class="number">1</span>]) child[x ^ <span class="number">1</span>]-&gt;parent = oldParent;</span><br><span class="line"></span><br><span class="line">            child[x ^ <span class="number">1</span>] = oldParent;</span><br><span class="line">            oldParent-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">            oldParent-&gt;maintain(), maintain();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!parent-&gt;parent) rotate();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown();</span><br><span class="line">                    <span class="keyword">if</span> (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate();</span><br><span class="line">                    <span class="keyword">else</span> rotate(), rotate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">evert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            access();</span><br><span class="line">            splay();</span><br><span class="line">            reversed ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">expose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            splay();</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (child[R]) &#123;</span><br><span class="line">                child[R]-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">                child[R]-&gt;pathParent = <span class="keyword">this</span>;</span><br><span class="line">                child[R] = <span class="literal">NULL</span>;</span><br><span class="line">                maintain();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">splice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            splay();</span><br><span class="line">            <span class="keyword">if</span> (!pathParent) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            pathParent-&gt;expose();</span><br><span class="line">            pathParent-&gt;child[R] = <span class="keyword">this</span>;</span><br><span class="line">            parent = pathParent;</span><br><span class="line">            pathParent = <span class="literal">NULL</span>;</span><br><span class="line">            parent-&gt;maintain();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            expose();</span><br><span class="line">            <span class="keyword">while</span> (splice());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> T &amp;<span class="title">querySum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            access();</span><br><span class="line">            splay();</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> T &amp;<span class="title">queryMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            access();</span><br><span class="line">            splay();</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *nodes[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> T &amp;value)</span> </span>&#123;</span><br><span class="line">        nodes[u - <span class="number">1</span>] = <span class="keyword">new</span> Node(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;evert();</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;pathParent = nodes[u - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;evert();</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;access();</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;splay();</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;pushDown();</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;child[L]-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;child[L] = <span class="literal">NULL</span>;</span><br><span class="line">        nodes[v - <span class="number">1</span>]-&gt;maintain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">querySum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;evert();</span><br><span class="line">        <span class="keyword">return</span> nodes[v - <span class="number">1</span>]-&gt;querySum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;evert();</span><br><span class="line">        <span class="keyword">return</span> nodes[v - <span class="number">1</span>]-&gt;queryMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> T &amp;value)</span> </span>&#123;</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;splay();</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;value = value;</span><br><span class="line">        nodes[u - <span class="number">1</span>]-&gt;maintain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> Treap </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> Splay </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Shq]等差数列?</title>
      <link href="/articles/question-01/"/>
      <url>/articles/question-01/</url>
      <content type="html"><![CDATA[<blockquote><p> Shq五难题之一</p></blockquote><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/aliayc.png" alt="img"></p><p>一日，大蒟蒻Shq在看dalao ycy的Blog的时候，发现ycy的Blog有个十分玄学的<del>Bug</del>特性，ycy特地江一篇文章中的数字变成这样</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Shq突发奇想，给出你一个首项为<code>A</code>, 公差为<code>P</code>的等差数列，江他们按照这样排成一行，求第n个数字是多少</p><hr><h2 id="输入-amp-amp-输出格式"><a href="#输入-amp-amp-输出格式" class="headerlink" title="输入&amp;&amp;输出格式"></a>输入&amp;&amp;输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共有两行<br>第一行有两个数，为<code>A</code>和<code>P</code>。<br>第二行有一个数，为<code>n</code></p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出所对应的数</p><h2 id="输入-amp-amp-输出样例"><a href="#输入-amp-amp-输出样例" class="headerlink" title="输入&amp;&amp;输出样例"></a>输入&amp;&amp;输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>0 &lt;= A &lt;= 10^5<br>-10^3 &lt;= P &lt;= 10^3<br>1 &lt;= n &lt;= 10^7</p>]]></content>
      
      <categories>
          
          <category> 《Shq出的题目》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题目 </tag>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sandaram筛法</title>
      <link href="/articles/Sandaram/"/>
      <url>/articles/Sandaram/</url>
      <content type="html"><![CDATA[<blockquote><p> 辛达拉姆筛法（Sandaram）是一种十分玄学的筛法</p></blockquote><a id="more"></a><!-- boy next door --><h2 id="常规判定方法"><a href="#常规判定方法" class="headerlink" title="常规判定方法"></a>常规判定方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">classic</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> half = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=half;i++)</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规的素数判定思想和实现都很easy，可是效率较低。如今存在不少更高效的素数判定方法，比方费马測试、<img src="http://latex.codecogs.com/gif.latex?\rho" alt="\rho">算法、数域筛法等。可是这些算法要么不精确要么须要的数学知识过于复杂，在此不做过多介绍。</p><p>以下我们介绍一种仅仅须要初等数学就可以明确的素数判定方法，<strong>该方法在不论什么情况下都会获得比常规方法好一倍的性能。</strong></p><h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><p>​       在介绍新方法之前。我们先回想一下埃氏筛法，这是一个与辗转相除法一样古老的算法。</p><p>​       大约在公元前3世纪，古希腊数学家埃拉托色尼提出了一种编造素数表的方法（如表一）。</p><p>这样的方法类似于筛东西，把不要的筛掉。把须要的留下。详细做法是：将从2到N的自然数，按顺序排列成2,3,4,5,…,N，然后留下第一个2。划去全部2的倍数；2之后没划去的第一个数是3。留下3，划去全部3的倍数；在3后面没划掉的第一个数是5，留下5，划去全部5的倍数。如此继续。直至上述一列数中再也没有可划的数为止，留下来的便是N以内的一切素数。</p><p><img src="http://img.blog.csdn.net/20140706205429343" alt="img"></p><p>表一 埃氏筛法</p><p>​       假设仅仅对一个整数进行素性判定，常规判定方法或者后面介绍的方法就足够了。</p><p>但假设要对很多整数进行素性判定，就须要採用埃氏筛法。</p><p>下面枚举算法摘自《挑战程序设计竞赛》一书：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回n以内的素数个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">prime[p++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辛达拉姆筛法"><a href="#辛达拉姆筛法" class="headerlink" title="辛达拉姆筛法"></a>辛达拉姆筛法</h2><p>​       公元1934年。一名年轻的东印度数学生辛达拉姆。提出了一种与埃拉托色尼迥然不同的筛法。它首先列出了一张表，如表二。表的第一行和第一列都是首项为4。公差为3的等差数列。从第二行开始。以后各行也是等差数列，公差分别为5,7,9,11,13……。能够看出，该表事实上是一个对称矩阵。</p><p>辛达拉姆指出：假设N出如今表中，则2N+1是合数。若N不在表中，则2N+1是素数。</p><p>证明相当精彩！</p><p><img src="http://img.blog.csdn.net/20140706205615265" alt="img"></p><p>先证明前半部分。</p><p>首先。他写出来第m行的第一个数：4+(m-1)×3=3m+1注意到该行是公差为2m+1的等差数列，所以此行第n列的数是：3m+1+(n-1)*(2m+1)=2mn+m+n即第m行n列的数是2mn+m+n。于是2N+1=4mn+2m+2n+1=(2m+1)(2n+1)是合数。</p><p>再证后半部分。要想正面证明2N+1是素数是相当困难的。假设换成等价的逆否命题，即证“若2N+1不是素数，则N必在表中”似乎要easy得多。</p><p>其实。若2N+1=x<em>y(x ,</em>y)*为整数则因2N+1为奇数，x、y也必为奇数。最好还是设： x=2p+1;y=2q+1从而2N+1=(2p+1)(2q+1)=4pq+2p+2q+1。由此能够得到 N=2pq+p+q。也即N是表中第p行第q列的数。</p><p>综上所述。我们证明了辛达拉姆筛法的正确性。比如18不在表中，则2*18+1=37为素数。</p><p>相反，71在表中，则2*71+1=143是合数。后半部分的证明是反证法的绝佳实例。</p><h2 id="基于辛达拉姆筛的素数推断"><a href="#基于辛达拉姆筛的素数推断" class="headerlink" title="基于辛达拉姆筛的素数推断"></a>基于辛达拉姆筛的素数推断</h2><p>​       有了辛达拉姆筛法，我们该怎样判定一个正整数n是否为素数呢？我们仅仅须要推断(n-1)/2是否在表中就可以。</p><p>因为须要判定的数肯定是奇数（偶数肯定都是合数）。所以(n-1)/2肯定能够整除。推断是否在表中，也即推断是否存在p和q使得2pq+p+q=(n-1)/2。</p><p>依照这个思路实现的代码例如以下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xindalamu</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> aa = (a - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> half = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">sqrt</span>(aa / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= half; i++)</span><br><span class="line">        <span class="keyword">if</span>((aa - i) % (<span class="number">2</span> * i + <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下详解一下上面的代码。首先推断用户输入是否是偶数。假设是直接返回false。然后将用户输入减一除以二赋值给aa，后面就须要推断aa是否在表中。推断的方法和常规推断的方法类似。也是须要验证某一行是否出现整除的情况，只是这里公式稍有不同。</p><p>从上述代码能够看到。在对aa开方的时候，我们将其除以二。</p><p>这是为什么呢？推断aa是否出如今表中，也即推断是否存在p和q使得2pq+p+q=aa。</p><p>这和常规方法中的推断aa=p*q稍有不同。忽略掉两个小项，我们须要推断2pq是否等于aa。也即pq是否等于aa/2，这就是除以2的原因。for循环从第一行開始检查。推断该行是否存在列满足2pq+p+q=aa。当行号固定之后。推断的方法是看aa-p是否整除2p+1（稍作变化就可以看出）。</p><p>我们分析一下基于辛达拉姆筛的素数判定复杂度。由for循环能够看出。复杂度也是O(根号n)。只是常系数比常规方法要小。这是由于，在求aa时有个除以二的操作，在开方时又有一个除以二的操作。所以相当于对a/4进行开方，因而最多仅仅须要对根号a/2的行进行推断。</p><p>而常规方法最多则须要验证根号n不同的因子。所以能够看出基于辛达拉姆筛的素数判定方法比常规方法快一倍。</p><p>​       可是，另一个疑问须要解决，假设用户输入的是一个合数，基于辛达拉姆筛的素数判定方法是否还优于常规判定方法。能够证明，<strong>无论输入的是合数还是素数，基于辛达拉姆筛的素数判定方法始终比常规方法快一倍。</strong>证明例如以下：</p><p>​       假设用户输入的是素数，在分析复杂度的时候已经证明。假设用户输入的是合数，则常规方法在遇到a的<strong>最小质因子b</strong>时返回，而辛达拉姆判定方法会在遍历到第(b-1)/2行时返回。假设a=b*y，由于a是合数，则肯定存在p行和q列使得2pq+p+q=(a-1)/2。变换得(2p+1)(2q+1)=a。由于辛达拉姆判定方法在遍历时是从第一行開始的，所以我们能够觉得b=2p+1，从而辛达拉姆判定方法在第(b-1)/2行时返回。这也就证明了当输入是合数（奇数）时，基于辛达拉姆筛的素数判定方法也比常规方法快一倍。</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性筛</title>
      <link href="/articles/Linear-sieve/"/>
      <url>/articles/Linear-sieve/</url>
      <content type="html"><![CDATA[<blockquote><p>求素数是程序设计比赛(NOIP, NOI, CTSC······)中经常遇到的问题</p></blockquote><a id="more"></a><p>求素数是程序设计比赛中经常遇到的问题，最基本的方法是通过素数的定义直接判断，只能被1和它本身整除的数就是素数了。这种方法适合判断单个数是否为素数，当要求一个范围内素数而这个范围又比较大时，这种方法就不太使用了，甚至程序要运行几分钟才能算出结果。</p><p>筛法的思想是去除要求范围内所有的合数，剩下的就是素数了，而任何合数都可以表示为素数的乘积，因此如果已知一个数为素数，则它的倍数都为合数。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000<span class="comment">//求MAX范围内的素数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> su[MAX], cnt;</span><br><span class="line"><span class="keyword">bool</span> isprime[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(isprime, <span class="number">1</span>, <span class="keyword">sizeof</span>(isprime));<span class="comment">//初始化认为所有数都为素数</span></span><br><span class="line">    isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//0和1不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i])<span class="comment">//保存素数</span></span><br><span class="line">            su[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = i * <span class="number">2</span>; j &lt;= MAX; j += i) &#123;<span class="comment">//素数的倍数都为合数</span></span><br><span class="line">            isprime[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, su[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样线性筛法虽然大大缩短了求素数的时间，但是实际上还是做了许多重复运算，比如2*3=6，在素数2的时候筛选了一遍，在素数为3时又筛选了一遍。如果只筛选小于等于素数i的素数与i的乘积，既不会造成重复筛选，又不会遗漏。时间复杂度几乎是线性的。</p><p><strong>优化后的线性筛法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000<span class="comment">//求MAX范围内的素数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> su[MAX], cnt;</span><br><span class="line"><span class="keyword">bool</span> isprime[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(isprime, <span class="number">1</span>, <span class="keyword">sizeof</span>(isprime));<span class="comment">//初始化认为所有数都为素数</span></span><br><span class="line">    isprime[<span class="number">0</span>] = isprime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//0和1不是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i]) su[cnt++] = i;<span class="comment">//保存素数i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>;j &lt; cnt &amp;&amp; su[j] * i &lt; MAX; j++) &#123;</span><br><span class="line">            isprime[su[j] * i] = <span class="number">0</span>;<span class="comment">//筛掉小于等于i的素数和i的积构成的合数</span></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, su[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「算法」Treap算法</title>
      <link href="/articles/treap/"/>
      <url>/articles/treap/</url>
      <content type="html"><![CDATA[<blockquote><p> Treap 算法是个简单易懂的算法</p></blockquote><a id="more"></a><p>在说Treap前，我们来先说下二叉堆</p><blockquote><p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。</p><p>最大堆：父结点的键值总是大于或等于任何一个子节点的键值；<br>最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</p></blockquote><p>图示:</p><p><img src="http://cfanz.cn/uploads/png/2013/07/10/14/YBc7YdK34D.png" alt="二叉堆"></p><p>如上图，这就是一个小根堆，所有非根节点的节点均小于这个节点的父亲。</p><p>简单介绍了堆，我们就开始看Treap</p><hr><p><code>Treap = Tree + Heap</code> </p><p>Treap是一棵拥有键值和优先级的树. </p><p>对于键值而言,   Treap是一棵排序二叉树<br>对于优先级而言,   Treap是堆.</p><h2 id="旋转Treap"><a href="#旋转Treap" class="headerlink" title="旋转Treap"></a>旋转Treap</h2><p>因为Treap既要满足键值排序二叉树结构,又要满足优先级的堆结构.<br>旋转的Treap是通过<strong>旋转</strong>来维护性质的, </p><p><img src="http://img.blog.csdn.net/20170105170607099?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGhlX3VzZWxlc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>如图所示,以右旋为例 </p><p>若x优先级比u高,当前子树不满足堆性质,要将x旋上去.<br>将x旋到u处成为当前子树根,将u旋下去成为x的右儿子,那么x原来的左儿子b就空出来了,将键值b作为u的左儿子,旋转完毕.</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_rotate</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_rotate</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = root;</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Treap中插入节点"><a href="#Treap中插入节点" class="headerlink" title="Treap中插入节点"></a>Treap中插入节点</h2><p>　　「节点的插入」是一个递归的过程，我们从根节点开始，逐个判断当前节点的值与插入值的大小关系。如果插入值小于当前节点值，则递归至左儿子；大于则递归至右儿子；</p><p>　　相等则直接在把当前节点数值的出现次数 +1 ，跳出循环即可。如果当前访问到了一个空节点，则初始化新节点，将其加入到 Treap 的当前位置。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valueInsert</span><span class="params">(Node* root, Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; node-&gt;key)&#123;</span><br><span class="line">        Flag = valueInsert(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;priority &gt; node-&gt;priority) Left_rotate(root);</span><br><span class="line">        <span class="keyword">return</span> Flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &lt; node-&gt;key)&#123;</span><br><span class="line">        Flag = valueInsert(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;priority &lt; node-&gt;priority) Right_rotate(root);</span><br><span class="line">        <span class="keyword">return</span> Flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真·插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(Node* root, <span class="keyword">int</span> key, <span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;priority = priority;</span><br><span class="line">    <span class="keyword">return</span> valueInsert(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Treap中删除节点"><a href="#Treap中删除节点" class="headerlink" title="Treap中删除节点"></a>Treap中删除节点</h2><p>　「节点的删除」同样是一个递归的过程，不过需要讨论多种情况： </p><ul><li><p>如果插入值小于当前节点值，则递归至左儿子；大于则递归至右儿子。 </p></li><li><p>如果插入值等于当前节点值： </p></li><li><p>若当前节点数值的出现次数大于 1 ，则减一; </p></li><li><p>若当前节点数值的出现次数等于于 1 : </p></li></ul><ol><li><p>若当前节点没有左儿子与右儿子，则直接删除该节点（置 0）； </p></li><li><p>若当前节点没有左儿子或右儿子，则将左儿子或右儿子替代该节点； </p></li><li><p>若当前节点有左儿子与右儿子，则不断旋转 当前节点，并走到当前节点新的对应位置，直到没有左儿子或右儿子为止。 </p></li></ol><p>时间复杂度均为 O(logn) 。 </p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Node* root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; key) <span class="keyword">return</span> remove(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key&lt; key) <span class="keyword">return</span> remove(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line">    Node* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left &amp;&amp; node-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left-&gt;priority &lt;= node-&gt;right-&gt;priority)&#123;</span><br><span class="line">            Right_rotate(node);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left-&gt;priority &gt; node-&gt;right-&gt;priority)&#123;</span><br><span class="line">            Left_rotate(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) node = node-&gt;right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span>) node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="求Treap的先续遍历"><a href="#求Treap的先续遍历" class="headerlink" title="求Treap的先续遍历"></a>求Treap的先续遍历</h2><p>这是树的基本操作</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求先续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_traverse</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123; <span class="comment">// 判断是否有root</span></span><br><span class="line">        in_order_traverse(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        in_order_traverse(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="求Treap的后续遍历"><a href="#求Treap的后续遍历" class="headerlink" title="求Treap的后续遍历"></a>求Treap的后续遍历</h2><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre_order_traverse</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        Pre_order_traverse(root-&gt;left);</span><br><span class="line">        Pre_order_traverse(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="求Treap的高度"><a href="#求Treap的高度" class="headerlink" title="求Treap的高度"></a>求Treap的高度</h2><p>Treap的高度，我们可以用递归来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth  = depth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> RightDepth = depth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftDepth &gt; RightDepth ? leftDepth + <span class="number">1</span> : RightDepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Treap是一个十分<em>简单易懂</em>的算法</p><p>总代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SMAX = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Left_rotate</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = root;</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Right_rotate</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = root;</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valueInsert</span><span class="params">(Node* root, Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; node-&gt;key)&#123;</span><br><span class="line">        Flag = valueInsert(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;priority &gt; node-&gt;priority) Left_rotate(root);</span><br><span class="line">        <span class="keyword">return</span> Flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &lt; node-&gt;key)&#123;</span><br><span class="line">        Flag = valueInsert(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;priority &lt; node-&gt;priority) Right_rotate(root);</span><br><span class="line">        <span class="keyword">return</span> Flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真·插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(Node* root, <span class="keyword">int</span> key, <span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;priority = priority;</span><br><span class="line">    <span class="keyword">return</span> valueInsert(root, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(Node* root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; key) <span class="keyword">return</span> remove(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key&lt; key) <span class="keyword">return</span> remove(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line">    Node* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left &amp;&amp; node-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left-&gt;priority &lt;= node-&gt;right-&gt;priority)&#123;</span><br><span class="line">            Right_rotate(node);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left-&gt;priority &gt; node-&gt;right-&gt;priority)&#123;</span><br><span class="line">            Left_rotate(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) node = node-&gt;right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span>) node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求先续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_traverse</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        in_order_traverse(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        in_order_traverse(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre_order_traverse</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">        Pre_order_traverse(root-&gt;left);</span><br><span class="line">        Pre_order_traverse(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth  = depth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> RightDepth = depth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftDepth &gt; RightDepth ? leftDepth + <span class="number">1</span> : RightDepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="function">Node* <span class="title">Search</span><span class="params">(Node* root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; key) <span class="keyword">return</span> Search(root-&gt;left,  key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &lt; key) <span class="keyword">return</span> Search(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求前驱 / 后继</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryInOrder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        queryInOrder(root-&gt;left);</span><br><span class="line">        ans.push_back(root-&gt;key);</span><br><span class="line">        queryInOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求前驱 / 后继</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Next</span><span class="params">(Node* root, <span class="keyword">int</span> num, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    ans.clear(); tot = <span class="number">0</span>;</span><br><span class="line">    queryInOrder(root);</span><br><span class="line">    <span class="keyword">return</span> ans[num + value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SlowRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">'-'</span> &amp;&amp; (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) data = (data &lt;&lt; <span class="number">1</span>) + (data &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> data * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> num = SlowRead(), kind;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">    <span class="keyword">while</span> (--num)&#123;</span><br><span class="line">        kind = SlowRead();</span><br><span class="line">        number = SlowRead();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">1</span>) Insert(root, number, rand()%SMAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">2</span>) remove(root, number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">3</span>) in_order_traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出前序排列</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">4</span>) Pre_order_traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定值的元素</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">5</span>) remove(Search(root, number), number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求前驱</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, Next(root, number, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求后继</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">7</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, Next(root, number, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求树的高度</span></span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">8</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, depth(root));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>(End)</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
            <tag> Treap </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Lemon」自动AC机</title>
      <link href="/articles/autoAC-lemon/"/>
      <url>/articles/autoAC-lemon/</url>
      <content type="html"><![CDATA[<blockquote><p>这是自动AC机不是AC自动机qwq               ———Shq</p></blockquote><a id="more"></a><p>自动AC机实现原理:</p><hr><ol><li>获取输入文件</li><li>检测是否为对应文件</li><li>在Lemon评测文件中取得答案</li><li>输出</li></ol><hr><p>明显，这样做是可以的</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lemon 自动AC机</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> in[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1,num2,id,n1,n2;</span><br><span class="line">    freopen(<span class="string">"****.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);   <span class="comment">//****为题目名称</span></span><br><span class="line">    freopen(<span class="string">"****.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n2);</span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(in,<span class="string">"..\\..\\data\\****\\****%d.in"</span>,i);</span><br><span class="line">        freopen(in,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;num1,&amp;num2);</span><br><span class="line">        <span class="keyword">if</span> (num1==n1&amp;&amp;num2==n2) &#123;id=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(in,<span class="string">"..\\..\\data\\****\\****%d.ans"</span>,id);</span><br><span class="line">    freopen(in,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化<del>毒瘤</del>版本:</p><p>-&gt;注意，这是直接再文件中复制到输出</p><p>各个平台拷贝命令:</p><ul><li>Windows: copy</li><li>Linux: cp</li><li>Mac: 什么?你给我说Mac?我就问，你见过评测机有多少是Mac的?</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __linux__  <span class="comment">// 自动识别Linux / Windows</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//#include&lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">//#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> f=__FILE__;<span class="keyword">int</span> n,l;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; p;</span><br><span class="line"><span class="built_in">vector</span>&lt;p&gt;v;<span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>*<span class="title">rread</span><span class="params">(<span class="keyword">int</span>&amp;r,<span class="keyword">char</span>*s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  r=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*s&lt;<span class="string">'0'</span>||*s&gt;<span class="string">'9'</span>)s--;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;*s&gt;=<span class="string">'0'</span>&amp;&amp;*s&lt;=<span class="string">'9'</span>;b*=<span class="number">10</span>,s--)</span><br><span class="line">    r+=b*(*s-<span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f=f.substr(<span class="number">0</span>,f.find_last_of(<span class="string">'.'</span>,f.length()));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">  DIR*dir=opendir((<span class="string">"../../data/"</span>+f).c_str());</span><br><span class="line">  dirent*ptr;</span><br><span class="line">  <span class="keyword">while</span>((ptr=readdir(dir))!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>((l=<span class="built_in">strlen</span>(ptr-&gt;d_name))&gt;<span class="number">3</span>&amp;&amp;</span><br><span class="line">       (<span class="built_in">string</span>(ptr-&gt;d_name).rfind(<span class="string">".out"</span>,l)==l<span class="number">-4</span>||</span><br><span class="line">        <span class="built_in">string</span>(ptr-&gt;d_name).rfind(<span class="string">".ans"</span>,l)==l<span class="number">-4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      rread(n,ptr-&gt;d_name+<span class="built_in">strlen</span>(ptr-&gt;d_name));</span><br><span class="line">      v.push_back(p(n,<span class="built_in">string</span>(ptr-&gt;d_name)));</span><br><span class="line">    &#125;</span><br><span class="line">  realpath(<span class="string">"."</span>,s);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  f=f.substr(f.find_last_of(<span class="string">'\\'</span>,f.length())+<span class="number">1</span>,f.length());</span><br><span class="line">  WIN32_FIND_DATA d;</span><br><span class="line">  HANDLE hFind=FindFirstFile((<span class="string">"..\\..\\data\\"</span>+f+<span class="string">"\\*"</span>).c_str(), &amp;d);</span><br><span class="line">  do if((l=strlen(d.cFileName))&gt;3&amp;&amp;</span><br><span class="line">       (<span class="built_in">string</span>(d.cFileName).rfind(<span class="string">".out"</span>,l)==l<span class="number">-4</span>||</span><br><span class="line">        <span class="built_in">string</span>(d.cFileName).rfind(<span class="string">".ans"</span>,l)==l<span class="number">-4</span>))&#123;</span><br><span class="line">    rread(n,d.cFileName+<span class="built_in">strlen</span>(d.cFileName));</span><br><span class="line">    v.push_back(p(n,<span class="built_in">string</span>(d.cFileName)));</span><br><span class="line">  &#125;<span class="keyword">while</span> (FindNextFile(hFind, &amp;d) != <span class="number">0</span>);</span><br><span class="line">  FindClose(hFind);</span><br><span class="line">  GetModuleFileName(<span class="literal">NULL</span>,s,<span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  rread(n,rread(l,s+<span class="built_in">strlen</span>(s)));</span><br><span class="line">  sort(v.begin(),v.end());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__ <span class="comment">// Linux / Windows的复制命令不一样</span></span></span><br><span class="line">  system((<span class="string">"cp -f ../../data/"</span>+f+<span class="string">'/'</span>+v[n].second+<span class="string">" "</span>+f+<span class="string">".out"</span>).c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  system((<span class="string">"copy ..\\..\\data\\"</span>+f+<span class="string">'\\'</span>+v[n].second+<span class="string">" "</span>+f+<span class="string">".out"</span>).c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>这是一篇有用的文章，不是吗?</p></blockquote>]]></content>
      
      <categories>
          
          <category> 「日常卡评测机」 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lemon </tag>
            
            <tag> 评测机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chtholly完形填空</title>
      <link href="/articles/P3933Chtholly/"/>
      <url>/articles/P3933Chtholly/</url>
      <content type="html"><![CDATA[<p>本题为Shq出的一道大水题</p><a id="more"></a><p>年轻的二等技官，妖精仓库的管理员，世界上最后一个人类——威廉·克梅修，数百年前曾经是一名准勇者，掌握着成为一名勇者所需要的所有知识。</p><p>大战在即，调整圣剑的状态成为了一项重要的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">瑟尼欧里斯（セニオリス）</span><br><span class="line">圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。</span><br><span class="line">拥有非常特殊的资质，只有极少一部分的人才能使用。</span><br><span class="line">由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。</span><br></pre></td></tr></table></figure><p>威廉需要调整圣剑的状态，因此他将瑟尼欧尼斯拆分护符，组成了一个nn 行mm 列的矩阵。</p><p>每一个护符都有自己的魔力值。现在为了测试圣剑，你需要将这些护符分成 A,B两部分。</p><p>要求如下：</p><ol><li>圣剑的所有护符，恰好都属于两部分中的一部分。</li><li>每个部分内部的方块之间，可以通过上下左右相互到达，而且每个内部的方块之间互相到达，最多允许拐一次弯。</li></ol><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ＡＡＡＡＡ　　ＡＡＡＡＡ　　ＡＡＡＡＡ</span><br><span class="line">ＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＡＡＢＢ</span><br><span class="line">ＡＢＢＢＡ　　ＢＢＡＡＡ　　ＡＡＡＢＢ</span><br><span class="line">ＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＢＢＢＢ</span><br><span class="line">ＡＡＡＡＡ　　ＡＡＡＡＡ　　ＢＢＢＢＢ</span><br><span class="line"></span><br><span class="line">　　(1)　　　　　(2)　　　　　(3)</span><br></pre></td></tr></table></figure><p>其中(1)(2)是不允许的分法，(3)是允许的分法。在(2)中，a属于A区域，这两个a元素之间互相到达，没有办法最多只拐一次弯。</p><p>现在要问，所有合法的分法中，A区域的极差与B区域的极差 中间较大的一个的 <strong>最小值</strong> 是多少？</p><p>好心而可爱的在一旁默默观察奈芙莲悄悄地告诉你，极差就是区域内最大值减去最小值。</p><p>夜晚的风吹拂着，68号岛上的景色竟与地上的森林无异。转念又想，黄金妖精本身就是与森林之中出现，成长，消亡的神秘存在啊。</p><p>时间不早了，早上训练中落败的珂朵莉即将回来了。您要尽快和威廉一起调整好圣剑，千万不能迟哟。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行两个自然数n,mn,m</p><p>接下来nn 行，每行mm 个自然数A_{i,j}Ai,j 表示权值</p><p>输出格式：</p><p>一个整数表示答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 12 6 11</span><br><span class="line">11 4 2 14</span><br><span class="line">10 1 9 20</span><br><span class="line">4 17 13 10</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>样例解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  12 6        11</span><br><span class="line">11 4  2        14</span><br><span class="line">10 1  9        20</span><br><span class="line">4        17 13 10</span><br></pre></td></tr></table></figure><p>分法不唯一，如图是一种合法的分法。左边部分极差12-1=11，右边一块极差20-10=10，所以答案取这两个中较大者11。没有别的分法，可以使答案更小。</p><p><strong>数据范围与约定</strong></p><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">n</th><th style="text-align:center">m</th></tr></thead><tbody><tr><td style="text-align:center">#1-2</td><td style="text-align:center">10≤10</td><td style="text-align:center">10≤10</td></tr><tr><td style="text-align:center">#3-4</td><td style="text-align:center">1</td><td style="text-align:center">2000≤2000</td></tr><tr><td style="text-align:center">#5-7</td><td style="text-align:center">≤200</td><td style="text-align:center">200≤200</td></tr><tr><td style="text-align:center">#8-10</td><td style="text-align:center">≤2000</td><td style="text-align:center">2000≤2000</td></tr></tbody></table><p>对于所有的权值$1\le A_{i,j} \le 10^9 , 1≤Ai,j≤10^9$</p><hr><p>对于这道题自然是很简单的，但是Shq认为这是锻炼你的代码能力的一道题，于是，就给你出成了补全对话模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;______&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_______&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf ___(2e9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nl ____</span></span><br><span class="line"><span class="meta">#defien ____</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ___,____;<span class="keyword">int</span> ______________=<span class="number">0</span>,_____________=inf;</span><br><span class="line"><span class="keyword">int</span> _________________[<span class="number">4</span>][<span class="number">2017</span>][<span class="number">2017</span>],_______________=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> __________________[<span class="number">2017</span>][<span class="number">2017</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ________(<span class="keyword">int</span> ___________________,<span class="keyword">int</span> ____________________)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=<span class="number">1</span>;_&lt;=___;_++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> __=<span class="number">1</span>;__&lt;=____;__++)</span><br><span class="line">            _________________[____________________][__][___-_ + <span class="number">1</span>]=_________________[___________________][_][__];</span><br><span class="line">    swap(____ ,___);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> _________(<span class="keyword">int</span> ________________)&#123;</span><br><span class="line">    <span class="keyword">int</span> ____________=____;</span><br><span class="line">    <span class="built_in">memset</span>(__________________,<span class="number">0</span>,<span class="keyword">sizeof</span>(__________________));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=<span class="number">1</span>;_&lt;=___;_++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> __=<span class="number">1</span>;__&lt;=____________;__++)</span><br><span class="line">            <span class="keyword">if</span>(_________________[_______________][_][__]+________________&lt;______________)&#123;</span><br><span class="line">                ____________=__<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> __________________[_][__] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=___;_; _--)</span><br><span class="line">        <span class="keyword">for</span>(___ __=____; __; __--)</span><br><span class="line">            <span class="keyword">if</span>(__________________[_][__])<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(_________________[_______________][_][__]-________________&gt;_____________)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ___________()&#123;swap(___,____);_______________=(_______________+<span class="number">1</span>)%<span class="number">4</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> __________(<span class="keyword">int</span> ________________)&#123;</span><br><span class="line">    <span class="keyword">if</span>(_________(________________)) <span class="keyword">return</span> <span class="literal">true</span>; ___________();</span><br><span class="line">    <span class="keyword">if</span>(_________(________________)) <span class="keyword">return</span> <span class="literal">true</span>; ___________();</span><br><span class="line">    <span class="keyword">if</span>(_________(________________)) <span class="keyword">return</span> <span class="literal">true</span>; ___________();</span><br><span class="line">    <span class="keyword">if</span>(_________(________________)) <span class="keyword">return</span> <span class="literal">true</span>; ___________();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ____</span></span><br><span class="line">    freopen(<span class="string">"______"</span>, <span class="string">"__"</span>, ____);</span><br><span class="line">    _______(<span class="string">"______"</span>, <span class="string">"__"</span>, ____);</span><br><span class="line">#_____</span><br><span class="line">    _____(<span class="string">"%d%d"</span>,&amp;___,&amp;____);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _=_;_&lt;=___;_++)<span class="keyword">for</span>(<span class="keyword">int</span> __=_;__&lt;=____;__++)&#123;</span><br><span class="line">        ______(<span class="string">"%d"</span>,&amp;_________________[<span class="number">0</span>][_][__]);</span><br><span class="line">        ______________=max(______________,_________________[<span class="number">0</span>][_][__]);</span><br><span class="line">        _____________=min(_____________,_________________[<span class="number">0</span>][_][__]);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ________(<span class="number">0</span>,<span class="number">1</span>);________(__,__);________(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> _____=<span class="number">0</span>,______=______________-_____________;</span><br><span class="line">    <span class="keyword">while</span>(_____&lt;______)&#123;</span><br><span class="line">        <span class="keyword">int</span> _______=_____+______ &gt;&gt; _;</span><br><span class="line">        <span class="keyword">if</span>(__________(_______))______=_______;</span><br><span class="line">        <span class="keyword">else</span> _____=_______+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"__"</span>,_____);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _______ end</span></span><br></pre></td></tr></table></figure><p>填完的各位dalao可以发到我的QQ上或者是邮箱哦</p>]]></content>
      
      <categories>
          
          <category> Shq出的大水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chtholly </tag>
            
            <tag> Problems </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 矩阵翻转 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>凸包「graham算法」</title>
      <link href="/articles/tubaomb/"/>
      <url>/articles/tubaomb/</url>
      <content type="html"><![CDATA[<blockquote><p> 凸包（Convex Hull）是一个计算几何（图形学）中的概念。</p></blockquote><p>在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的<strong>凸包</strong>。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造.</p><p>在二维欧几里得空间中，凸包可想象为一条刚好包着所有点的橡皮圈。</p><p>用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点。</p><a id="more"></a><p>凸包最常用的凸包算法是Graham扫描法和Jarvis步进法</p><p>Graham’s Scan法</p><p>这个算法是由数学大师葛立恒（Graham）发明的，他曾经是美国数学学会（AMS）主席、AT&amp;T首席科学家以及国际杂技师协会（IJA）主席。</p><p><strong>问题</strong></p><p>给定平面上的二维点集，求解其凸包。</p><p><strong>过程</strong></p><p><img src="http://img.blog.csdn.net/20150530151346608" alt="img"></p><ol><li><p>把所有点放在二维坐标系中，则纵坐标最小的点一定是凸包上的点，如图中的P0。</p></li><li><p>把所有点的坐标平移一下，使 P0 作为原点，如上图。</p></li><li><p>计算各个点相对于 P0 的幅角 α ，按从小到大的顺序对各个点排序。当 α 相同时，距离 P0 比较近的排在前面。例如上图得到的结果为 P1，P2，P3，P4，P5，P6，P7，P8。我们由几何知识可以知道，结果中第一个点 P1 和最后一个点 P8 一定是凸包上的点。 </p></li></ol><p>——（以上是准备步骤，以下开始求凸包）——- </p><p>   以上，我们已经知道了凸包上的第一个点 P0 和第二个点 P1，我们把它们放在栈里面。现在从步骤3求得的那个结果里，把 P1 后面的那个点拿出来做当前点，即 P2 。接下来开始找第三个点：</p><ol start="4"><li><p>连接P0和栈顶的那个点，得到直线 L 。看当前点是在直线 L 的右边还是左边。如果在直线的右边就执行步骤5；如果在直线上，或者在直线的左边就执行步骤6。</p></li><li><p>如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤4。</p></li><li><p>当前点是凸包上的点，把它压入栈，执行步骤7。</p></li><li><p>检查当前的点 P2 是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把 P2 后面那个点做当前点，返回步骤4。</p></li></ol><p>动态求解：</p><p><img src="http://img.blog.csdn.net/20150530145453912" alt="动态求解"></p><hr><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　文件锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议不加using namespace std;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pointNum;</span><br><span class="line"><span class="keyword">int</span> lowestIndex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point points[MAXN];</span><br><span class="line">Point lowestPoint;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Point&gt; pointStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//听说手写max,min,spaw 运行速度会加快</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spaw</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;a ^= b ^= a ^= b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i &gt; j ? i : j;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i &lt; j ? i : j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Assignment</span><span class="params">(Point from, Point to)</span></span>&#123;</span><br><span class="line">    from.x = to.x;</span><br><span class="line">    from.y = to.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkNeedToSwap</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x1 - lowestPoint.x)*(y2 - lowestPoint.y) - (x2 - lowestPoint.x)*(y1 - lowestPoint.y) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pointNum; i++)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = pointNum - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (checkNeedToSwap(points[j].x, points[j].y, points[j - <span class="number">1</span>].x, points[j - <span class="number">1</span>].y))&#123;</span><br><span class="line">                tmp[<span class="number">0</span>] = points[j - <span class="number">1</span>].x;</span><br><span class="line">                tmp[<span class="number">1</span>] = points[j - <span class="number">1</span>].y;</span><br><span class="line">                Assignment(points[j - <span class="number">1</span>], points[j]);</span><br><span class="line">                points[j].x = tmp[<span class="number">0</span>];</span><br><span class="line">                points[j].y = tmp[<span class="number">1</span>];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法本体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graham</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">3</span>;</span><br><span class="line">    pointStack.push(points[<span class="number">0</span>]);</span><br><span class="line">    pointStack.push(points[<span class="number">1</span>]);</span><br><span class="line">    pointStack.push(points[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; pointNum)&#123;</span><br><span class="line">        Point point2 = pointStack.top();</span><br><span class="line">        pointStack.pop();</span><br><span class="line">        Point point1 = pointStack.top();</span><br><span class="line">        Point point3 = points[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Debug</span></span><br><span class="line"><span class="comment">         * cout &lt;&lt; "p1(" &lt;&lt; point1.x &lt;&lt; " " &lt;&lt; point1.y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         * cout &lt;&lt; "p2(" &lt;&lt; point2.x &lt;&lt; " " &lt;&lt; point2.y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         * cout &lt;&lt; "p3(" &lt;&lt; point3.x &lt;&lt; " " &lt;&lt; point3.y &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = (point3.x - point1.x)*(point2.y - point1.y) - (point2.x - point1.x)*(point3.y - point1.y);</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            point2 = point1;</span><br><span class="line">            pointStack.pop();</span><br><span class="line">            point1 = pointStack.top();</span><br><span class="line">            tmp = (point3.x - point1.x)*(point2.y - point1.y) - (point2.x - point1.x)*(point3.y - point1.y);</span><br><span class="line">        &#125;</span><br><span class="line">        pointStack.push(point2);</span><br><span class="line">        pointStack.push(point3);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SlowPrint</span><span class="params">(<span class="keyword">int</span> test)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PrintAnswer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt;::reverse_iterator iter=vec.rbegin(); iter!=vec.rend(); iter++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter-&gt;x &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCK</span></span><br><span class="line">    freopen (<span class="string">"test.in"</span> , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        lowestPoint.x = INT_MAX;</span><br><span class="line">        lowestPoint.y = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; pointNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; points[i].x &gt;&gt; points[i].y;</span><br><span class="line">            <span class="comment">//find the lowest point</span></span><br><span class="line">            <span class="keyword">if</span> (lowestPoint.y &gt; points[i].y || (lowestPoint.y == points[i].y &amp;&amp; lowestPoint.x &gt; points[i].x))&#123;</span><br><span class="line">                Assignment (lowestPoint, points[i]);</span><br><span class="line">                lowestIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  swap lowestPoint to first place.</span></span><br><span class="line"><span class="comment">         *  points[lowestIndex].x = points[0].x;</span></span><br><span class="line"><span class="comment">         *  points[lowestIndex].y = points[0].y;</span></span><br><span class="line"><span class="comment">         *  points[0].x = lowestPoint.x;</span></span><br><span class="line"><span class="comment">         *  points[0].y = lowestPoint.y;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assignment (points[lowestIndex], points[<span class="number">0</span>]);</span><br><span class="line">        Assignment (points[<span class="number">0</span>], lowestPoint);</span><br><span class="line"></span><br><span class="line">        sortPoints();</span><br><span class="line"></span><br><span class="line">        graham();</span><br><span class="line"></span><br><span class="line">        SlowPrint (T + <span class="number">1</span>);</span><br><span class="line">        SlowPrint (pointStack.size());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (!pointStack.empty()) &#123;</span><br><span class="line">            Point p = pointStack.top();</span><br><span class="line">            vec.push_back(p);</span><br><span class="line">            pointStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        PrintAnswer(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 凸包 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「题解」多段线(polyline)</title>
      <link href="/articles/test-polyline/"/>
      <url>/articles/test-polyline/</url>
      <content type="html"><![CDATA[<blockquote><h2 id="多段线-polyline"><a href="#多段线-polyline" class="headerlink" title="多段线(polyline)"></a>多段线(polyline)</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/test.png" alt="题面"></p></blockquote><a id="more"></a><blockquote><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>从文件<code>polyline . in</code>中读入数据。<br>输入第一行包含一个正整数 ,表示函数个数。<br>接下来<code>n</code> 行 , 每行包含两个正整数<code>ki , bi</code>,表示第<code>i</code>个函数的参数。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出到文件<code>portal . out</code>中。<br>输出一行一个正整数,表示形成的多段线的图像中不等于180度角的个数</p><h3 id="【样例-输入】"><a href="#【样例-输入】" class="headerlink" title="【样例 输入】"></a>【样例 输入】</h3><p>1<br>1<br>1 0</p><h3 id="【样例-输出】"><a href="#【样例-输出】" class="headerlink" title="【样例 输出】"></a>【样例 输出】</h3><p>1<br>1</p><h3 id="【样例-输入】-1"><a href="#【样例-输入】-1" class="headerlink" title="【样例 输入】"></a>【样例 输入】</h3><p>3<br>-2 -4<br>1 7<br>-5 1</p><h3 id="【样例-输出】-1"><a href="#【样例-输出】-1" class="headerlink" title="【样例 输出】"></a>【样例 输出】</h3><p>3</p><h3 id="【提示】"><a href="#【提示】" class="headerlink" title="【提示】"></a>【提示】</h3><p>函数相关参见高中数学必修 。(看了也没用)<br>请认真阅读【数据规模及约定】。</p><h3 id="【数据规模及约定】"><a href="#【数据规模及约定】" class="headerlink" title="【数据规模及约定】"></a>【数据规模及约定】</h3><p>保证对于所有数据有:<br>$n ≤ 100000, −1000000000 ≤ k i , b i ≤ 1000000000$</p><p><strong>本题评测时将开启 O2 优化。</strong></p></blockquote><p>注意，本题中函数&lt;=180度的角就是函数的拐点，也就是说，就是让你求函数的拐点</p><p>那么，我们来研究下样例：</p><p>对于样例一就很明显了，我们就研究下最后一个样例</p><p>我们看下图像：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/Data_xy/1.png" alt="图像"></p><p>现在，我们计算一下s(x)的值</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/Data_xy/2.png" alt="s(x)"></p><p>这就是s(x)的值．明显的，这个函数有3个拐点（一个在<code>x=7</code>的地方，不容易看出来）</p><p>我们就来研究一下这几个函数的关系：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/Data_xy/3.png" alt="all"></p><p>上图就显示了所有函数．</p><p>我们可以计算这些函数的零点（与x轴交点）来判断有多少个拐点</p><blockquote><p>各个分函数<strong>不同的</strong>零点数就是总函数的拐点数</p></blockquote><p>思路明白了，代码就好写了</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> lb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Data_k;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Data_b;</span><br><span class="line">lb withx[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ki, bi;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;ki, &amp;bi);</span><br><span class="line">        <span class="keyword">if</span>(ki != <span class="number">0</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            Data_k.push_back(ki); Data_b.push_back(bi);</span><br><span class="line">            <span class="comment">//求出与函数零点</span></span><br><span class="line">            withx[cnt] = -(lb)Data_b[cnt] / (lb)Data_k[cnt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCK</span></span><br><span class="line">    freopen (<span class="string">"polyline.in"</span> , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"polyline.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">    init();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">std</span>::sort(withx + <span class="number">1</span>,withx + <span class="number">1</span> + number);</span><br><span class="line">    <span class="keyword">int</span> Answer = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">if</span>(withx[i] - withx[i - <span class="number">1</span>] &lt;= <span class="number">1e-18</span>) Answer--;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, Answer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wonderful end</span></span><br></pre></td></tr></table></figure><hr><p>最后给下函数解析式</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/lyyztest/Data_xy/Data.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「题解」众数(mode)</title>
      <link href="/articles/test-mode/"/>
      <url>/articles/test-mode/</url>
      <content type="html"><![CDATA[<p>这是一道十分<strong><del>水</del></strong>锻炼思维的题目</p><blockquote><h2 id="众数-mode"><a href="#众数-mode" class="headerlink" title="众数(mode)"></a>众数(mode)</h2><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个包含n个数的数列,其中某个数出现了超过 n/2 次即众数,请你找出那个数。</p></blockquote><a id="more"></a><blockquote><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>从文件mode . in中读入数据。 输入第一行包含一个正整数n ,表示数列中数的个数。 接下来一行包含n个正整<br>数,分别表示数列中的每个数。</p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>输出到文件mode . out中。 输出一行一个正整数,为数列中的众数。</p><h3 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h3><p>5<br>3 2 3 1 3</p><h3 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h3><p>3</p><h3 id="【提示】"><a href="#【提示】" class="headerlink" title="【提示】"></a>【提示】</h3><p>请注意本题空间限制!</p><h3 id="【数据规模及约定】"><a href="#【数据规模及约定】" class="headerlink" title="【数据规模及约定】"></a>【数据规模及约定】</h3><p>保证对于所有数据有:<br>n ≤ 500000, 0 ≤ a i ≤ 9223372036854775807<br><del>切勿弃疗!</del></p></blockquote><p>如果不看空间，那么这道题就是十分水的一道题目</p><p>但是，我们看到空间<code>1MB</code>的时候就会发现，我们其实连数组都没地方开，只有<code>1MB</code>的空间，也就是说我们只能开几个int了233</p><p>那么，我们就只能使用这三四个变量来去进行我们的算法了</p><p>这里我就推荐一种十分神奇的方法： <del>暴力</del>抵消法</p><blockquote><p>抵消法 是一个 <del>法师套牌</del> 十分有效的办法，实现简单，<del>造假低廉</del>．</p></blockquote><p>我们注意到，题目中给出了＂超过 n/2 次＂ 这个条件, 那么我们可以设一个变量tag(1)，当现在输入的x与记录的x不同时,tag = tag - 1, 当相同时，tag = tag + 1．当tag &lt;= 1时，江x更新为现在输入的x．</p><p>显然这个算法是显然成立的</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件锁，可以编译时带参数编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"></span><br><span class="line">ui number;</span><br><span class="line">ui x = <span class="number">0</span>, tag = <span class="number">1</span>, data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ui i = <span class="number">1</span>; i &lt;= number; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span><br><span class="line">        tag += data == x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag &lt;= <span class="number">1</span>) x = data, tag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCK</span></span><br><span class="line">    freopen (<span class="string">"mode.in"</span> , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"mode.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wonderful end</span></span><br></pre></td></tr></table></figure><hr><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="350" height="86" src="//music.163.com/outchain/player?type=2&id=32358448&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 题解 </tag>
            
            <tag> Problem </tag>
            
            <tag> 优化 </tag>
            
            <tag> 测试题 </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[P2018]消息传递</title>
      <link href="/articles/P2018/"/>
      <url>/articles/P2018/</url>
      <content type="html"><![CDATA[<p>今年是2018年，我就去Luogu上刷了一道代号为2018的水题.</p><p>然而这道题是道大水题，用树上DP完美解决</p><a id="more"></a><p>思路:</p><p>枚举第一个放的位置，dfs递归处理出当前节点u的子节点v需要的传递时间，然后从大到小排序，对于传递时间长的节点，就先传递给它。</p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mxn=<span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; f[mxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,maxx;</span><br><span class="line"><span class="keyword">int</span> ans[mxn],dp[mxn],du[mxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 听说手写min,max会跑的快</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &lt; b ? a : b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa &amp;&amp; du[u]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp[mxn],cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;f[u].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=f[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        tmp[++cnt]=dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(tmp+<span class="number">1</span>,tmp+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) dp[u]=max(dp[u],tmp[i]+cnt-i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        f[x].push_back(i);</span><br><span class="line">        f[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dfs(i,<span class="number">0</span>);</span><br><span class="line">        ans[i]=dp[i];</span><br><span class="line">        maxx = (i == <span class="number">1</span>) ? dp[i] : maxx;</span><br><span class="line">        maxx=min(maxx,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxx+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==maxx) <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完美结束</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Problem </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DP </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>联通分量&amp;&amp;Tarjian算法</title>
      <link href="/articles/scc1/"/>
      <url>/articles/scc1/</url>
      <content type="html"><![CDATA[<p>子图（subgraph）</p><ul><li>图G=(V，E)，G’=(V’，E’)中，若V’    V，E’     E，并且E’中的边所关联的顶点都在V’中，则称图G’是图G的子图</li></ul><a id="more"></a><p>强连通性:</p><ul><li>对有向图G=(V,E)而言，若对于G中任意两个顶点Vi和Vj（Vi≠Vj ），都有一条从Vi到Vj的（有向路径），同时还有一条从Vj到Vi的(有向)路径，则称有向图G是强连通的</li></ul><p>强联通分量:</p><ul><li>有向图强连通的<strong>极大子图</strong></li></ul><hr><h2 id="Tarjian算法"><a href="#Tarjian算法" class="headerlink" title="Tarjian算法"></a>Tarjian算法</h2><p>Tarjan算法用于求<strong>有向图强连通分量</strong></p><p>当然，这个算法是非常实用的算法，<del>你也可以叫他什么塔尖算法，铊剑算法之类的233</del></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>其过程主要如下：做一遍DFS，用dfn[i]表示编号为i的节点在DFS过程中的访问序号(也可以叫做开始时间）</li><li>用low[i]表示i节点DFS过程中i的下方节点所能到达的开始时间最早的节点的开始时间。</li><li>初始时dfn[i]=low[i]在DFS过程中会形成一搜索树。在搜索树上越先遍历到的节点，显然dfn的值就越小。DFS过程中，碰到哪个节点，就将哪个节点入栈。</li><li>栈中节点只有在其所属的强连通分量已经全部求出时，才会出栈。</li><li>如果发现某节点u有边连到搜索树中栈里的节点v，则更新u的low 值为dfn[v](更新为low[v]也可以）。</li><li>如果一个节点u已经DFS访问结束，而且此时其low值等于dfn值，则说明u可达的所有节点，都不能到达任何在u之前被DFS访问的节点，那么该节点u就是一个强连通分量在DFS搜索树中的根。</li><li>此时将栈中所有节点弹出，包括u,就找到了一个强连通分量</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><del>自己写</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">By - lyd</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(u)</span> </span>&#123;</span><br><span class="line">dfn[u]=low[u]=++index</span><br><span class="line"><span class="built_in">stack</span>.push(u)</span><br><span class="line"><span class="keyword">for</span> each (u, v) in E &#123;</span><br><span class="line"><span class="keyword">if</span> (v is <span class="keyword">not</span> visted) &#123;</span><br><span class="line">tarjan(v) </span><br><span class="line">low[u] = min(low[u], low[v]) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (v in <span class="built_in">stack</span>) &#123;</span><br><span class="line">low[u] = min(low[u], dfn[v]) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123; <span class="comment">//u是一个强连通分量的根</span></span><br><span class="line">repeat </span><br><span class="line">v = <span class="built_in">stack</span>.pop </span><br><span class="line">print v </span><br><span class="line">until (u== v) </span><br><span class="line">&#125; <span class="comment">//退栈，把整个强连通分量都弹出来</span></span><br><span class="line">&#125; <span class="comment">//复杂度是O(E+V)的</span></span><br><span class="line"><span class="comment">// 完美结束</span></span><br></pre></td></tr></table></figure><hr><h2 id="双联通分量"><a href="#双联通分量" class="headerlink" title="双联通分量"></a>双联通分量</h2><h3 id="无向图的割点与桥"><a href="#无向图的割点与桥" class="headerlink" title="无向图的割点与桥"></a>无向图的割点与桥</h3><p>无向连通图中，如果删除某点后，图变成不连通，则称该点为割点。<br>无向连通图中，如果删除某边后，图变成不连通，则称该边为桥。</p><h3 id="双联通分量-1"><a href="#双联通分量-1" class="headerlink" title="双联通分量"></a>双联通分量</h3><p>如果一个连通图，如果任意两点至少存在两条“点不重复”的路径，则说明这个图是点-双联通的，同时这个条件等价于任意两条边都在同一个简单环内，图内无割点（简称双连通）点双连通分量——一个图点-双联通的极大联通子图如果任意两点至少存在两条“边不重复”的路径，我们认为这个图是边-双联通的，即每条边都在一个简单环内，所有边都不是桥边双联通分量——一个图边-双联通的极大联通子图</p><h3 id="边双连通"><a href="#边双连通" class="headerlink" title="边双连通"></a>边双连通</h3><p>只需在求出所有的桥以后，把桥边删除，原图变成了多个连通块，则每个连通块就是一个边双连通分支。桥不属于任何一个边双连通分支，其余的边和每个顶点都属于且只属于一个边双连通分支。</p><hr><h2 id="Tarjan-求割点与桥"><a href="#Tarjan-求割点与桥" class="headerlink" title="Tarjan 求割点与桥"></a>Tarjan 求割点与桥</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和有向图求强连通分量类似</p><p>在深度优先遍历整个图过程中形成的一棵搜索树    </p><p> 一个顶点u是割点，当且仅当满足以下两个条件之一 </p><pre><code>1. u为树根，且u有多于一个子树。2. u不为树根，且满足存在(u,v)为树枝边(或称父子边，即u为v在搜索树中的父亲)，使得dfn(u)&lt;=low(v).</code></pre><p>一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足dfn(u)&lt;low(v)（前提是其没有重边）。</p><p>low[u]为u与u的子树中能够通过非父子边追溯到的最早节点的DFS序</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">low[u] = dfn[u] = nTime ++;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; G[u].size() ;i ++ ) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span>( ! dfn[v]) &#123; <span class="comment">//v没有访问过</span></span><br><span class="line"><span class="comment">//树边要入栈</span></span><br><span class="line">Edges.push_back(Edge2(u,v));</span><br><span class="line">Tarjan(v,u);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line"><span class="function">Edge2 <span class="title">tmp</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(dfn[u] &lt;= low[v]) &#123; </span><br><span class="line"><span class="comment">//从一条边往下走，走完后发现自己是割点，则栈中的边一定全是和自己在一个双连通分量里面</span></span><br><span class="line">        <span class="comment">//根节点总是和其下的某些点在同一个双连通分量里面</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Block No: "</span> &lt;&lt; ++ nBlockNo &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="Tarjian求双联通分量"><a href="#Tarjian求双联通分量" class="headerlink" title="Tarjian求双联通分量"></a>Tarjian求双联通分量</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//by - lyd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">low[u] = dfn[u] = nTime ++;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; G[u].size() ;i ++ ) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span>( ! dfn[v]) &#123; <span class="comment">//v没有访问过</span></span><br><span class="line"><span class="comment">//树边要入栈</span></span><br><span class="line">Edges.push_back(Edge2(u,v));</span><br><span class="line">Tarjan(v,u);</span><br><span class="line">low[u] = min(low[u],low[v]);</span><br><span class="line"><span class="function">Edge2 <span class="title">tmp</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(dfn[u] &lt;= low[v]) &#123; </span><br><span class="line"><span class="comment">//从一条边往下走，走完后发现自己是割点，则栈中的边一定全是和自己在一个双连通分量里面</span></span><br><span class="line">        <span class="comment">//根节点总是和其下的某些点在同一个双连通分量里面</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Block No: "</span> &lt;&lt; ++ nBlockNo &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tmp = Edges.back();</span><br><span class="line">Edges.pop_back ();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp.u &lt;&lt; <span class="string">","</span> &lt;&lt;</span><br><span class="line"> tmp.v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">while</span> ( ! (tmp.u == u &amp;&amp; tmp.v == v) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// 对应if( ! dfn[v]) &#123;</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( v != father ) &#123;<span class="comment">//u连到父节点的回边不考虑</span></span><br><span class="line">       low[u] = min(low[u],dfn[v]);</span><br><span class="line">       <span class="keyword">if</span>( dfn[u] &gt; dfn[v])</span><br><span class="line"><span class="comment">//子孙连接到祖先的回边要入栈，但是子孙连接到自己的边，此处肯定已经入过栈了，不能再入栈</span></span><br><span class="line">Edges.push_back(Edge2(u,v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//对应 for( i = 0;i &lt; G[u].size() ;i ++ ) &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjian求边双联通分量"><a href="#Tarjian求边双联通分量" class="headerlink" title="Tarjian求边双联通分量"></a>Tarjian求边双联通分量</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>请大家当作课后作业，顺便把代码发给我给你测数据</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 图论 </tag>
            
            <tag> Tarjian </tag>
            
            <tag> 强联通 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Shq]Wyh买卡包</title>
      <link href="/articles/ShqProblem1/"/>
      <url>/articles/ShqProblem1/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一天，Wyh到了卡包零售店，要买卡包</p><a id="more"></a><p>但是，他到了零售点后，店长告诉他，今天已经没有零售的卡包了，只有N套成套的卡包了。</p><p>Wyh经过千辛万苦才到达了零售店，他绝对不会不买的，他今天带了M元，他想买尽可能多的卡包，但是他并不想自己算，毕竟太费脑子了，那请你帮他算算，他买那种套装更实惠</p><hr><h2 id="输入-amp-amp-输出描述"><a href="#输入-amp-amp-输出描述" class="headerlink" title="输入 &amp;&amp; 输出描述"></a>输入 &amp;&amp; 输出描述</h2><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行输入两个数，分别为Wyh带的钱数M和卡包的套数N</p><p>接下来N行，每行2个数据，分别代表套装需要的钱数 pn 和 套装中的包数 qn</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出共一行，输出买了的套装数 及 共有多少包</p><hr><h2 id="输入-amp-amp-输出样例"><a href="#输入-amp-amp-输出样例" class="headerlink" title="输入&amp;&amp;输出样例"></a>输入&amp;&amp;输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400 4</span><br><span class="line">128 30</span><br><span class="line">60 7</span><br><span class="line">388 60</span><br><span class="line">328 48</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 60</span><br></pre></td></tr></table></figure><hr><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>单点1s / 128MB</p><table><thead><tr><th style="text-align:center">数据</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">对于30%的数据</td><td style="text-align:center">0 &lt;= N &lt;= 10 ^ 3，0 &lt;= M &lt;= 10</td></tr><tr><td style="text-align:center">对于50%的数据</td><td style="text-align:center">0 &lt;= N &lt;= 10 ^ 3，0 &lt;= M &lt;= 40</td></tr><tr><td style="text-align:center">对于80%的数据</td><td style="text-align:center">0 &lt;= N &lt;= 10 ^ 4，0 &lt;= M &lt;= 100</td></tr><tr><td style="text-align:center">对于100%的数据</td><td style="text-align:center">0 &lt;= N &lt;= 10 ^ 5，0 &lt;= M &lt;= 150</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 《Shq出的题目》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Problem </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二维树状数组</title>
      <link href="/articles/TreeArray2/"/>
      <url>/articles/TreeArray2/</url>
      <content type="html"><![CDATA[<p>二维树状数组就是一维树状数组 * 2</p><a id="more"></a><p>然而，一维树状数组就是对二维树状数组进行降维打击（雾</p><p>首先，我们来看一个update的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> Abscissa, <span class="keyword">int</span> Ordinate, <span class="keyword">int</span> Increment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Abscissa; i &lt;= size_x; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Ordinate; j &lt;= size_y; j++) TreeArray[i][j] += Increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，二维树状数组就是对一维树状数组加一个<code>j</code></p><hr><p>那这就不用浪费时间了，直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件锁</span></span><br><span class="line"><span class="comment">//#define FILELOCK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TreeArray[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> size_x, size_y, qNumber;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LowBit</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &amp; -value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shq: 下面函数中的</span></span><br><span class="line"><span class="comment">// Abscissa:横坐标</span></span><br><span class="line"><span class="comment">// Ordinate:纵坐标</span></span><br><span class="line"><span class="comment">// Increment:增量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> Abscissa, <span class="keyword">int</span> Ordinate, <span class="keyword">int</span> Increment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Abscissa; i &lt;= size_x; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Ordinate; j &lt;= size_y; j++) TreeArray[i][j] += Increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Abscissa, <span class="keyword">int</span> Ordinate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Abscissa; i &gt;= <span class="number">1</span>; i -= LowBit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Ordinate; j &gt;= <span class="number">1</span>; j -= LowBit(j)) Sum += TreeArray[i][j];</span><br><span class="line">    <span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> Abscissa, <span class="keyword">int</span> Ordinate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Abscissa; i &gt;= <span class="number">1</span>; i -= LowBit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Ordinate; j &gt;= <span class="number">1</span>; j -= LowBit(i)) value += TreeArray[i][j];</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SlowRead</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> Kind)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1表示更新单个点</span></span><br><span class="line">    <span class="keyword">if</span> (Kind == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> posx, posy, value;</span><br><span class="line">        SlowRead(posx); SlowRead(posy); SlowRead(value);</span><br><span class="line">        update (posx, posy, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2表示查询单个节点的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Kind == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> posx, posy;</span><br><span class="line">        SlowRead(posx); SlowRead(posy);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Read(posx, posy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3表示求和</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Kind == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> posx, posy;</span><br><span class="line">        SlowRead(posx); SlowRead(posy);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d"</span>, query(posx , posy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他情况</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"???"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILELOCK</span></span><br><span class="line">    freopen (<span class="string">"test.in"</span> , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">    SlowRead(size_x); SlowRead(size_y);</span><br><span class="line">    SlowRead(qNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size_x; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size_y; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k; SlowRead(k);</span><br><span class="line">            update(i, j, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qNumber; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> Kind; SlowRead(Kind);</span><br><span class="line"></span><br><span class="line">        Solve(Kind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------End------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树状数组</title>
      <link href="/articles/TreeArray/"/>
      <url>/articles/TreeArray/</url>
      <content type="html"><![CDATA[<p>树状数组  重点是在树状的数组</p><a id="more"></a><p>大家都知道二叉树吧<br>叶子结点代表A数组A[1]~A[8]</p><p>Tree array is focused on the tree array<br>We all know that binary tree it<br>Leaf nodes represent A array A [1] ~ A [8]</p><p><img src="http://images2015.cnblogs.com/blog/786945/201612/786945-20161206222443741-1201716038.png" alt=""></p><hr><p>现在变形一下</p><p>Now deformation</p><p><img src="http://images2015.cnblogs.com/blog/786945/201612/786945-20161206222444069-504520694.png" alt=""></p><p> 现在定义每一列的顶端结点C[]数组<br> 如下图</p><p> Now define the top node of each column C [] array<br> As shown below</p><p><img src="https://images2015.cnblogs.com/blog/786945/201612/786945-20161206222444319-1066528329.jpg" alt=""></p><p>C[i]代表 子树的叶子结点的权值之和// 这里以求和举例<br>如图可以知道</p><p>C [i] represents the sum of the weights of the leaf nodes of the subtree // here for summation example<br>As figure can know</p><blockquote><p> C[1]=A[1];<br> C[2]=A[1]+A[2];<br> C[3]=A[3];<br> C[4]=A[1]+A[2]+A[3]+A[4];<br> C[5]=A[5];<br> C[6]=A[5]+A[6];<br> C[7]=A[7];<br> C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];</p></blockquote><p>下面观察如下图</p><p>Below observe the following figure</p><p><img src="http://images2015.cnblogs.com/blog/786945/201612/786945-20161206222444679-518511660.png" alt=""></p><p>将C[]数组的结点序号转化为二进制</p><p>The C [] array node number into binary</p><blockquote><p>1=(001)      C[1]=A[1];<br>2=(010)      C[2]=A[1]+A[2];<br>3=(011)      C[3]=A[3];<br>4=(100)      C[4]=A[1]+A[2]+A[3]+A[4];<br>5=(101)      C[5]=A[5];<br>6=(110)      C[6]=A[5]+A[6];<br>7=(111)      C[7]=A[7];<br>8=(1000)    C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];</p></blockquote><p>不难看出这和二进制有关系</p><p>而对于C[i] 我们不妨设 a = i 的二进制中从最低位到高位连续零的长度</p><p>对照式子可以发现  C[i]=A[i-a+1]+A[i-a+2]+……A[i]; 例如i=8时，a=3;<br>可以自行带入验证;</p><p>这时候，我们就会发现怎么求这个长度呢？<br>其实这个长度就是 i &amp; (-i)</p><p>证明：</p><p>It is not hard to see that this has a relationship with the binary</p><p>For C [i] we may as well set the length of a = i binary from the lowest to the highest continuous zero</p><p>For example, when i = 8, a = 3; for example, C = i [i-<br>Can bring it into verification</p><p>At this time, we will find how to seek this length?<br>In fact, this length is i &amp; (-i)</p><p>prove:</p><blockquote><p>首先明白一个概念，计算机中-i=（i的取反+1），也就是i的补码<br>而lowbit，就是求（树状数组中）一个数二进制的1的最低位，例如<code>01100110</code>，<code>lowbit=00000010；</code>再例如<code>01100000</code>，<code>lowbit=00100000</code>。<br>所以若一个数（先考虑四位）的二进制为<code>abcd</code>，那么其取反为<code>(1-a)(1-b)(1-c)(1-d)</code>，那么其补码为<code>(1-a)(1-b)(1-c)(2-d)</code>。<br>如果<code>d</code>为1，什么事都没有<em>-_-|||</em>但我们知道如果<code>d</code>为0，<em>天理不容2Σ( ° △ °|||)︴</em><br>于是就要进位。如果<code>c</code>也为0，那么<code>1-b</code>又要加1，然后又有可能是<code>1-a</code>……直到碰见一个为补码为0的<code>bit</code>，我们假设这个bit的位置为<code>x</code><br>这个时候可以发现：是不是<code>x</code>之前的<code>bit</code>的补码都与其自身不同？，<code>x</code>之后的补码与其自身一样都是0？<br>例如<code>01101000</code>，反码为<code>10010111</code>，补码为<code>10011000</code>，可以看到在原来数正数第五位前，补码的进位因第五位使其不会受到影响，于是<code>0&amp;1=0；</code><br>但在这个原来数<code>1</code>后，所有零的补码都会因加1而进位，导致在这个<code>1</code>后所有数都变成0，再加上<code>0&amp;0=0</code>，所以他们运算结果也都是零；<br>只有在这个数处，<code>0+1=1</code>，连锁反应停止，所以这个数就被确定啦<em>O(∩_∩)O</em><br>所以and以后只有x这个bit是一……</p></blockquote><blockquote><p>First understand a concept, the computer -i = (i + 1), that is, the complement of i<br>The lowbit, is seeking (tree array) a number of binary 1 of the lowest, such as 01100110, lowbit = 00000010; then for example, 01100000, lowbit = 00100000.<br>So if a number (consider the first four) of the binary is abcd, then the negation of (1-a) (1-b) (1-c) (1-d), then the complement of (1-a ) (1-b) (1-c) (2-d).<br>If d is 1, there is nothing -_- ||| but we know that if d is 0, we can not hold 2Σ (° △ ° |||) ︴<br>So we should carry. If c is also 0 then 1-b is incremented by 1 and then possibly 1-a … until we encounter a bit that has a complement of 0, and we assume that this bit is at x<br>This time can be found: is not the complement of the bit before x are different from their own? , After the complement of x is the same as its own 0?<br>For example, 01101000, anti-code is 10010111, complement code is 10011000, you can see in the original number of positive fifth before the complement of the carry for the fifth so that it will not be affected, so 0 &amp; 1 = 0;<br>However, after the original number 1, all zero’s complement will be carried by 1, resulting in all the numbers in this 1 become 0, together with 0 &amp; 0 = 0, so their results are also zero;<br>Only in this number, 0 + 1 = 1, the chain reaction stops, so this number is determined O (∩ _ ∩) O<br>So after and only x this bit is 1 …</p></blockquote><hr><h2 id="LowBit"><a href="#LowBit" class="headerlink" title="LowBit"></a>LowBit</h2><p>LowBit部分就是求 <code>i</code> 的二进制中从最低位到高位连续零的长度</p><p>The LowBit part is the length of the consecutive zeros from the lowest to the highest in the binary of i</p><p>代码：</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LowBit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &amp; -i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>当我们修改A[]数组中的某一个值时  应当如何更新C[]数组呢？</p><p>回想一下 区间查询的过程，再看一下上文中列出的图</p><p>How do we update the C [] array when we change a value in the A [] array?</p><p>Recall the process of interval query, take a look at the figure listed above</p><p>代码：</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = node; i &lt;= number; i += LowBit(i)) TreeArray[i] += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/786945/201612/786945-20161206222445132-1538640594.jpg" alt=""></p><p>如图： </p><p>As shown:</p><p>当更新A[1]时  需要向上更新C[1] ,C[2],C[4],C[8]</p><p>You need to update C [1], C [2], C [4], C [8] when updating A [1]</p><blockquote><p>​                     C[1],   C[2],    C[4],     C[8]</p><p>写为二进制 Written as binary :  C[(001)],C[(010)],C[(100)],C[(1000)]</p><p>​                                      1(001)        <strong>C[1]+=A[1]</strong><br>lowbit(1)=001 1+lowbit(1)=2(010)     <strong>C[2]+=A[1]</strong><br>lowbit(2)=010 2+lowbit(2)=4(100)     <strong>C[4]+=A[1]</strong><br>lowbit(4)=100 4+lowbit(4)=8(1000)   <strong>C[8]+=A[1]</strong></p></blockquote><hr><h2 id="GetSum"><a href="#GetSum" class="headerlink" title="GetSum"></a>GetSum</h2><p>下面利用C[i]数组，求A数组中前i项的和 </p><p>Let’s use the C [i] array to find the sum of the first i terms in the A array</p><p>举个例子 i=7;</p><p>For example i = 7;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum[<span class="number">7</span>]=A[<span class="number">1</span>]+A[<span class="number">2</span>]+A[<span class="number">3</span>]+A[<span class="number">4</span>]+A[<span class="number">5</span>]+A[<span class="number">6</span>]+A[<span class="number">7</span>] ;   <span class="comment">//前i项和</span></span><br><span class="line"></span><br><span class="line">C[<span class="number">4</span>]=A[<span class="number">1</span>]+A[<span class="number">2</span>]+A[<span class="number">3</span>]+A[<span class="number">4</span>];   C[<span class="number">6</span>]=A[<span class="number">5</span>]+A[<span class="number">6</span>];   C[<span class="number">7</span>]=A[<span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>可以推出:  <code>sum[7]=C[4]+C[6]+C[7];</code></p><p>Can be introduced:  <code>sum[7]=C[4]+C[6]+C[7];</code></p><p>序号写为二进制: <code>sum[(111)]=C[(100)]+C[(110)]+C[(111)];</code></p><p>The serial number is written as binary: sum [(111)] = C [(100)] + C [(110)] + C [(111)];</p><p><strong>细细观察二进制 树状数组追其根本就是二进制的应用</strong></p><p><strong>A careful observation of the binary tree array chasing it is simply a binary application</strong></p><p>代码：</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> GetSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt; <span class="number">0</span>; i -= LowBit(i)) GetSum += TreeArray[i];</span><br><span class="line">    <span class="keyword">return</span> GetSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于i=7 进行演示 </p><blockquote><p>​                                  7(111)     <strong> ans+=C[7]</strong><br>lowbit(7)=001  7-lowbit(7)=6(110) <strong>   ans+=C[6]</strong><br>lowbit(6)=010  6-lowbit(6)=4(100)    <strong>ans+=C[4]</strong><br>lowbit(4)=100  4-lowbit(4)=0(000)    </p></blockquote><hr><p>好了，解析到这里就结束了</p><p>Well, the analysis is over here</p><p>下面附上总代码：</p><p>Code:</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TreeArray[MAXN], number, qNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读 Quick Read ; from: Wyh's Blog</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SlowRead</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Data = <span class="number">0</span>,w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch != <span class="string">'-'</span> &amp;&amp; (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)) ch = getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>,ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) Data = Data * <span class="number">10</span> + ch - <span class="string">'0'</span>,ch = getchar();</span><br><span class="line">    num = Data * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LowBit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &amp; -i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = node; i &lt;= number; i += LowBit(i)) TreeArray[i] += value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> GetSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt; <span class="number">0</span>; i -= LowBit(i)) GetSum += TreeArray[i];</span><br><span class="line">    <span class="keyword">return</span> GetSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SlowRead(number);SlowRead(qNumber);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        SlowRead(d);</span><br><span class="line">        add(i, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qNumber; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> Kind, x, y;</span><br><span class="line">        SlowRead(Kind); SlowRead(x); SlowRead(y);</span><br><span class="line">        <span class="keyword">if</span>(Kind == <span class="number">1</span>) add(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Kind == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,GetSum(y)-GetSum(x - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 完美结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SegmentTree线段树</title>
      <link href="/articles/SegmentTree/"/>
      <url>/articles/SegmentTree/</url>
      <content type="html"><![CDATA[<p>线段树<br>SegmentTree</p><p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)</p><a id="more"></a><p>Line segment tree, a similar interval tree, which saves a line segment in each node (an array of sub-array), is mainly used to efficiently solve the dynamic range of consecutive queries, due to the characteristics of binary structure, it can basically maintain each operation Complexity is O (logn)</p><p>线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]</p><p>Each node of the segment tree represents an interval, and the subnodes represent the left and right half intervals of the parent node respectively. For example, if the father’s interval is [a, b], the interval of the left son [a, c], the right son’s interval is [c + 1, b]</p><p>下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0…n-1]中查找某个数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新</p><p>Below we learn from a classic example of the line segment tree, the problem is described as follows: From the array arr [0 … n-1] to find the minimum value of a range of an array, which array size fixed, but the array The value of the element can be updated at any time</p><p>对这个问题一个简单的解法是：遍历数组区间找到最小值，时间复杂度是O(n),额外的空间复杂度O(1)。当数据量特别大，而查询操作很频繁的时候，耗时可能会不满足需求</p><p>A simple solution to this problem is: traversing the array interval to find the minimum, the time complexity is O (n), additional space complexity O (1). When the amount of data is particularly large, and query operations are frequent, time-consuming may not meet the demand</p><p>另一种解法：使用一个二维数组来保存提前计算好的区间[i,j]内的最小值，那么预处理时间为O(n^2)，查询耗时O(1), 但是需要额外的O(n^2)空间，当数据量很大时，这个空间消耗是庞大的，而且当改变了数组中的某一个值时，更新二维数组中的最小值也很麻烦</p><p>Another solution: using a two-dimensional array to save the minimum value of the interval [i, j] calculated in advance, then the preprocessing time is O (n ^ 2), the query takes O (1) O (n ^ 2) space, this space consumption is huge when the amount of data is large, and updating the minimum value in the two-dimensional array is also troublesome when changing one of the values in the array</p><p>我们可以用线段树来解决这个问题：预处理耗时O(n)，查询、更新操作O(logn)，需要额外的空间O(n)。根据这个问题我们构造如下的二叉树</p><p>We can solve this problem with a segment tree: Preprocessing O (n), query, update operation O (logn), requires extra space O (n). According to this problem we construct the following binary tree</p><ul><li>叶子节点是原始组数arr中的元素</li><li>非叶子节点代表它的所有子孙叶子节点所在区间的最小值</li></ul><ul><li>The leaf node is the element in the original group arr</li><li>The non-leaf node represents the minimum of the range of all its children’s leaf nodes</li></ul><p>例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）</p><p>For example, an array [2, 5, 1, 4, 9, 3] can construct a binary tree as follows (the background is a white leaf node, and the value of a non-leaf node is the minimum value within its corresponding array interval. For example, the root node represents an array interval The minimum value in arr [0 … 5] is 1)</p><p><img src="https://images0.cnblogs.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg" alt=""></p><p>由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，<strong>对于包含n个叶子节点的完全二叉树，它一定有n-1个非叶节点，总共2n-1个节点</strong>，因此存储线段是需要的空间复杂度是O(n)。</p><p>The segment tree is a complete binary tree because the parent interval of the segment tree is evenly divided into left and right subtrees. For a complete binary tree containing n leaf nodes, it must have n-1 non-leaf nodes, for a total of 2n-1 nodes, Therefore, the space complexity required to store a line segment is O (n).</p><hr><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value,LasyTag;</span><br><span class="line">&#125;SegmentTree[MAXN*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RangeLength,Question_Number,t,Kind,y,k;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树 build tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SegmentTree_build</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">long</span> <span class="keyword">long</span> arr[],<span class="keyword">int</span> istart,<span class="keyword">int</span> iend)</span></span>&#123;</span><br><span class="line">    SegmentTree[root].LasyTag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(istart==iend) SegmentTree[root].value=arr[istart];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Rangemid=(istart+iend)/<span class="number">2</span>;</span><br><span class="line">        SegmentTree_build(root*<span class="number">2</span>,arr,istart,Rangemid);</span><br><span class="line">        SegmentTree_build(root*<span class="number">2</span>+<span class="number">1</span>,arr,Rangemid+<span class="number">1</span>,iend);</span><br><span class="line">        SegmentTree[root].value=SegmentTree[root*<span class="number">2</span>].value+SegmentTree[root*<span class="number">2</span>+<span class="number">1</span>].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入LasyTag Insert LasyTag</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SegmentTree_pushDown</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(SegmentTree[root].LasyTag!=<span class="number">0</span>)&#123;</span><br><span class="line">        SegmentTree[root*<span class="number">2</span>].LasyTag+=SegmentTree[root].LasyTag;</span><br><span class="line">        SegmentTree[root*<span class="number">2</span>+<span class="number">1</span>].LasyTag+=SegmentTree[root].LasyTag;</span><br><span class="line">        <span class="keyword">int</span> Rangemid=(end+start)/<span class="number">2</span>;</span><br><span class="line">        SegmentTree[root*<span class="number">2</span>].value+=SegmentTree[root].LasyTag*(Rangemid-start+<span class="number">1</span>);</span><br><span class="line">        SegmentTree[root*<span class="number">2</span>+<span class="number">1</span>].value+=SegmentTree[root].LasyTag*(end-Rangemid);</span><br><span class="line">        SegmentTree[root].LasyTag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间查询 Query Range</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">SegmentTree_query</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> Rangenstart,<span class="keyword">int</span> Rangenend,<span class="keyword">int</span> Rangeqstart,<span class="keyword">int</span> Rangeqend)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Rangeqstart&gt;Rangenend||Rangeqend&lt;Rangenstart) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Rangeqstart&lt;=Rangenstart&amp;&amp;Rangeqend&gt;=Rangenend) <span class="keyword">return</span> SegmentTree[root].value;</span><br><span class="line">    SegmentTree_pushDown(root,Rangenstart,Rangenend);</span><br><span class="line">    <span class="keyword">int</span> Rangemid=(Rangenstart+Rangenend)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> SegmentTree_query(root*<span class="number">2</span>,Rangenstart,Rangemid,Rangeqstart,Rangeqend)+SegmentTree_query(root*<span class="number">2</span>+<span class="number">1</span>,Rangemid+<span class="number">1</span>,Rangenend,Rangeqstart,Rangeqend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值 Assignment</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SegmentTree_update</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> Rangenstart,<span class="keyword">int</span> Rangenend,<span class="keyword">int</span> Rangeustart,<span class="keyword">int</span> Rangeuend,<span class="keyword">int</span> addvalue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Rangeustart&gt;Rangenend||Rangeuend&lt;Rangenstart) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(Rangeustart&lt;=Rangenstart&amp;&amp;Rangeuend&gt;=Rangenend)&#123;</span><br><span class="line">        SegmentTree[root].LasyTag+=addvalue;</span><br><span class="line">        SegmentTree[root].value+=addvalue*(Rangenend-Rangenstart+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree_pushDown(root,Rangenstart,Rangenend);</span><br><span class="line">    <span class="keyword">int</span> Rangemid=(Rangenstart+Rangenend)/<span class="number">2</span>;</span><br><span class="line">    SegmentTree_update(root*<span class="number">2</span>,Rangenstart,Rangemid,Rangeustart,Rangeuend,addvalue);</span><br><span class="line">    SegmentTree_update(root*<span class="number">2</span>+<span class="number">1</span>,Rangemid+<span class="number">1</span>,Rangenend,Rangeustart,Rangeuend,addvalue);</span><br><span class="line">    SegmentTree[root].value=SegmentTree[root*<span class="number">2</span>].value+SegmentTree[root*<span class="number">2</span>+<span class="number">1</span>].value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;RangeLength,&amp;Question_Number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=RangeLength;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    SegmentTree_build(<span class="number">1</span>,a,<span class="number">1</span>,RangeLength);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Question_Number;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;Kind,&amp;y,&amp;k);</span><br><span class="line">            SegmentTree_update(<span class="number">1</span>,<span class="number">1</span>,RangeLength,Kind,y,k);</span><br><span class="line">        &#125;<span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;Kind,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,SegmentTree_query(<span class="number">1</span>,<span class="number">1</span>,RangeLength,Kind,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Wonderful End</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29717271&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python入门（一）</title>
      <link href="/articles/python1/"/>
      <url>/articles/python1/</url>
      <content type="html"><![CDATA[<blockquote><p> Python 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。</p></blockquote><a id="more"></a><blockquote><p>Python是纯粹的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">自由软件</a>， <a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969" target="_blank" rel="noopener">源代码</a>和<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8" target="_blank" rel="noopener">解释器</a>CPython遵循 <a href="https://baike.baidu.com/item/GPL" target="_blank" rel="noopener">GPL</a>(<a href="https://baike.baidu.com/item/GNU" target="_blank" rel="noopener">GNU</a> General Public License)协议。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。</p><p>Python具有丰富和强大的库。它常被昵称为<a href="https://baike.baidu.com/item/%E8%83%B6%E6%B0%B4%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">胶水语言</a>，能够把用其他语言制作的各种模块（尤其是<a href="https://baike.baidu.com/item/C/7252092" target="_blank" rel="noopener">C</a>/<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写，比如<a href="https://baike.baidu.com/item/3D%E6%B8%B8%E6%88%8F" target="_blank" rel="noopener">3D游戏</a>中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">跨平台</a>的实现。</p></blockquote><center>—–以上来自某度百科—–</center><p>Python其实是一个十分好用的语言，<del>有点常识的人</del>用过的人都知道他的简洁</p><hr><h2 id="First-Python-program"><a href="#First-Python-program" class="headerlink" title="First Python program!"></a>First Python program!</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/media/shan666/Files</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><blockquote><p> tips> ‘#’后面的代表注释，你加上或不加没有什么影响</p></blockquote><p>print 是一个函数，用来向屏幕上打印东西。</p><p>现在，问题来了，我们只是写出了19个字符而已，有什么用呢？？</p><p>我们接下来就要在电脑上运行一下</p><p>新建一个文件HelloWorld.py</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Python1/HelloWorld/0.png" alt="Hello World"></p><p>接下来，我们cd到相关目录，运行命令：</p><blockquote><p>python HelloWorld.py</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Python1/HelloWorld/HelloWorld.png" alt="Hello World"></p><p>这就是我们的第一个Python程序了</p><p>虽然这些代码很简单(的确很简单)，也没什么效果，但是这毕竟是万里长征第一步。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，<code>1.23x109</code>和<code>12.3x108</code>是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把<code>10</code>用<code>e</code>替代，<code>1.23x109</code>就是<code>1.23e9</code>，或者<code>12.3e8</code>，<code>0.000012</code>可以写成<code>1.2e-5</code>，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p><p>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'I\'m \"OK\"!'</span></span><br></pre></td></tr></table></figure><p>表示的字符串内容是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">'m "OK"!</span></span><br></pre></td></tr></table></figure><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code></p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">5</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span> &gt; <span class="number">3</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>布尔值经常用在条件判断中，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>变量<code>a</code>是一个整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_007 = <span class="string">'T007'</span></span><br></pre></td></tr></table></figure><p>变量<code>t_007</code>是一个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Answer = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>变量<code>Answer</code>是一个布尔值<code>True</code>。</p><p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，</p><p>这种变量本身类型不固定的语言称之为<em>动态语言</em>，与之对应的是<em>静态语言</em>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>; <span class="comment">// a是整数类型变量</span></span><br><span class="line">a = <span class="string">"ABC"</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因。</p><p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">x = x + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p><p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'ABC'</span></span><br></pre></td></tr></table></figure><p>时，Python解释器干了两件事情：</p><ol><li>在内存中创建了一个<code>&#39;ABC&#39;</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>&#39;ABC&#39;</code>。</li></ol><p>也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据</p><hr><p>(未完待<del>续</del>)</p>]]></content>
      
      <categories>
          
          <category> 《人生苦短》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++教程</title>
      <link href="/articles/cppteach/"/>
      <url>/articles/cppteach/</url>
      <content type="html"><![CDATA[<p>本文是关于C++的基础</p><a id="more"></a><p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p><p>本教程通过通俗易懂的语言来讲解 C++ 编程语言。</p><hr><p>C++教程：</p><iframe style="padding:0px;" src="http://www.runoob.com/cplusplus/cpp-tutorial.html" width="100%" height="250" frameborder="0px"></iframe><hr><p>From–<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a></p>]]></content>
      
      <categories>
          
          <category> 《教程》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BigInt</title>
      <link href="/articles/BigInt/"/>
      <url>/articles/BigInt/</url>
      <content type="html"><![CDATA[<p>高精度是在算法竞赛中一种十分常用的算法，本文就来介绍一下有关高精度的一些知识</p><p>我们知道，计算机内部直接用int或double等数据类型储存数字是有范围限制的，即当数据运算大小过大后，计算机将会出现溢出情况，使得计算结果不够精确。为了能够使计算机精确地计算高位的数字，我们需要学会使用高精度乘法</p><p>当然再本地，你可以用一些__int128之类的定义，但是你在NOIP中用个试试23333333</p><p>事实上，高精度乘法就是通过编程的方法，把我们小学时候我们学过的数学乘法运算的步骤在计算机上完美的演示一遍而已</p><a id="more"></a><hr><h2 id="高精加"><a href="#高精加" class="headerlink" title="高精加"></a>高精加</h2><p>回忆我们小学时候的列数式加法：</p><blockquote><center>1  3</center><br><center>2  8</center><br><center>+—————-</center><br><center>4  1</center></blockquote><p>这当然是一种十分有效的计算方法2333</p><p>现在我们用代码的眼光重新审视一下我们加法的步骤：</p><blockquote><center>a[1]  a[2]</center><br><center>1  3</center><br><center>b[1]  b[2]</center><br><center>2  8</center><br><center>+—————-</center><br><center>ans[1]  ans[2]</center><br><center>4  1</center></blockquote><p>首先，进行a[2] + b[2] 的操作，得到ans[2] = 11, ans[2] % 10 得到1 ,向下一位进1，上一位没有进位得1。<br>继续，进行a[1] + b[1] 的操作，得到ans[1] = 3  , ans[1] % 10 得到3 ,向下一位进0，加上一位的进位1得4</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////高精度加法//////</span></span><br><span class="line"><span class="keyword">while</span>(lenc &lt;=a1_len || lenc &lt;=b1_len)&#123;</span><br><span class="line">    c[lenc] = a[lenc] + b[lenc] + x; <span class="comment">//两数相加</span></span><br><span class="line">    x = c[lenc]/<span class="number">10</span>;   <span class="comment">//要进的位,注意，x要初始化为0</span></span><br><span class="line">    c[lenc] = c[lenc] % <span class="number">10</span>;     <span class="comment">//进位后的数</span></span><br><span class="line">    lenc++;     <span class="comment">//数组下标加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="高精减"><a href="#高精减" class="headerlink" title="高精减"></a>高精减</h2><p>学会了高精加，高精减就很容易了</p><p>唯一要注意的一点就是输出的时候要带符号</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lenc &lt;= a_lenth || i &lt;= b_lenth)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(a[lenc] &lt; b[lenc])&#123;</span><br><span class="line">        a[lenc + <span class="number">1</span>]--;</span><br><span class="line">        a[lenc] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[lenc] = a[lenc] - b[lenc];</span><br><span class="line">    lenc++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="高精乘-除"><a href="#高精乘-除" class="headerlink" title="高精乘/除"></a>高精乘/除</h2><p>略</p><hr><p>最后我们将所有的操作封装在一起，就会得到一个相当长的BigInt：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span>&#123;</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BASE=<span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WIDTH=<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">//value</span></span><br><span class="line">    BigInt(<span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>)&#123; *<span class="keyword">this</span> = num;&#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> = (<span class="keyword">long</span> <span class="keyword">long</span> num)&#123;</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            s.push_back(num%BASE);</span><br><span class="line">            num/=BASE;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)&#123;</span><br><span class="line">        s.clear() ;</span><br><span class="line">        <span class="keyword">int</span> x,len = (str.length()<span class="number">-1</span>)/WIDTH + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> end = str.length() - i*WIDTH;</span><br><span class="line">            <span class="keyword">int</span> start = max(<span class="number">0</span>,end - WIDTH);</span><br><span class="line">            <span class="built_in">sscanf</span>(str.substr(start,end-start).c_str(),<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            s.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//input&amp;output</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="keyword">const</span> BigInt&amp; x)&#123;</span><br><span class="line">        out &lt;&lt; x.s.back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x.s.size()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(buf,<span class="string">"%08d"</span>,x.s[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(buf);j++) out &lt;&lt; buf[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream &amp;in, BigInt&amp; x)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span>(!(in&gt;&gt;s)) <span class="keyword">return</span> in;</span><br><span class="line">        x=s;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//compare</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()!=b.s.size()) <span class="keyword">return</span> s.size() &lt; b.s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++) <span class="keyword">if</span>(s[i]!=b.s[i]) <span class="keyword">return</span> s[i] &lt; b.s[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//equal</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span> || *<span class="keyword">this</span> &lt; b;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>) &amp;&amp; !(*<span class="keyword">this</span> &lt; b);&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//calculate</span></span><br><span class="line">    BigInt <span class="keyword">operator</span> +(<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.s.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,g=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g==<span class="number">0</span> &amp;&amp; i&gt;=s.size() &amp;&amp; i&gt;=b.s.size()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x=g;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.size()) x+=s[i];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;b.s.size()) x+=b.s[i];</span><br><span class="line">            c.s.push_back(x%BASE);</span><br><span class="line">            g = x/BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> +=(<span class="keyword">const</span> BigInt&amp; b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> -(<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.s.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,g=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g==<span class="number">0</span> &amp;&amp; i&gt;=s.size() &amp;&amp; i&gt;=b.s.size()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x=g;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.size()) x+=s[i];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;b.s.size()) x-=b.s[i];</span><br><span class="line">            x+=BASE;</span><br><span class="line">            c.s.push_back(x%BASE);</span><br><span class="line">            g = x/BASE - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span> * (<span class="keyword">const</span> BigInt&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.s.clear();</span><br><span class="line">        BigInt g=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.s.size()==<span class="number">0</span> &amp;&amp; i&gt;=s.size()+b.s.size()<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            BigInt x;</span><br><span class="line">            x.s.clear() ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g.s.size();j++) x.s.push_back(g.s[j]);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;s.size()+b.s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = max(<span class="number">0</span> , i-(<span class="keyword">int</span>)s.size()+<span class="number">1</span>);j&lt;=min(i,(<span class="keyword">int</span>)b.s.size()<span class="number">-1</span>);j++)&#123;</span><br><span class="line">                    BigInt t = (<span class="keyword">long</span> <span class="keyword">long</span>)b.s[j]*s[i-j];</span><br><span class="line">                    x += t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s.push_back(x.s[<span class="number">0</span>]);</span><br><span class="line">            g.s.clear();</span><br><span class="line">            <span class="keyword">if</span>(x.s.size()&gt;<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;x.s.size();j++) g.s.push_back(x.s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 高精度 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOI2010]能量采集</title>
      <link href="/articles/NOI2010-Plant/"/>
      <url>/articles/NOI2010-Plant/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1447" target="_blank" rel="noopener">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。</p><a id="more"></a><p>栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。</p><p>由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。</p><p>能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。</p><p>在这个例子中，总共产生了36的能量损失。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>仅包含一行，为两个整数n和m。</p><p>输出格式：</p><p>仅包含一个整数，表示总共产生的能量损失。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【样例输入1】</span><br><span class="line">5 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【样例输入2】</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【样例输出1】</span><br><span class="line">36</span><br><span class="line"></span><br><span class="line">【样例输出2】</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于10%的数据：1 ≤ n, m ≤ 10；</p><p>对于50%的数据：1 ≤ n, m ≤ 100；</p><p>对于80%的数据：1 ≤ n, m ≤ 1000；</p><p>对于90%的数据：1 ≤ n, m ≤ 10,000；</p><p>对于100%的数据：1 ≤ n, m ≤ 100,000。</p><hr><p>首先看到这道题，作为一个数竞<del>dalao</del>蒟蒻，首先想到的就是建系，但是建系的话就更麻烦了，所以说我们需要搞到一个更好的方法</p><blockquote><p>|<br>|      o (4,2)<br>|     /<br>|   o (2,1)<br>|  /<br>o —- —————-</p></blockquote><p>懒得画图再传了，就用这个将就一些吧</p><p>注意，我们看到(4,2)这个点，它与原点构成的一次函数(正比例函数)的解析式为f(x) = 2x,那么说他一定经过(2,1)</p><p>回到问题上来，我们要求的某个点能量损失事实上就是求他与原点构成的一次函数经过的整数点。</p><p>一次函数经过的整数点怎么算呢?经过我们的一番严密的，细致的思索，终于得出—-gcd(x, y)。具体为什么呢，请自行推理</p><p>所以说，我们就写出了第一个暴力解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            ans += gcd(i, j);</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">2</span> - m * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，明显这样做不是出题人的意图。毕竟暴力就可以水过的题不会再NOI中出现</p><hr><p>我们怎么优化暴力呢?自己看就行了</p><p>本题就是小学奥术题，自己翻翻一些小学奥术教材就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(nlogn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">LL size,m,mu[MAXN],Answer,tot;</span><br><span class="line">LL p[MAXN],np[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= size; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[++p[<span class="number">0</span>]] = i,mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; p[j]*i &lt;= size; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = p[j]*i;</span><br><span class="line">            np[k] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i % p[j])) <span class="keyword">break</span>;</span><br><span class="line">            mu[k] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; size &gt;&gt; m;</span><br><span class="line">    get_mu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= size; d++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(size, m) / d; i++)</span><br><span class="line">            Answer += d * mu[i] * (size / (d * i)) * (m / (d * i));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Answer * <span class="number">2</span> - size * m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=424496995&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些写文章用的Html语法</title>
      <link href="/articles/markdown/"/>
      <url>/articles/markdown/</url>
      <content type="html"><![CDATA[<p>在写一些Markdown的文章中，经常会发现一些问题–markdown并不滋磁那么多的用法(不要说我t** y**** t** s*****)，其实再Github page中也是滋磁Html的语法的，这也极大弥补了Markdown的不足性。</p><a id="more"></a><p>当然，写一些平常的Mardown文档是不需要那么多Html的，这仅仅是锦上添花而已23333</p><p>话不多说，下面就是Html的几种常在文章里用到的用法</p><hr><h2 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h2><input class="input-text" type="text" placeholder="Text"><input class="input-search" type="search" placeholder="Search"><textarea class="input-textarea" placeholder="Text Area"></textarea><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-text'</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">placeholder</span>=<span class="string">'Text'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-search'</span> <span class="attr">type</span>=<span class="string">'search'</span> <span class="attr">placeholder</span>=<span class="string">'Search'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">'input-textarea'</span> <span class="attr">placeholder</span>=<span class="string">'Text Area'</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><label class="input-label"><input class="input-radio" type="radio" name="radio"> Radio</label><label class="input-label"><input class="input-radio" type="radio" name="radio" checked> Radio</label><label class="input-label"><input class="input-checkbox" type="checkbox" checked> Checkbox</label><label class="input-label"><input class="input-toggle" type="checkbox" checked> Toggle</label><input class="input-range" type="range"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">'input-label'</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-radio'</span> <span class="attr">type</span>=<span class="string">'radio'</span> <span class="attr">name</span>=<span class="string">'radio'</span>&gt;</span> Radio<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">'input-label'</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-radio'</span> <span class="attr">type</span>=<span class="string">'radio'</span> <span class="attr">name</span>=<span class="string">'radio'</span> <span class="attr">checked</span>&gt;</span> Radio<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">'input-label'</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-checkbox'</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">checked</span>&gt;</span> Checkbox<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">'input-label'</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-toggle'</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">checked</span>&gt;</span> Toggle<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">'input-range'</span> <span class="attr">type</span>=<span class="string">'range'</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><div class="block"><br>  <button class="inline-block btn">Do it</button><br>  <button class="inline-block btn">Another</button><br>  <button class="inline-block btn"><a href="https://bad-end.github.io" target="_blank" rel="noopener">Bad_End’s Blog</a></button><br></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'block'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'inline-block btn'</span>&gt;</span>Do it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'inline-block btn'</span>&gt;</span>Another<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">'inline-block btn'</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://bad-end.github.io"</span>&gt;</span>Bad_End's Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h2><ul class="list-tree has-collapsable-children"><br><li class="list-nested-item"><br>  <div class="list-item"><br>      <span class="icon icon-file-directory">A Directory</span><br>  </div><br><br>  <ul class="list-tree"><br>    <li class="list-nested-item"><br>      <div class="list-item"><br>        <span class="icon icon-file-directory">Nested Directory</span><br>      </div><br><br>      <ul class="list-tree"><br>         <li class="list-item"><br>                <span class="icon icon-file-text">File one</span><br>                </li><br>            </ul><br>        </li><br><br>        <li class="list-nested-item collapsed"><br>            <div class="list-item"><br>                <span class="icon icon-file-directory">Collapsed Nested Directory</span><br>            </div><br><br>            <ul class="list-tree"><br>                <li class="list-item"><br>                    <span class="icon icon-file-text">File one</span><br>                </li><br>            </ul><br>        </li><br><br>        <li class="list-item"><br>            <span class="icon icon-file-text">File one</span><br>        </li><br><br>        <li class="list-item selected"><br>            <span class="icon icon-file-text">File three .selected!</span><br>        </li><br>    </ul><br></li><br><br><li class="list-item"><br>    <span class="icon icon-file-text">.icon-file-text</span><br></li><br><br><li class="list-item"><br>    <span class="icon icon-file-symlink-file">.icon-file-symlink-file</span><br></li><br></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&apos;list-tree has-collapsable-children&apos;&gt;</span><br><span class="line">    &lt;li class=&apos;list-nested-item&apos;&gt;</span><br><span class="line">        &lt;div class=&apos;list-item&apos;&gt;</span><br><span class="line">            &lt;span class=&apos;icon icon-file-directory&apos;&gt;A Directory&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;ul class=&apos;list-tree&apos;&gt;</span><br><span class="line">            &lt;li class=&apos;list-nested-item&apos;&gt;</span><br><span class="line">                &lt;div class=&apos;list-item&apos;&gt;</span><br><span class="line">                    &lt;span class=&apos;icon icon-file-directory&apos;&gt;Nested Directory&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">                &lt;ul class=&apos;list-tree&apos;&gt;</span><br><span class="line">                    &lt;li class=&apos;list-item&apos;&gt;</span><br><span class="line">                        &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;li class=&apos;list-nested-item collapsed&apos;&gt;</span><br><span class="line">                &lt;div class=&apos;list-item&apos;&gt;</span><br><span class="line">                    &lt;span class=&apos;icon icon-file-directory&apos;&gt;Collapsed Nested Directory&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">                &lt;ul class=&apos;list-tree&apos;&gt;</span><br><span class="line">                    &lt;li class=&apos;list-item&apos;&gt;</span><br><span class="line">                        &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;li class=&apos;list-item&apos;&gt;</span><br><span class="line">                &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;li class=&apos;list-item selected&apos;&gt;</span><br><span class="line">                &lt;span class=&apos;icon icon-file-text&apos;&gt;File three .selected!&lt;/span&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;li class=&apos;list-item&apos;&gt;</span><br><span class="line">        &lt;span class=&apos;icon icon-file-text&apos;&gt;.icon-file-text&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;li class=&apos;list-item&apos;&gt;</span><br><span class="line">        &lt;span class=&apos;icon icon-file-symlink-file&apos;&gt;.icon-file-symlink-file&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 《hexo的玄学用法系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> blog </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu终端基础命令(二)</title>
      <link href="/articles/terminal2/"/>
      <url>/articles/terminal2/</url>
      <content type="html"><![CDATA[<p>本文是<a href="https://blog-shq.github.io/2018/01/19/terminal/" target="_blank" rel="noopener">Ubuntu终端基础命令(一)</a>的续集</p><a id="more"></a><h2 id="新建文件-文件夹"><a href="#新建文件-文件夹" class="headerlink" title="新建文件/文件夹"></a>新建文件/文件夹</h2><p>新建文件/文件夹命令</p><blockquote><p>$ touch [name]</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-touch/1.png" alt="touch"></p><blockquote><p>我们运行命令： $ touch 1.cpp</p></blockquote><hr><p>效果：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-touch/2.png" alt=""></p><p>注意，我们输入的\<name>是要带后缀的。当然，你的这个后缀是什么都可以的</name></p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-touch/3.png" alt="touch"></p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-touch/4.png" alt="shq666"></p><hr><p>创建目录(文件夹):</p><blockquote><p>$ mkdir [name]</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-mkdir/0.png" alt="mkdir"></p><hr><p>比方说，我们要新建一个叫做1的目录(文件夹)，就可以运行命令：</p><blockquote><p>$ mkdir 1</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-mkdir/1.png" alt="mkdir"></p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-mkdir/2.png" alt="mkdir"></p><hr><p><strong>注意：这是在普通文件夹的创建，在系统文件夹中要先取得权限</strong></p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-su-sudo/01.png" alt="sudo/su"></p><p>取得权限有两种方法：</p><ul><li>执行 su 命令进入root帐户</li><li>使用 sudo 暂时取得权限</li></ul><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>进入root用户：</p><blockquote><p>$ su</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-su-sudo/0.png" alt="sudo/su"></p><hr><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>使用sudo命令可以短暂取得权限</p><blockquote><p>$ sudo &lt;命令&gt;</p></blockquote><p>在命令前加 ‘sudo’</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-su-sudo/02.png" alt="sudo/su"></p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-su-sudo/03.png" alt="sudo/su"></p><p>输入密码，即可</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-su-sudo/04.png" alt="sudo/su"></p><hr><p>在Ubuntu中，我们可以在网上下载到各个软件的.deb包，接下来，我们就来看一看如何解包</p><h2 id="deb包"><a href="#deb包" class="headerlink" title=".deb包"></a>.deb包</h2><p>首先，cd到相应目录</p><p>运行解包命令：</p><blockquote><p>$ sudo dpkg –install xxx.deb</p></blockquote><p>注意，上方的xxx.deb输入的时候，可以按’Tab’键补全。</p><hr><p>(未完待<strong><del>续</del></strong>)</p>]]></content>
      
      <categories>
          
          <category> 《Terminal教程系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> system </tag>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu终端基础命令(一)</title>
      <link href="/articles/terminal/"/>
      <url>/articles/terminal/</url>
      <content type="html"><![CDATA[<p>大家都知道，Terminal是Linux下十分有用的东西，下面Shq就介绍下Teminal一些常用的命令</p><a id="more"></a><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在终端中打开文件夹。</p><blockquote><p>$ cd  [文件名]</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-cd/1.png" alt="cd"></p><center>cd到目录</center><hr><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-cd/2.png" alt="返回"></p><center>返回上一个目录</center><blockquote><p>$ cd ..</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-cd/3.png" alt="cd"></p><center>打开文件夹</center><hr><h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><p>清屏命令</p><blockquote><p>$ clear</p></blockquote><p>比如我们有一个十分乱的终端233333333</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-clear/1.png" alt="luan"></p><p>但是，我们有Shq的教程在，<del>发动秘技——-反复横跳</del>，使用clear秘技</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-clear/2.png" alt="clear"></p><p>就会变得异常干净明了</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-clear/3.png" alt="clear"></p><h2 id="退出终端"><a href="#退出终端" class="headerlink" title="退出终端"></a>退出终端</h2><p>下面就介绍一下如何退出终端</p><p>（据<a href="http://blog.aor.cn" target="_blank" rel="noopener">Wyh</a>dalao说，直接点X号是会损坏机子的<del>如果你够有钱，你可以不看</del>，所以说我们就需要一个十分有效的方法去<del>不损坏电脑</del>关掉终端</p><blockquote><p>$ exit</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-exit/1.png" alt="exit"></p><hr><p>问题来了，有时候一次关闭会关不掉</p><p>所以说，我们要模仿关酒精灯的方法(雾)，再关一次233</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/terminal-exit/2.png" alt="酒精灯"></p><hr><p>未完待<del>续</del></p>]]></content>
      
      <categories>
          
          <category> 《Terminal教程系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> system </tag>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安装elementaryos虚拟机</title>
      <link href="/articles/elementaryos/"/>
      <url>/articles/elementaryos/</url>
      <content type="html"><![CDATA[<h2 id="elementaryos"><a href="#elementaryos" class="headerlink" title="elementaryos"></a>elementaryos</h2><p><a href="https://elementary.io/" target="_blank" rel="noopener">elementaryos 官网</a></p><p>Elementary OS 系统它是一款基于 Ubuntu 精心打磨美化的桌面 Linux 发行版，号称 “最美的 Linux”。 Elementary 最早是 Ubuntu 的一个美化主题项目，后来太受欢迎演变成了独立的发行版。</p><a id="more"></a><p>Elementary OS 由设计师主导开发，<em>风格与 macOS 有点相似</em>，它借鉴了 ChromeOS 的菜单设计，系统核心依然是 Ubuntu，可以<strong>「完全兼容所有 Ubuntu 软件包」</strong>。elementary OS 从界面外观到系统的各种设计元素都很精美，逼格甚高！如果你想体验下 Linux 与漂亮的界面设计，那么可以装来玩玩……</p><hr><p>于是， Shq就带着不怕<del>死</del>折腾的精神，用Vbox装了个 elementaryos的虚拟机<del>续你机</del></p><p>完成安装图片：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/ele/e.png" alt="elementaryos"></p><p>锁屏界面：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/ele/sp.png" alt="锁屏"></p><p>Terminal图片:</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/ele/terminal.png" alt="Terminal"></p><p>另附上我的Vbox图片：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/ele/vbox.png" alt="虚拟机管理"></p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略</p><p>(自己<del>Google</del>百度一下就行了(逃</p><p><a href="https://jingyan.baidu.com/article/acf728fd1af3d0f8e510a3df.html" target="_blank" rel="noopener">教程链接</a></p><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先，原装系统的包含的软件有：</p><ul><li>Midori浏览器</li><li>Docky</li><li>Geary Mail</li><li>Lingo 字典</li><li>Abiword文字处理器</li><li>Software Centre 软件中心</li><li>Shotwell</li><li>Totem 视频播放器</li><li>noise音乐播放器</li><li>Empathy</li><li>Nautilus-Elementary</li><li>scartch</li></ul><p>当然，这些软件还是不错的，但是既然我们要美化及配置，就要卸载预装软件。卸载软件的命令：</p><blockquote><p>$ sudo apt-get remove \&lt;name></p></blockquote><p><img src="https://github.com/Blog-Shq/Blog-Pictures/blob/master/ele/removes.png?raw=true" alt="示例图"></p><p>其中 \&lt;name>是指软件名称</p><p>这也不仅可以卸载预装软件，也可以卸载其他软件。</p><hr><p>By - Shq</p><p>(未完待<strong><del>续</del></strong>)</p>]]></content>
      
      <categories>
          
          <category> system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「折腾向」atom插件</title>
      <link href="/articles/atom-plugins/"/>
      <url>/articles/atom-plugins/</url>
      <content type="html"><![CDATA[<blockquote><p>atom是个十分强大的编辑器.</p></blockquote><a id="more"></a><p>在代码编辑器、文本编辑器领域，有着不少的「神器」级的产品，如历史悠久的 VIM、Emacs 以及如今当红的 SublimeText。另外还有 VS Code、EditPlus、NotePad++、UltraEdit 等一大堆流行的利器，可谓百家争鸣。</p><p>然而，作为目前全球范围内影响力最大的代码仓库/开源社区，GitHub 的程序员们并不满足于此。他们使用目前最先进流行的技术重新打造了一款称为“属于21世纪”的代码编辑器——<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>， 它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，支持插件扩展，可配置性非常高……</p><h2 id="ATOM-由-GitHub-打造更为先进的编辑器"><a href="#ATOM-由-GitHub-打造更为先进的编辑器" class="headerlink" title="ATOM - 由 GitHub 打造更为先进的编辑器"></a>ATOM - 由 GitHub 打造更为先进的编辑器</h2><p><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 代码编辑器支持 Windows、Mac、Linux 三大桌面平台，完全免费，并且已经在 GitHub 上开放了全部的源代码。在经过一段长时间的迭代开发和不断改进后，<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 终于从早期的测试版达到了 1.0 正式版了！相比之前的版本，在性能和稳定性方面都有着显著的改善。</p><h3 id="Atom-代码编辑器"><a href="#Atom-代码编辑器" class="headerlink" title="Atom 代码编辑器"></a>Atom 代码编辑器</h3><p>开发团队将 <a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 称为一个“为 21 世纪创造的可配置的编辑器”，它拥有非常精致细腻的界面，并且可配置项丰富，加上它提供了与 SublimeText 上类似的 Package Control (包管理)功能，人们可以非常方便地安装和管理各种插件，并将 <a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 打造成真正适合自己的开发工具。</p><p>作为一个现代的代码编辑器，<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 有着各种流行编辑器都有的特性，功能上非常丰富，支持各种编程语言的代码高亮(<em>HTML / CSS / Javascript / PHP / Python / C / C++ / Objective C / Java / JSON / Perl / CoffeeScript / Go / Sass / YAML / Markdown </em>等等)、 与大多数其他编辑器相比，Atom的语言支持已经算是覆盖非常全面了。另外，它的代码补全功能（也叫Snippets） 也非常好用，你只需输入几个字符即可展开成各种常用代码，可以极大提高编程效率。</p><p>另外，<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>同样支持 SublimeText 的几个重要的功能，譬如 Goto Anything、Goto Symbol、Goto Line、命令面板等等，就连快捷键也是一模一样的！相信 ST 的用户将会比较轻松地过渡到 Atom 去。实际上，从功能上来看，目前的 Atom 编辑器基本就是 Sublime 的一个复刻版，只是技术实现方式不同，插件的技术也有所差异。</p><h3 id="和-GIT-完美结合工作"><a href="#和-GIT-完美结合工作" class="headerlink" title="和 GIT 完美结合工作"></a>和 GIT 完美结合工作</h3><p><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 编辑器可以和 GIT 完美结合，所有对代码、文本的修改都能体现在编辑器的界面上。比如在文件内新写的代码会在左边标记为绿色，删除的标记为红色，修改的标记为黄色。在左边的目录导航也能方便的看到文件改动：有改动的文件其文件名和所在文件夹名都会被标记为高亮显示。编辑器底部会显示当前所在分支和对文件的修改行数统计，对于 GIT 用户来说非常方便。</p><h3 id="基于-WEB-技术构建"><a href="#基于-WEB-技术构建" class="headerlink" title="基于 WEB 技术构建"></a>基于 WEB 技术构建</h3><p>和之前介绍过的微软 Visual Studio Code 编辑器一样，Atom 也是基于 WEB 技术（Chromium+Node.js）开发的，简单理解的话编辑器本身其实是一个跑在本地的网页，这足以让无数 WEB 工程师为之兴奋！用户可以用Javascript来编写编辑器插件，用 CSS把主题界面改成任何你喜欢的样式等，这使得编写插件、主题、二次开发的门槛的降低了许多。这也能解释从 Atom 发布到现在不长的时间里，Atom的 Package 和主题数量都快速增长上来了。</p><p><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 主题</p><p>不过，也正因为它基于WEB 技术构建的，目前处于初步阶段的 Atom 在性能上与传统的编辑器还有点差距，在打开大文件时尤为明显，而在一些机器上也容易出现 CPU 占用率过高等问题，这一点确实有待改进，而且还是需要大幅改进。</p><h2 id="Atom-编辑器到底怎么样？"><a href="#Atom-编辑器到底怎么样？" class="headerlink" title="Atom 编辑器到底怎么样？"></a>Atom 编辑器到底怎么样？</h2><p>那么，很多人关心的是，Atom 与主流的编辑器对比会怎么样？其实，在我看来， Atom 目前还不太适合用做主力编辑器，虽然它的功能与 SublimeText 较为接近，但现在的它和 Sublime 相比还是稚嫩了一点，毕竟现在Sublime 已经非常成熟了，后者有很全面的内置功能，也有非常丰富的插件包和活跃的社区，而 Atom 则还需给予时间让其发展。</p><p>不过由于 Atom 是由 Github 维护的，它拥有非常强大的后台。并且那里有着大量极为优秀的编程爱好者，也是极客们的聚集地，相信在不久的将来Atom一定也会拥有不少新的插件包，而性能方面的缺点迟早也会被解决掉。</p><p>对于喜欢追求新鲜技术的极客和程序员们，<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 肯定将会是你的一个不错的新玩物，毕竟它是开源社区的产物，并且也代表着 WEB 技术进入桌面程序开发的新方向。纵使目前它还有不少的进步的空间，但一旦它解决了性能问题、建立了丰富强大的插件库，开源且跨平台的 <a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> 编辑器将会成为业界新宠。</p><p>而对于原版的<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>，我们当然是不满足的，接下来是我推荐的几款插件，可以使你的<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>更加的好用。</p><hr><p>minimap 插件</p><p>让你了解当前屏幕所处相对位置</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/atom/minimap.jpg" alt="1"></p><p>安装命令：</p><blockquote><p>$ apm install minimap</p></blockquote><hr><p>最后是重磅的 terminal-plus</p><p>Atom 中有了 terminal-plus 简直可以完全弃用系统控制台了。</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/atom/terminal-plus1.jpg" alt="2"></p><blockquote><p>cmd+shift+t 开启新控制台<br>ctrl+` 打开 /关闭 控制台</p></blockquote><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/atom/terminal-plus2.jpg" alt="3"></p><blockquote><p>cmd+shift+j/k 切换控制台</p></blockquote><p>另外，通过导航栏还可以对控制台导航进行命名或设置颜色，非常方便。</p><p>安装命令：</p><blockquote><p>$ apm install terminal-plus</p></blockquote><hr><p>未完待续</p><p>随后贴上我安装插件的所有命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apm install minimap</span><br><span class="line">apm install activate-power-mode</span><br><span class="line">apm install color-picker</span><br><span class="line">apm install file-icons</span><br><span class="line">apm install browser-plus</span><br><span class="line">apm install linter</span><br><span class="line">apm install tool-bar</span><br><span class="line">apm install atom-bautifiy</span><br><span class="line">apm install markdown-scroll-sync</span><br><span class="line">apm install playyoutube</span><br><span class="line">apm install linter-gcc</span><br><span class="line">apm install linter-ui-default</span><br><span class="line">apm install tree-view-sort</span><br><span class="line">apm install markdown-preview-enhanced</span><br><span class="line">apm install activate-power-mode</span><br><span class="line">apm install terminal-plus</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Settings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atom </tag>
            
            <tag> plugins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>故人不复</title>
      <link href="/articles/poem1/"/>
      <url>/articles/poem1/</url>
      <content type="html"><![CDATA[<blockquote><p>故人不复</p></blockquote><a id="more"></a><center>–shq</center><center><br>浮萍彷徨，清流冷淌。还余旧年，月色潇湘。<br>忆浊茶醉，夜宿雕梁，追忆此情，哪辨鸳鸯。<br>擦肩邂逅，尽生难忘。执伞同行，烟雨茫茫。<br>转瞬之间，即成过往。既不回头，何必不忘。<br>西风微凉，红笺玉蔷。秋水未央，霜满松堂。<br>寻觅玖廊，芙蓉微凉，故人不复，寸裂柔肠。<br></center><hr><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=459434585&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 《烟雨茫茫》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划算法（一）</title>
      <link href="/articles/dynamic-planning/"/>
      <url>/articles/dynamic-planning/</url>
      <content type="html"><![CDATA[<p>动态规划是解决问题的一种十分常用的方法</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>动态规划过程是：</p><p>每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><hr><h2 id="基本思想-amp-amp-策略"><a href="#基本思想-amp-amp-策略" class="headerlink" title="基本思想 &amp;&amp; 策略"></a>基本思想 &amp;&amp; 策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><hr><h2 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ul><hr><h2 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a>求解的基本步骤</h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><ul><li><p>分析最优解的性质，并刻画其结构特征。</p></li><li><p>递归的定义最优解。</p></li><li><p>以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p></li><li><p>根据计算最优值时得到的信息，构造问题的最优解</p></li></ul><h2 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a>算法实现的说明</h2><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li><p>问题的阶段</p></li><li><p>每个阶段的状态</p></li><li><p>从前一个阶段转化到后一个阶段之间的递推关系。</p></li></ul><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><center>f(n,m)=max{f(n-1,m),f(n-1,m-w[n])+P(n,m)}</center><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套矩形题目</span></span><br><span class="line"><span class="comment">// 本题状态转移方程：</span></span><br><span class="line"><span class="comment">// d(i) = max &#123; d(j) + 1|(i, j) 属于 E &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; ans = d[i];</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span> (G[i][j]) ans = max(ans, dp(j + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><p>大家可以敲一下<a href="https://www.luogu.org/problemnew/show/1002" target="_blank" rel="noopener">luogu P1002</a>的题</p><hr><p>By - Shq</p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=459434585&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/articles/dijkstra/"/>
      <url>/articles/dijkstra/</url>
      <content type="html"><![CDATA[<p>Dijkstra算法是求最短路径的一种十分好用的方法</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>Dijkstra算法是典型的单源最短路径算法,用于计算一个节点到其他所有节点的最短路径,主要特点是以起点为中心向外层扩展,直到扩展到终点为止.该算法要求图中不存在负权边.</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>设G=(V,E)是一个带权的有向图, 把图中顶点集合分为两组,第一组为已求出最短路径的顶点集合(用S表示,初始时S中只有一个源点，以后每求得一条最短路径，就将加入到集合S中,直到全部顶点都加到S中,算法就结束了),第二组为其余未确定最短路径的顶点集合(用U表示),按照最短路径长度的递增次序依次把第二组的顶点加入到S中，在加入过程中,总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度, 此外,每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度,U中的顶点的距离,是从v到此顶点只包含S中的顶点为中间顶点的当前最短路径长度.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码：</p><p><a href="https://github.com/liuhangyang/Data_Structure_and_Algorithm/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0/linjiebiao.c" target="_blank" rel="noopener">https://github.com/liuhangyang/Data_Structure_and_Algorithm/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0/linjiebiao.c</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AdjList *<span class="title">Created_Graph</span><span class="params">(AdjList *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,n1,n2,weight;</span><br><span class="line">    ArcNode *s;</span><br><span class="line">    <span class="keyword">char</span> vex1,vex2;</span><br><span class="line">    G=(AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顶点的个数和边数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;G-&gt;vexnum,&amp;G-&gt;arcnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入顶点:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G-&gt;vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No.%d号顶点的值:"</span>,i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;G-&gt;vertex[i].vexdata);</span><br><span class="line">        G-&gt;vertex[i].head=(ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode)); <span class="comment">//为每个头节点开辟空间;有头节点的链表;</span></span><br><span class="line">        G-&gt;vertex[i].head-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//头节点指向为空;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入由两个顶点构成的边:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=G-&gt;arcnum;k++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d条边:"</span>,k);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c%c"</span>,&amp;vex1,&amp;vex2);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G-&gt;vexnum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;vertex[i].vexdata == vex1)&#123;  </span><br><span class="line">                n1=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;vertex[i].vexdata == vex2)&#123;</span><br><span class="line">                n2=i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入权值:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;weight);</span><br><span class="line">        s=(ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        s-&gt;adjvex = n2;</span><br><span class="line">        s-&gt;weight=weight;</span><br><span class="line">        Insert(&amp;G-&gt;vertex[n1],s);</span><br><span class="line">        <span class="comment">/*如果是有向图，则下面的语句去掉就行*/</span></span><br><span class="line">       <span class="comment">/*s=(ArcNode *)malloc(sizeof(ArcNode));</span></span><br><span class="line"><span class="comment">        s-&gt;adjvex = n1;</span></span><br><span class="line"><span class="comment">        s-&gt;weight=weight;</span></span><br><span class="line"><span class="comment">       Insert(&amp;G-&gt;vertex[n2],s);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(AdjList *G,<span class="keyword">int</span> start,<span class="keyword">int</span> disk[],<span class="keyword">int</span> path[][MAXVEX])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,mindist,k,t;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=G-&gt;vexnum;i++)&#123;    <span class="comment">//初始化最短路径数组disk,和标记此顶点是否已经找到最短路径的path[i][0],等于0表示没有找到,等于1表示找到.</span></span><br><span class="line">        disk[i]=INFINE;</span><br><span class="line">        path[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p=G-&gt;vertex[start].head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;                                  <span class="comment">//保存源点到和此源点相关的顶点的路径.</span></span><br><span class="line">        disk[p-&gt;adjvex]=p-&gt;weight;</span><br><span class="line">        path[p-&gt;adjvex][<span class="number">1</span>]=start;</span><br><span class="line">        path[p-&gt;adjvex][<span class="number">2</span>]=p-&gt;adjvex;</span><br><span class="line">        path[p-&gt;adjvex][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">         p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    path[start][<span class="number">0</span>]=<span class="number">1</span>;               <span class="comment">//源点标记为为1，其最短路径为0.此顶点以后不会再用到</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=G-&gt;vexnum;i++)&#123;                <span class="comment">//选择最最短的路径</span></span><br><span class="line">         mindist=INFINE;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=G-&gt;vexnum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path[j][<span class="number">0</span>] &amp;&amp; disk[j] &lt; mindist)&#123;</span><br><span class="line">                k=j;                                         </span><br><span class="line">                mindist=disk[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mindist == INFINE)&#123;         <span class="comment">//如果没有找到最短的路径，则说明从此源点不能到任何其他顶点，直接返回.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[k][<span class="number">0</span>]=<span class="number">1</span>;                  <span class="comment">//标记找到最小路径的顶点，此顶点以后不会再用到.</span></span><br><span class="line">        p=G-&gt;vertex[k].head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path[p-&gt;adjvex][<span class="number">0</span>]&amp;&amp; disk[p-&gt;adjvex] &gt; disk[k]+ p-&gt;weight)&#123;     <span class="comment">//更新disk，使其从保持从源点到和此顶点相关的顶点的路径最短.           </span></span><br><span class="line">                <span class="comment">//printf("p-&gt;ad:%d ",p-&gt;adjvex);</span></span><br><span class="line">                disk[p-&gt;adjvex]=disk[k]+p-&gt;weight;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(path[k][t]!=<span class="number">0</span>)      <span class="comment">//记录最新的路径</span></span><br><span class="line">                &#123;</span><br><span class="line">                    path[p-&gt;adjvex][t]=path[k][t];</span><br><span class="line">                    t++;</span><br><span class="line">                &#125;</span><br><span class="line">                path[p-&gt;adjvex][t]=p-&gt;adjvex;</span><br><span class="line">                path[p-&gt;adjvex][t+<span class="number">1</span>]=<span class="number">0</span>;                       <span class="comment">//path[i][t+1]之前的都是最短路径所要经过的顶点，从t+1这里停止,作为最后输出路径的判断条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，明显指针的方法太毒瘤了，不如我们换种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnum = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxint = <span class="number">999999</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v, <span class="keyword">int</span> *dist, <span class="keyword">int</span> *prev, <span class="keyword">int</span> c[maxnum][maxnum])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> s[maxnum];    <span class="comment">// 判断是否已存入该点到S集合中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = c[v][i];</span><br><span class="line">        s[i] = <span class="number">0</span>;     <span class="comment">// 初始都未用过该点</span></span><br><span class="line">        <span class="keyword">if</span>(dist[i] == maxint)</span><br><span class="line">            prev[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次将未放入S集合的结点中，取dist[]最小值的结点，放入结合S中</span></span><br><span class="line">    <span class="comment">// 一旦S包含了所有V中顶点，dist就记录了从源点到所有其他顶点之间的最短路径长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = maxint;</span><br><span class="line">        <span class="keyword">int</span> u = v;</span><br><span class="line">        <span class="comment">// 找出当前未使用的点j的dist[j]最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">            <span class="keyword">if</span>((!s[j]) &amp;&amp; dist[j]&lt;tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;              <span class="comment">// u保存当前邻接点中距离最小的点的号码</span></span><br><span class="line">                tmp = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;    <span class="comment">// 表示u点已存入S集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新dist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">            <span class="keyword">if</span>((!s[j]) &amp;&amp; c[u][j]&lt;maxint)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> newdist = dist[u] + c[u][j];</span><br><span class="line">                <span class="keyword">if</span>(newdist &lt; dist[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = newdist;</span><br><span class="line">                    prev[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchPath</span><span class="params">(<span class="keyword">int</span> *prev,<span class="keyword">int</span> v, <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[maxnum];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">    que[tot] = u;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">int</span> tmp = prev[u];</span><br><span class="line">    <span class="keyword">while</span>(tmp != v)</span><br><span class="line">    &#123;</span><br><span class="line">        que[tot] = tmp;</span><br><span class="line">        tot++;</span><br><span class="line">        tmp = prev[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    que[tot] = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tot; i&gt;=<span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; que[i] &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; que[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// 各数组都从下标1开始</span></span><br><span class="line">    <span class="keyword">int</span> dist[maxnum];     <span class="comment">// 表示当前点到源点的最短路径长度</span></span><br><span class="line">    <span class="keyword">int</span> prev[maxnum];     <span class="comment">// 记录当前点的前一个结点</span></span><br><span class="line">    <span class="keyword">int</span> c[maxnum][maxnum];   <span class="comment">// 记录图的两点间路径长度</span></span><br><span class="line">    <span class="keyword">int</span> n, line;             <span class="comment">// 图的结点数和路径数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入结点数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 输入路径数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">    <span class="keyword">int</span> p, q, len;          <span class="comment">// 输入p, q两点及其路径长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化c[][]为maxint</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">            c[i][j] = maxint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; ++i)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; len;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; c[p][q])       <span class="comment">// 有重边</span></span><br><span class="line">        &#123;</span><br><span class="line">            c[p][q] = len;      <span class="comment">// p指向q</span></span><br><span class="line">            c[q][p] = len;      <span class="comment">// q指向p，这样表示无向图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        dist[i] = maxint;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%8d"</span>, c[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dijkstra(n, <span class="number">1</span>, dist, prev, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最短路径长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"源点到最后一个顶点的最短路径长度: "</span> &lt;&lt; dist[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"源点到最后一个顶点的路径为: "</span>;</span><br><span class="line">    searchPath(prev, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，代码就结束了</p><hr><p>By - Shq</p>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「折腾向」文章实施加密措施</title>
      <link href="/articles/use-hexo2/"/>
      <url>/articles/use-hexo2/</url>
      <content type="html"><![CDATA[<blockquote><p>即使是最简单的密码功能也足以阻止90%的访问者</p></blockquote><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>一开始使用Hexo的时候，是喜欢它的简单：因为可以直接编译成纯静态文件，方便部署。可是在使用过程中，又发现诸多不便：也因为它全是纯静态页面。突发奇想，能不能给文章加上一个加密访问的功能……</p><p>在经过实践之后，运用到自己博客中，发现有不少的访客对这个功能甚是感兴趣，所以也就在这里找个时间写写自己加密的小诀窍吧算是。</p><h3 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h3><p>由于 Hexo 最终编译出来的文件是纯静态的，也就意味着文章的所有信息其实还是原封不动展示在页面中的，当你输入一篇文章的网址，所有的内容就已经跟随网络传输过来了。那我博客使用的加密是怎么实现的呢？</p><p>这就要讲到 js 的阻塞机制了，在以往的经验中，当页面中有调用<code>alert();</code>函数的时候，整个页面会停止运行，直到你点击确定之后，页面的中的代码才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是<code>alert</code>只有提醒的功能，没有输入的功能，所以这里要用到的是<code>promt</code>函数。例子参见如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> password = promt(<span class="string">'请输入文章密码'</span>);</span><br><span class="line">alert(password);</span><br></pre></td></tr></table></figure><h3 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h3><p>究竟要把上述代码加在哪里呢？<br>找到<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件。<br>按道理是添加在任何地方都行，但是推荐加在所有的<code>&lt;meta&gt;</code>标签之后，个人建议，<strong>仅做参考</strong>。以下是我加的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">alert(&apos;密码错误！&apos;);</span><br><span class="line">history.back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果你好奇<code>page.password</code>是什么东西，那么恭喜你，你对 Hexo 的结构还是很熟悉的。<code>page</code>这个变量就是你在<code>hexo new</code>的时候生成文件中最顶部的东西，以下我给出这篇文章的头部参考：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo文章简单加密访问</span><br><span class="line">date: 2016-12-01 10:45:29</span><br><span class="line">tags: hexo</span><br><span class="line">categories: 博客</span><br><span class="line">keywords:</span><br><span class="line"><span class="code">- Hexo</span></span><br><span class="line"><span class="code">- 加密</span></span><br><span class="line">description: 文章访问密码：password</span><br><span class="line">password: password</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本来只是简单的纯静态页面，但是经历不断的更新和改进，便有了静态页面统计访问量的工具；有了静态页面添加评论的工具；甚至有了静态页面进行搜索的功能等等。个人想出来的静态页面加密功能根本算不上技术上的创新，只能说是一点小技巧的应用吧，小技巧也能迷惑住大家的眼睛，也算是喜事一件。</p>]]></content>
      
      <categories>
          
          <category> 《hexo的玄学用法系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>prims详解</title>
      <link href="/articles/prims/"/>
      <url>/articles/prims/</url>
      <content type="html"><![CDATA[<p>再上一篇最小生成树的文章中，我们介绍了Kruskal算法和Prim算法，但是由于时间仓促，没详细介绍了Prim算法，在这篇文章中，我们介绍一下Prim算法</p><a id="more"></a><p>图解：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims1.png" alt="img"></p><p>设置2个数据结构：</p><p> $ lowcost[i] $ :表示以i为终点的边的最小权值,当 $ lowcost[i]=0 $ 说明以i为终点的边的最小权值 $ =0 $ ,也就是表示 $ i $ 点加入了MST</p><p> $ mst[i]: $ 表示对应 $ lowcost[i] $ 的起点，即说明边 $ &lt;mst[i],i&gt; $ 是MST的一条边，当 $ mst[i]=0 $ 表示起点i加入MST</p><p>我们假设 $ V1 $ 是起始点，进行初始化（*代表无限大，即无通路）：</p><p> $ lowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=<em>，lowcost[6]=</em> $ </p><p> $ mst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1， $ （所有点默认起点是 $ V_1 $ ）</p><p>明显看出，以 $ V3 $ 为终点的边的权值最小 $ =1 $ ，所以边 $ &lt;mst[3],3&gt;=1 $ 加入MST</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims2.png" alt="img"></p><p>此时，因为点V3的加入，需要更新lowcost数组和mst数组：</p><p> $ lowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4  $ </p><p> $ mst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3 $ </p><p>明显看出，以 $ V6 $ 为终点的边的权值最小 $ =4 $ ，所以边 $ &lt;mst[6],6&gt;=4 $ 加入MST</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims3.png" alt="img"></p><p>此时，因为点 $ V6 $ 的加入，需要更新 $ lowcost $ 数组和 $ mst $ 数组：</p><p> $ lowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0 $ </p><p> $ mst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0 $ </p><p>明显看出，以V4为终点的边的权值最小=2，所以边 $ &lt;mst[4],4&gt;=4 $ 加入MST</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims4.png" alt="img"></p><p>此时，因为点 $ V4 $ 的加入，需要更新 $ lowcost $ 数组和 $ mst $ 数组：</p><p> $ lowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0 $ </p><p> $ mst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0 $ </p><p>明显看出，以V2为终点的边的权值最小=5，所以边\&lt;mst[2],2>=5加入MST</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims5.png" alt="img"></p><p>此时，因为点 $ V2 ​$ 的加入，需要更新 $ lowcost ​$ 数组和 $ mst ​$ 数组：</p><p> $ lowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0 $ </p><p> $ mst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0 $ </p><p>很明显，以 $ V5 $ 为终点的边的权值最小=3，所以边 $ &lt;mst[5],5&gt;=3 $ 加入MST</p><p> $ lowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0 $ </p><p> $ mst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0 $ </p><p>至此，MST构建成功，如图所示：</p><p><img src="https://raw.githubusercontent.com/Blog-Shq/Blog-Pictures/master/Prims/Prims6.png" alt="img"></p><hr><p>By - Shq</p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=31654455&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/articles/Minimum-spanning-tree/"/>
      <url>/articles/Minimum-spanning-tree/</url>
      <content type="html"><![CDATA[<h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><p>kruskal算法适用于求<strong>稀疏图</strong>的最小生成树。</p><p>它是通过<strong>遍历边</strong>来求出最小生成树的。</p><a id="more"></a><hr><p>tips> 时间复杂度:O(elog_e)(e为边数)</p><hr><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><ul><li>因为要求最小生成树，所以对于我们找出的最小生成树来说，边权越小自然越好，所以我们第一步就要以边权为关键字对所有边进行<strong>升序排序</strong>。</li></ul><hr><p>tips> 这也是为什么时间复杂度是O(elog_e)的原因</p><p>tips> 所以我们在这里不推荐使用连接表储存边，反而直接用结构体把关键讯息存下来即可</p><hr><ul><li>接下来，从最小边开始遍历，依次用<strong>并查集</strong>处理边。对于一条新遍历到的边(假设是u,v 两点相连的边，权值为w )来说，如果u,v, 不在同一并查集中，说明这是一条新边，把它的权值w 加入我们的答案中，并且将v 点合并到u 点的并查集中。</li></ul><hr><p>tips> 在这一步之前，千万不要忘记将并查集初始化！</p><hr><ul><li>因为最小生成树的定义特点，当选中<strong>n-1条边</strong>时，最小生成树就形成了，所以我们在遍历中特判一下，即时退出循环就可以了。</li></ul><hr><p>tips> 这一步可以用一个变量(如cnt之类的)存选中边数，这个操作每次和答案更新同时进行。</p><p>tips> 如果遍历完所有边都没有选到n-1条，那么这张图自然无法形成最小生成树</p><hr><h2 id="其他奇怪的事情"><a href="#其他奇怪的事情" class="headerlink" title="其他奇怪的事情"></a>其他奇怪的事情</h2><hr><ul><li><strong>Q:问我啥时候不能形成最小生成树？</strong></li></ul><p>A:那么如果只有一个点的时候(连边都没有)也是一张图，但没有最小生成树。虽然例子极端，我觉得吼啊！</p><ul><li><strong>Q:为什么是n-1条边？</strong></li></ul><p>A:这是最小生成树的定义，自己去网上搜索一下吧或者自己想一想就出来喽。</p><ul><li><strong>Q:无向图需要开两倍边吗？</strong></li></ul><p>A:因为我们用并查集处理，只考虑边联通的两点之间是否在一个并查集，只要其中有一点不在并查集中，自然就是我们要找的新边。</p><hr><h6 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a><del>算法模拟</del></h6><p><del>不模拟，太麻烦。</del></p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="noopener">P3366 【模板】最小生成树</a></p><p>这是一道裸最小生成树的题，可以直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    ll u,v,w;</span><br><span class="line">&#125;e[<span class="number">200000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> edge &amp;a,<span class="keyword">const</span> edge &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">ll f[<span class="number">200000</span>+<span class="number">10</span>],n,m,ans,cnt;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]!=x) f[x]=find(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(e,e+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ll u=e[i].u, v=e[i].v, w=e[i].w;</span><br><span class="line">        ll fu=find(u), fv=find(v);</span><br><span class="line">        <span class="keyword">if</span>(fu==fv) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=w;</span><br><span class="line">        f[fv]=fu; cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="comment">//并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们只储存边的讯息即可，不用连接表</span></span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="keyword">if</span>(cnt!=n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"orz"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍一下另一种算法–Prims算法</p><h1 id="Prims算法"><a href="#Prims算法" class="headerlink" title="Prims算法"></a>Prims算法</h1><p>Prim算法是从点的方面考虑构建一颗MST，大致思想是：设图G顶点集合为U，首先任意选择图G中的一点作为起始点a，将该点加入集合V，再从集合U-V中找到另一点b使得点b到V中任意一点的权值最小，此时将b点也加入集合V；以此类推，现在的集合V={a，b}，再从集合U-V中找到另一点c使得点c到V中任意一点的权值最小，此时将c点加入集合V，直至所有顶点全部被加入V，此时就构建出了一颗MST。因为有N个顶点，所以该MST就有N-1条边，每一次向集合V中加入一个点，就意味着找到一条MST的边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5001</span>,INF=<span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">int</span> n,e1,e;</span><br><span class="line"><span class="keyword">int</span> w[M][M];</span><br><span class="line"><span class="keyword">int</span> minc[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,count=<span class="number">0</span>,min,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)minc[i]=w[s][i];</span><br><span class="line">    minc[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        min=INF;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minc[j] &amp;&amp; minc[j]&lt;min)&#123;</span><br><span class="line">                min=minc[j];</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minc[k]=<span class="number">0</span>;</span><br><span class="line">        count+=min;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[k][j]&lt;minc[j])</span><br><span class="line">                minc[j]=w[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"mst.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=M;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=M;j++)w[i][j]=INF;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t3);</span><br><span class="line">        <span class="keyword">if</span>(t3&lt;w[t1][t2])w[t2][t1]=w[t1][t2]=t3;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体关于prim的一些内容，请看我写的另一篇Blog\&lt;<a href="https://blog-shq.github.io/2017/12/30/prims/" target="_blank" rel="noopener">prim详解</a>>.</p><hr><p>from: <a href="https://luogu.org" target="_blank" rel="noopener">Luogu</a></p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=459434585&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 《算法详解》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[USACO09OCT]Heat Wave热浪</title>
      <link href="/articles/HeatWave/"/>
      <url>/articles/HeatWave/</url>
      <content type="html"><![CDATA[<p>这是一道经典的dijkstra的题</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The good folks in Texas are having a heatwave this summer. Their Texas Longhorn cows make for good eating but are not so adept at creating creamy delicious dairy products. Farmer John is leading the charge to deliver plenty of ice cold nutritious milk to Texas so the Texans will not suffer the heat too much.</p><p>FJ has studied the routes that can be used to move milk from Wisconsin to Texas. These routes have a total of T (1 &lt;= T &lt;= 2,500) towns conveniently numbered   1..T along the way (including the starting and ending towns). Each town (except the source and destination towns) is connected to at least two other towns by bidirectional roads that have some cost of traversal (owing to gasoline consumption, tolls, etc.). Consider this map of seven towns; town 5 is the</p><p>source of the milk and town 4 is its destination (bracketed integers represent costs to traverse the route):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          [1]----1---[3]-</span><br><span class="line">         /               \</span><br><span class="line">  [3]---6---[4]---3--[3]--4</span><br><span class="line"> /               /       /|</span><br><span class="line">5         --[3]--  --[2]- |</span><br><span class="line"> \       /        /       |</span><br><span class="line">  [5]---7---[2]--2---[3]---</span><br><span class="line">        |       /</span><br><span class="line">       [1]------</span><br></pre></td></tr></table></figure><p>Traversing 5-6-3-4 requires spending 3 (5-&gt;6) + 4 (6-&gt;3) + 3 (3-&gt;4) = 10 total expenses.</p><p>Given a map of all the C (1 &lt;= C &lt;= 6,200) connections (described as two endpoints R1i and R2i (1 &lt;= R1i &lt;= T; 1 &lt;= R2i &lt;= T) and costs (1 &lt;= Ci &lt;= 1,000), find the smallest total expense to traverse from the starting town Ts (1 &lt;= Ts &lt;= T) to the destination town Te (1 &lt;= Te &lt;= T).<br>德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p><p>FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T (1 &lt;= T &lt;= 2,500)个城镇，方便地标号為1到T。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。</p><p>给定一个地图，包含C (1 &lt;= C &lt;= 6,200)条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re (1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)，和花费(1 &lt;= Ci &lt;= 1,000)组成。求从起始的城镇Ts (1 &lt;= Ts &lt;= T)到终点的城镇Te(1 &lt;= Te &lt;= T)最小的总费用。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行: 4个由空格隔开的整数:  T, C, Ts, Te<br>第2到第C+1行: 第i+1行描述第i条道路。有3个由空格隔开的整数: Rs, Re和Ci</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7 11 5 4</span><br><span class="line">2 4 2</span><br><span class="line">1 4 3</span><br><span class="line">7 2 2</span><br><span class="line">3 4 3</span><br><span class="line">5 7 5</span><br><span class="line">7 3 3</span><br><span class="line">6 1 1</span><br><span class="line">6 3 4</span><br><span class="line">2 4 3</span><br><span class="line">5 6 3</span><br><span class="line">7 2 1</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">// #define LOCK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF  = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, c, S, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)  d[i]=a[st][i];</span><br><span class="line">    f[st] = <span class="literal">true</span>;d[st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minn=INF,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++)</span><br><span class="line">        <span class="keyword">if</span> ((!f[j]) &amp;&amp; (d[j] &lt; minn)) &#123;minn = d[j];k = j;&#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)  <span class="keyword">return</span>;</span><br><span class="line">        f[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++)</span><br><span class="line">             <span class="keyword">if</span> ((!f[j]) &amp;&amp; (d[k] + a[k][j] &lt; d[j])) d[j] = d[k] + a[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; c &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">10</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (a[x][y] &amp;&amp; a[x][y] &gt; z) &#123;a[x][y] = z;a[y][x] = z;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCKL</span></span><br><span class="line">    freopen (<span class="string">"1.in"</span> , <span class="string">"r"</span>, <span class="built_in">stdin</span> );</span><br><span class="line">    freopen (<span class="string">"1.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    read();</span><br><span class="line">    dijkstra(S);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[T];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>By - Shq</p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=459434585&auto=0&height=66"></iframe></center>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无题</title>
      <link href="/articles/somethinks1/"/>
      <url>/articles/somethinks1/</url>
      <content type="html"><![CDATA[<p>人生一梦，白云苍狗，错错对对，恩恩怨怨，终不过日月无声，水过无痕，所为弃者，一点执念而已。</p><a id="more"></a><p>心微动，奈何情已远，物也非，人也非，事事非，往日不可重。</p><p>时间很短，天涯很远，往后的一山一水，一朝一夕，自己安静地走完。倘若不慎走失迷途，跌入水中，也应该记得，有一条河流，叫重生。这世上任何地方，都可以生长；任何去处，都是归宿你。那么，别来找我，我亦不去寻你。守着剩下的流年，看一段岁月静好，现实安稳。</p><hr><p>有些事，我们明知道是错的，也要去坚持，因为不甘心；</p><p>有些人，我们明知道是爱的，也要去放弃，因为没结局；</p><p>有时候，我们明知道没路了，却还在前行，因为习惯了；</p>]]></content>
      
      <categories>
          
          <category> 《烟雨茫茫》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如果临沂的夜晚没有风</title>
      <link href="/articles/aboutBlog/"/>
      <url>/articles/aboutBlog/</url>
      <content type="html"><![CDATA[<p id="div-border-top-green">这座城市人很多，每天在路上都能看到好多拉着行李箱的人，不管他们是来到这座城市还是离开这座城市，至少他们都曾努力过。<br></p><a id="more"></a><p>上面说的文字和下面的文章没有一点关系。</p><p>其实呢，做Blog的网站有很多，比如 CSDN ，最近Luogu也推出了LuoguBlog，我也试了试这些Blog，但是都觉得不大好用，但是它们毕竟是一个技术类的博客网站，如果写一点生活杂谈还是不太好，而且 CSDN 上面挂载的广告，以及页面风格，我不太喜欢，因为我喜欢【精于心，简于形】。(强势插入广告23333)</p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 。 它有以下特点：</p><ul><li><h6 id="超快速度"><a href="#超快速度" class="headerlink" title="超快速度"></a>超快速度</h6><p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p></li><li><h6 id="支持Markdown"><a href="#支持Markdown" class="headerlink" title="支持Markdown"></a>支持Markdown</h6><p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p></li><li><h6 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h6><p>只需一条指令即可部署到Github Pages，或其他网站</p></li><li><h6 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h6><p>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a> 来快速的插入特定形式的内容。</p><p>这是我的第三个Blog了，中间失败了2个Blog，这几个Blog都是我随便乱改一些config文件导致的，<del>所以说不要总想搞一个大新闻</del>，也让我知道了一些大大小小的坑(比如hexo d后记得备份)，也曾迷茫，也曾彷徨。我也希望这次的Blog不要再炸了。</p><p>在用这个Github Page之前，我也<del>google</del>百度了一些关于如何搭网站之类的东西，比如域名空间之类的啊，我这个人有选择恐惧症，而且我想，域名空间搞好以后，还要自己写页面这些的。关键是还要设计博客风格，页面样式这些的，一想到这些，就感觉是一个不小的工程啊，后来才发现我多虑了。</p><p>后来无意中听一个dtz<a href="http://blog.aor.cn" target="_blank" rel="noopener">Wyh</a>的Blog，就知道了 Hexo 和 Next ，感觉风格和样式挺不错的，就去google了一些教程，自己搭了个Blog，也<del>自学</del>了Markdown</p><p>最后，鸣谢一下所有帮助过Shq的人</p><p><a href="http://blog.aor.cn" target="_blank" rel="noopener">@Wyh</a>,<a href="https://handwer-blog.github.io" target="_blank" rel="noopener">@Wzm</a>,<del><a href="http://www.jlacg.top" target="_blank" rel="noopener">@jlacg</a></del></p>]]></content>
      
      <categories>
          
          <category> 《hexo的玄学用法系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[转]Git学习的一些总结</title>
      <link href="/articles/aboutgit/"/>
      <url>/articles/aboutgit/</url>
      <content type="html"><![CDATA[<h2 id="git-简介"><a href="#git-简介" class="headerlink" title="git 简介"></a>git 简介</h2><p id="div-border-top-green">git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。<br></p><a id="more"></a><p>在 git 中，工作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><h2 id="实用指令详解"><a href="#实用指令详解" class="headerlink" title="实用指令详解"></a>实用指令详解</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。<br><code>git merge --no-ff -m &#39;merge with no-ff&#39; dev</code><br>因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。</p><p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。<br><code>git fetch &lt;远程主机名&gt;</code><br>上面命令将某个远程主机的更新，全部取回本地。<br>默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。<br><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code><br>比如，取回 origin 主机的 master 分支<br><code>git fetch origin master</code><br>所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。</p><p><code>git fetch -p</code> ：取回远程更新，删除不存在的分支。</p><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>git pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。<br><code>git pull origin next:master</code><br>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。<br><code>git pull origin master</code><br>上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。<br>git 也允许手动建立追踪关系。<br><code>git branch --set-upstream master origin/next</code><br>上面的命令指定 master 分支追踪 origin/next 分支。<br>如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。<br><code>git pull origin</code><br>上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。<br>如果当前分支只有一个追踪分支，连远程主机名都可以忽略。<br><code>git pull</code><br>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>如果合并需要采用 rebase 模式，可以使用 -rebase 选项。<br><code>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>git push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。<br><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。<br><code>git push origin master</code><br>上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。<br><strong>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</strong><br><code>git push origin :master</code><br>等同于<br><code>git push origin --delete master</code><br>上面命令表示删除 origin 主机的 master 分支。<br>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。<br><code>git push origin</code><br>上面命令表示，将当前分支推送到 origin 主机的对应分支。<br>如果当前分支只有一个追踪分支，那么主机名都可以省略。<br><code>git push</code><br>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。<br><code>git push -u origin master</code><br>上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。<br>不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。<br>git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。<br><code>git config --global push.default matching</code><br>或者<br><code>git config --global push.default simple</code><br>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。<br><code>git push --all origin</code><br>上面命令表示，将所有本地分支都推送到 origin 主机。<br>如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。<br><code>git push --force origin</code><br>上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。<br>最后，git push 不会推送标签(tag)，除非使用 -tags 选项。<br><code>git push origin --tags</code></p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><code>git log</code> 命令可以查看历史记录，<code>git log</code> 命令显示从最近到最远的提交日志；<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试 <code>git log --pretty=oneline</code> 。我们可以看到当前版本以及之前的版本日志以及版本号。<br>用 <code>git log --graph</code> 命令可以看到分支合并图。<br>或者两个参数一起用：<br><code>git log --graph --pretty=oneline</code><br><code>git log --graph --pretty=oneline --abbrev-commit</code><br>首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ， 当然往上100个版本写100个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code> 。<br>现在，我们要把当前版本回退到上一个版本，就可以使用 <code>git reset</code> 命令：<br><code>git reset --hard HEAD^</code><br>当你回退到了某个版本后，<code>git log</code> 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？<br>Git 提供了一个命令 <code>git reflog</code> 用来记录你的每一次命令</p><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>查看标签（用来标记标志性的稳定版本信息）<br>发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>相比于 commit 的版本号(40位16进制)，标签号则要好使的多。<br>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。</p><p><code>git tag [tag name]</code><br>如果没有标签名，则为查看所有标签，带标签名则为新建标签</p><p><code>git tag &lt;tag name&gt;</code> 就可以打一个新标签</p><p>还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。<br><code>git tag -a &lt;tag name&gt; -m &lt;comment&gt;</code> ：添加带注释的标签<br>eg: <code>git tag -a v1.2 -m &#39;version 1.2 released&#39;</code></p><p><code>git tag -a &lt;tag name&gt; &lt;md5&gt;</code> ：对某个版本打标签<br>默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？<br>方法是找到历史提交的 commit id，然后打上就可以了。<br><code>git log --pretty=oneline --abbrev-commit</code><br>比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：<br><code>git tag v1.2 6224937</code><br>再用命令 <code>git log</code> 查看标签</p><p>可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息</p><p>如果标签打错了，也可以删除：<br><code>git tag -d v1.2</code></p><p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code><br>eg: <code>git push origin v1.2</code></p><p>如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：<br><code>git tag -d v1.2</code><br>然后，从远程删除；删除命令也是 push ，但是格式如下：<br><code>git push origin :ref/tags/v1.2</code></p><p><code>git tag -l &#39;[expression]&#39;</code><br>查看那符合正则表达式的</p><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p><code>git stash</code><br>备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。<br><code>git stash pop</code><br>从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。<br><code>git stash list</code><br>显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。<br><code>git stash clear</code> : 清空 Git 栈。</p><p>使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 <code>git stash apply stash@{1}</code> 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。<br>在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。</p><p>看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。</p><p>注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。</p><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p>查看远程仓库名</p><p><code>git remote -v</code><br>查看远程仓库url</p><p><code>git remote add &lt;basename&gt; &lt;url&gt;</code><br>新增远程仓库</p><p><code>git remote show &lt;basename&gt;</code><br>查看远程仓库详细信息</p><p><code>git remote rename &lt;old basename&gt; &lt;new basename&gt;</code><br>重命名远程仓库</p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><code>git commit -a -m &#39;xx&#39;</code><br>暂存并提交</p><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><code>git branch</code><br>查看本地仓库分支</p><p><code>git branch -r</code><br>查看远程分支情况</p><p><code>git branch -a</code><br>查看本地和远程的所有分支情况</p><p><code>git branch -v</code><br>查看本地仓库分支最后一次提交情况</p><p><code>git branch -vv</code><br>查看分支跟踪情况</p><p><code>git branch &lt;branch name&gt;</code><br>新建分支</p><p><code>git branch -d &lt;branch name&gt;</code><br>删除分支</p><p><code>git branch -D &lt;branch name&gt;</code><br>强制删除分支</p><p><code>git branch [--merged | --no-merged]</code><br>查看已合并|未合并的本地仓库分支</p><p><code>git branch -u &lt;remote base&gt;/&lt;remote branch&gt;</code><br>修改当前跟踪分支</p><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p><code>git checkout -- [file]</code> ：恢复文件<br><code>git checkout -- demo.html</code> 意思就是，把 <code>demo.html</code> 文件在工作区的修改全部撤销，这里有两种情况：<br>一种是 <code>demo.html</code> 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是 <code>demo.html</code> 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。<br>总之，就是让这个文件回到最后一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>但是如果 <code>git add</code> 到暂存区了，在 commit 之前，想撤销：<br>Git 同样告诉我们，用命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。<br><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 <code>HEAD</code> 时，表示最新的版本。<br>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改：<br>还记得如果丢弃工作区的修改吗？<br>对的，使用：<code>git checkout -- demo.html</code></p><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p><p><code>git checkout -b [branchname] [tagname]</code><br>在特定的版本上创建一个新的分支并切换到此分支</p><p><code>git checkout -b [local branch] [remote base]/[remote branch]</code><br>将远程分支检出到本地分支，并追踪</p><p><code>git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;</code><br>让当前分支跟踪远程分支</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><code>git rebase [basebranch]</code><br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>git clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。<br>使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p><p><code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code><br>如果不写本地目录名，默认就是版本库的名字</p><h3 id="如何新建分支"><a href="#如何新建分支" class="headerlink" title="如何新建分支"></a>如何新建分支</h3><p>本地建立 branch 並立即切换到新分支<br><code>git checkout -b &lt;branch_name&gt;</code></p><p>下面的命令表示，在 <code>origin/master</code> 的基础上，创建一个分支。<br><code>git checkout -b newBranch origin/master</code></p><p>修改分支名称<br><code>git branch -m &lt;new_name&gt;</code></p><h3 id="从远程仓库拉取代码到本地仓库，并建立跟踪关系"><a href="#从远程仓库拉取代码到本地仓库，并建立跟踪关系" class="headerlink" title="从远程仓库拉取代码到本地仓库，并建立跟踪关系"></a>从远程仓库拉取代码到本地仓库，并建立跟踪关系</h3><p><code>git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt;</code></p><h3 id="如何在远程仓库新建一个分支"><a href="#如何在远程仓库新建一个分支" class="headerlink" title="如何在远程仓库新建一个分支"></a>如何在远程仓库新建一个分支</h3><p>新建一个本地分支，按照正常流程提交完代码后，推送到远程<br><code>git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code></p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><p><code>git diff HEAD -- demo.html</code><br>命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。</p><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除<br><code>git rm --cached [file]</code><br>不删除文件，只移除追踪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>文件 .gitignore 的格式规范如下：</p><ul><li><p>所有空行或者以注释符号 # 开头的目录都会被 git 忽略</p></li><li><p>可以使用标准的 glob 模式匹配</p></li><li><p>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的目录</p></li><li><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反</p><p>​</p></li></ul><h3 id="bug-分支"><a href="#bug-分支" class="headerlink" title="bug 分支"></a>bug 分支</h3><p>git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。<br><code>git stash</code><br>修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？<br><code>git stash list</code> ：查看 stash 列表(stash 是一个栈的结构)<br>git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一是用 <code>git stash apply</code> 恢复，但是恢复后，stash 内容并不删除，你需要用 <code>git stash drop</code> 来删除；<br>另一种方式是用 <code>git stash pop</code> ，恢复的同时把 stash 内容也删了；<br>你可以多次 stash ，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令：<br><code>git stash apply stash@{0}</code></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br>配置文件放哪了？<br>每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。</p><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p><code>git config -1</code></p><h3 id="设置git-push-默认"><a href="#设置git-push-默认" class="headerlink" title="设置git push 默认"></a>设置git push 默认</h3><p><code>git config --global push.default current</code></p><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p><code>git config --global alias.&lt;name&gt; &lt;commend&gt;</code><br>我的设置：<br><code>git config --global alias.st status</code><br><code>git config --global alias.cm &quot;commit -m&quot;</code><br><code>git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot;</code></p><h3 id="保存用户名和密码"><a href="#保存用户名和密码" class="headerlink" title="保存用户名和密码"></a>保存用户名和密码</h3><h4 id="对于http-s-协议，可以用下面命令临时缓存"><a href="#对于http-s-协议，可以用下面命令临时缓存" class="headerlink" title="对于http(s)协议，可以用下面命令临时缓存"></a>对于http(s)协议，可以用下面命令临时缓存</h4><p><code>git config --global credential.helper cache</code><br>开启linux缓存<br><code>git config --global credential.helper wincred</code><br>开启windows缓存</p><h4 id="对于-ssh-协议，可以用-ssh-key，具体教程网上很多"><a href="#对于-ssh-协议，可以用-ssh-key，具体教程网上很多" class="headerlink" title="对于 ssh 协议，可以用 ssh key，具体教程网上很多"></a>对于 ssh 协议，可以用 ssh key，具体教程网上很多</h4><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>git 中执行命令 <code>add .</code><br>报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n)</p><p>因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 <code>.exe</code> 文件，我们是不需要添加到版本管理工具的。所以我们选择 <code>n</code> 。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>git 中生成 sshkey: <code>ssh-keygen -t rsa -C &quot;youremail&quot;</code><br>这个<code>email</code>并没有什么用<br>所以我们使用<code>ssh-keygen -t rsa</code>来生成sshkey就可以了。<br>然后git中的配置文件：<br><code>git config --list</code><br><code>git config --global user.name &quot;yu&quot;</code><br><code>git config --global user.email &quot;react.dong.yu@gmail.com&quot;</code><br>这种配置将会对本地所有的git仓库有效。<br>那么在 push 的时候，远程就知道这个push来自于哪个email.<br>但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。<br>这个时候就可以不设置global的配置了，而是在自己的仓库中设置<br><code>git config --local user.email &quot;react.dong.yu@gmail.com&quot;</code></p><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。<br>有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：<br><code>git add App.class</code><br>如果你确实想添加该文件，可以用 -f 制添加到 git：<br><code>git add -f App.class</code><br>或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。<br>可以用 <code>git check-ignore</code> 命令检查：<br><code>git check-ignore -v App.class</code></p><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>为什么我把我生成的 ssh key 添加到了 github 中<br>然后 也 remote 了 <code>https://github.com/Blog-Shq/Xxx.git</code><br>为什么提交的时候报错，或者提示 输入密码账号是为什么</p><p>ssh key 是 ssh 协议的密钥，http 协议没权限</p><h3 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h3><p>git怎样删除未监视的文件 untracked files?<br>用 git clean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 删除 untracked files</span><br><span class="line">git clean -f</span><br><span class="line"> </span><br><span class="line"># 连 untracked 的目录也一起删掉</span><br><span class="line">git clean -fd</span><br><span class="line"> </span><br><span class="line"># 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span><br><span class="line">git clean -xfd</span><br><span class="line"> </span><br><span class="line"># 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span><br><span class="line">git clean -nxfd</span><br><span class="line">git clean -nf</span><br><span class="line">git clean -nfd</span><br></pre></td></tr></table></figure><h2 id="我的常用命令"><a href="#我的常用命令" class="headerlink" title="我的常用命令"></a>我的常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -avv</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">权威教程</a><br><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">Pro Git 简体中文版</a></p>]]></content>
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo的一些玄学操作</title>
      <link href="/articles/use-hexo/"/>
      <url>/articles/use-hexo/</url>
      <content type="html"><![CDATA[<h1 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h1><p id="div-border-top-green">hexo 是博客框架，将支持的类型的文件转换成静态Web页面(html+css+javascript)<br></p><a id="more"></a><p>在这里我就不赘述hexo 的安装使用过程了，大家可以自行<a href="http://www.google.com" target="_blank" rel="noopener">google</a>,google(百度也可以)上有很多关于此方面的内容，在这里，我就推荐一个教程:<a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">HEXO+Github,搭建属于自己的博客</a>,可以自行学习</p><h1 id="hexo的玄学操作"><a href="#hexo的玄学操作" class="headerlink" title="hexo的玄学操作"></a>hexo的玄学操作</h1><p>这里就不介绍一些基础操作了(<del>然而是我太懒</del>)，话不多说，下面就介绍一些hexo的玄学操作（<strong>其实是拓展功能</strong>）</p><p>首先，我们要明白：</p><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>我们约定，将前者称为 <strong>站点配置文件</strong>，后者称为 <strong>主题配置文件</strong></p></blockquote><h2 id="1-添加居中模块"><a href="#1-添加居中模块" class="headerlink" title="1. 添加居中模块"></a>1. 添加居中模块</h2><blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span>优秀的人，不是不合群，而是他们合群的人里面没有你<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-添加high一下"><a href="#2-添加high一下" class="headerlink" title="2. 添加high一下"></a>2. 添加high一下</h2><p>打开博客根目录 <code>\themes\next\layout\_partials\header.swig</code> ，在<br><code>&lt;ul&gt; ... /ul&gt;</code> 标签之间加入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">title</span>=<span class="string">"把这个链接拖到你的Chrome收藏夹工具栏中"</span> <span class="attr">href</span>=<span class="string">'javascript:(function() &#123;</span></span></span></span><br><span class="line"><span class="xml">    function c() &#123;</span></span><br><span class="line"><span class="xml">        var e = document.createElement("link");</span></span><br><span class="line"><span class="xml">        e.setAttribute("type", "text/css");</span></span><br><span class="line"><span class="xml">        e.setAttribute("rel", "stylesheet");</span></span><br><span class="line"><span class="xml">        e.setAttribute("href", f);</span></span><br><span class="line"><span class="xml">        e.setAttribute("class", l);</span></span><br><span class="line"><span class="xml">        document.body.appendChild(e)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function h() &#123;</span></span><br><span class="line"><span class="xml">        var e = document.getElementsByClassName(l);</span></span><br><span class="line"><span class="xml">        for (var t = 0; t <span class="tag">&lt; <span class="attr">e.length</span>; <span class="attr">t</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">            document.body.removeChild(e[t])</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function p() &#123;</span></span><br><span class="line"><span class="xml">        var e = document.createElement("div");</span></span><br><span class="line"><span class="xml">        e.setAttribute("class", a);</span></span><br><span class="line"><span class="xml">        document.body.appendChild(e);</span></span><br><span class="line"><span class="xml">        setTimeout(function() &#123;</span></span><br><span class="line"><span class="xml">            document.body.removeChild(e)</span></span><br><span class="line"><span class="xml">        &#125;, 100)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function d(e) &#123;</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            height : e.offsetHeight,</span></span><br><span class="line"><span class="xml">            width : e.offsetWidth</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function v(i) &#123;</span></span><br><span class="line"><span class="xml">        var s = d(i);</span></span><br><span class="line"><span class="xml">        return s.height &gt; e &amp;&amp; s.height <span class="tag">&lt; <span class="attr">n</span> &amp;&amp; <span class="attr">s.width</span> &gt;</span> t &amp;&amp; s.width <span class="tag">&lt; <span class="attr">r</span></span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function m(e) &#123;</span></span><br><span class="line"><span class="xml">        var t = e;</span></span><br><span class="line"><span class="xml">        var n = 0;</span></span><br><span class="line"><span class="xml">        while (!!t) &#123;</span></span><br><span class="line"><span class="xml">            n += t.offsetTop;</span></span><br><span class="line"><span class="xml">            t = t.offsetParent</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        return n</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function g() &#123;</span></span><br><span class="line"><span class="xml">        var e = document.documentElement;</span></span><br><span class="line"><span class="xml">        if (!!window.innerWidth) &#123;</span></span><br><span class="line"><span class="xml">            return window.innerHeight</span></span><br><span class="line"><span class="xml">        &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123;</span></span><br><span class="line"><span class="xml">            return e.clientHeight</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        return 0</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function y() &#123;</span></span><br><span class="line"><span class="xml">        if (window.pageYOffset) &#123;</span></span><br><span class="line"><span class="xml">            return window.pageYOffset</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function E(e) &#123;</span></span><br><span class="line"><span class="xml">        var t = m(e);</span></span><br><span class="line"><span class="xml">        return t &gt;= w &amp;&amp; t <span class="tag">&lt;<span class="name">=</span> <span class="attr">b</span> + <span class="attr">w</span></span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    function S() &#123;</span></span><br><span class="line"><span class="xml">        var e = document.createElement("audio");</span></span><br><span class="line"><span class="xml">        e.setAttribute("class", l);</span></span><br><span class="line"><span class="xml">        e.src = i;</span></span><br><span class="line"><span class="xml">        e.loop = false;</span></span><br><span class="line"><span class="xml">        e.addEventListener("canplay", function() &#123;</span></span><br><span class="line"><span class="xml">            setTimeout(function() &#123;</span></span><br><span class="line"><span class="xml">                x(k)</span></span><br><span class="line"><span class="xml">            &#125;, 500);</span></span><br><span class="line"><span class="xml">            setTimeout(function() &#123;</span></span><br><span class="line"><span class="xml">                N();</span></span><br><span class="line"><span class="xml">                p();</span></span><br><span class="line"><span class="xml">                for (var e = 0; e <span class="tag">&lt; <span class="attr">O.length</span>; <span class="attr">e</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">                    T(O[e])</span></span><br><span class="line"><span class="xml">                &#125;</span></span><br><span class="line"><span class="xml">            &#125;, 15500)</span></span><br><span class="line"><span class="xml">        &#125;, true);</span></span><br><span class="line"><span class="xml">        e.addEventListener("ended", function() &#123;</span></span><br><span class="line"><span class="xml">            N();</span></span><br><span class="line"><span class="xml">            h()</span></span><br><span class="line"><span class="xml">        &#125;, true);</span></span><br><span class="line">        e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;";</span><br><span class="line">        document.body.appendChild(e);</span><br><span class="line">        e.play()</span><br><span class="line">    &#125;</span><br><span class="line">    function x(e) &#123;</span><br><span class="line">        e.className += " " + s + " " + o</span><br><span class="line">    &#125;</span><br><span class="line">    function T(e) &#123;</span><br><span class="line">        e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]</span><br><span class="line">    &#125;</span><br><span class="line">    function N() &#123;</span><br><span class="line">        var e = document.getElementsByClassName(s);</span><br><span class="line">        var t = new RegExp("\\b" + s + "\\b");</span><br><span class="line">        for (var n = 0; n &lt; e.length; ) &#123;</span><br><span class="line">            e[n].className = e[n].className.replace(t, "")</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var e = 30;</span><br><span class="line">    var t = 30;</span><br><span class="line">    var n = 350;</span><br><span class="line">    var r = 350;</span><br><span class="line">    var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3";</span><br><span class="line">    var s = "mw-harlem_shake_me";</span><br><span class="line">    var o = "im_first";</span><br><span class="line">    var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];</span><br><span class="line">    var a = "mw-strobe_light";</span><br><span class="line">    var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";</span><br><span class="line">    var l = "mw_added_css";</span><br><span class="line">    var b = g();</span><br><span class="line">    var w = y();</span><br><span class="line">    var C = document.getElementsByTagName("*");</span><br><span class="line">    var k = null;</span><br><span class="line">    for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">        var A = C[L];</span><br><span class="line">        if (v(A)) &#123;</span><br><span class="line">            if (E(A)) &#123;</span><br><span class="line">                k = A;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (A === null) &#123;</span><br><span class="line">        console.warn("Could not find a node of the right size. Please try a different page.");</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">    S();</span><br><span class="line">    var O = [];</span><br><span class="line">    for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">        var A = C[L];</span><br><span class="line">        if (v(A)) &#123;</span><br><span class="line">            O.push(A)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="xml">    &#125;)()    '&gt;High一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-添加最近访客"><a href="#3-添加最近访客" class="headerlink" title="3. 添加最近访客"></a>3. 添加最近访客</h2><p>在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最近访客</span><br><span class="line">&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="4-鼠标点击小红心的设置"><a href="#4-鼠标点击小红心的设置" class="headerlink" title="4. 鼠标点击小红心的设置"></a>4. 鼠标点击小红心的设置</h2><ol><li>将 <a href="https://github.com/Blog-Shq/blog-shq.github.io/blob/master/js/src/love.js" target="_blank" rel="noopener">love.js</a> 文件添加到 \themes\next\source\js\src 文件目录下。</li><li>找到 <code>\themes\next\layout\_layout.swing</code> 文件，<strong>在文件的后面</strong>，<code>&lt;/body&gt;</code><strong>标签之前</strong>添加以下代码：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>(未完待<strong>续</strong>)</p>]]></content>
      
      <categories>
          
          <category> 《hexo的玄学用法系列》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
